
build/ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800100  00001dd2  00001e66  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001dd2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000210  00800172  00800172  00001ed8  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00001ed8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001eec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000720  00000000  00000000  00001f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001a12f  00000000  00000000  0000264c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000048cf  00000000  00000000  0001c77b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007dec  00000000  00000000  0002104a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001424  00000000  00000000  00028e38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002374  00000000  00000000  0002a25c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006858  00000000  00000000  0002c5d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a18  00000000  00000000  00032e28  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	67 c3       	rjmp	.+1742   	; 0x6fc <__vector_11>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	45 c0       	rjmp	.+138    	; 0xc4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	a1 c3       	rjmp	.+1858   	; 0x78c <__vector_18>
      4a:	00 00       	nop
      4c:	dd c3       	rjmp	.+1978   	; 0x808 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2210>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2345>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e2 ed       	ldi	r30, 0xD2	; 210
      9e:	fd e1       	ldi	r31, 0x1D	; 29
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	a2 37       	cpi	r26, 0x72	; 114
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	23 e0       	ldi	r18, 0x03	; 3
      ae:	a2 e7       	ldi	r26, 0x72	; 114
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	a2 38       	cpi	r26, 0x82	; 130
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 c6 0a 	call	0x158c	; 0x158c <main>
      c0:	0c 94 e7 0e 	jmp	0x1dce	; 0x1dce <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	0b d3       	rcall	.+1558   	; 0x6de <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	84 e1       	ldi	r24, 0x14	; 20
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	09 d3       	rcall	.+1554   	; 0x6e0 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	8c d2       	rcall	.+1304   	; 0x5e8 <sdInit>
      d0:	02 d3       	rcall	.+1540   	; 0x6d6 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	3e c3       	rjmp	.+1660   	; 0x752 <st_lld_init>

000000d6 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t) TCNT1;
      d6:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
      da:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
      de:	08 95       	ret

000000e0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      e0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      e4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

  /* Reset pending. */
  TIFR_REG = _BV(OCF1A);
      e8:	82 e0       	ldi	r24, 0x02	; 2
      ea:	86 bb       	out	0x16, r24	; 22

  /* Enable interrupt. */
  TIMSK_REG = _BV(OCIE1A);
      ec:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
      f0:	08 95       	ret

000000f2 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  TIMSK_REG = 0;
      f2:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
      f6:	08 95       	ret

000000f8 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      f8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      fc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
     100:	08 95       	ret

00000102 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
     102:	af 92       	push	r10
     104:	bf 92       	push	r11
     106:	cf 92       	push	r12
     108:	df 92       	push	r13
     10a:	ef 92       	push	r14
     10c:	ff 92       	push	r15
     10e:	0f 93       	push	r16
     110:	1f 93       	push	r17
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	ec 01       	movw	r28, r24
     118:	6b 01       	movw	r12, r22
     11a:	8a 01       	movw	r16, r20
     11c:	8c 81       	ldd	r24, Y+4	; 0x04
     11e:	9d 81       	ldd	r25, Y+5	; 0x05
     120:	84 17       	cp	r24, r20
     122:	95 07       	cpc	r25, r21
     124:	10 f4       	brcc	.+4      	; 0x12a <iq_read+0x28>
     126:	0c 81       	ldd	r16, Y+4	; 0x04
     128:	1d 81       	ldd	r17, Y+5	; 0x05
     12a:	6c 85       	ldd	r22, Y+12	; 0x0c
     12c:	7d 85       	ldd	r23, Y+13	; 0x0d
     12e:	e8 84       	ldd	r14, Y+8	; 0x08
     130:	f9 84       	ldd	r15, Y+9	; 0x09
     132:	e6 1a       	sub	r14, r22
     134:	f7 0a       	sbc	r15, r23
     136:	0e 15       	cp	r16, r14
     138:	1f 05       	cpc	r17, r15
     13a:	98 f1       	brcs	.+102    	; 0x1a2 <iq_read+0xa0>
     13c:	e0 16       	cp	r14, r16
     13e:	f1 06       	cpc	r15, r17
     140:	d0 f0       	brcs	.+52     	; 0x176 <iq_read+0x74>
     142:	a8 01       	movw	r20, r16
     144:	c6 01       	movw	r24, r12
     146:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     14a:	8e 81       	ldd	r24, Y+6	; 0x06
     14c:	9f 81       	ldd	r25, Y+7	; 0x07
     14e:	9d 87       	std	Y+13, r25	; 0x0d
     150:	8c 87       	std	Y+12, r24	; 0x0c
     152:	8c 81       	ldd	r24, Y+4	; 0x04
     154:	9d 81       	ldd	r25, Y+5	; 0x05
     156:	80 1b       	sub	r24, r16
     158:	91 0b       	sbc	r25, r17
     15a:	9d 83       	std	Y+5, r25	; 0x05
     15c:	8c 83       	std	Y+4, r24	; 0x04
     15e:	c8 01       	movw	r24, r16
     160:	df 91       	pop	r29
     162:	cf 91       	pop	r28
     164:	1f 91       	pop	r17
     166:	0f 91       	pop	r16
     168:	ff 90       	pop	r15
     16a:	ef 90       	pop	r14
     16c:	df 90       	pop	r13
     16e:	cf 90       	pop	r12
     170:	bf 90       	pop	r11
     172:	af 90       	pop	r10
     174:	08 95       	ret
     176:	a7 01       	movw	r20, r14
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     17e:	58 01       	movw	r10, r16
     180:	ae 18       	sub	r10, r14
     182:	bf 08       	sbc	r11, r15
     184:	6e 81       	ldd	r22, Y+6	; 0x06
     186:	7f 81       	ldd	r23, Y+7	; 0x07
     188:	a5 01       	movw	r20, r10
     18a:	c6 01       	movw	r24, r12
     18c:	8e 0d       	add	r24, r14
     18e:	9f 1d       	adc	r25, r15
     190:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     194:	4e 81       	ldd	r20, Y+6	; 0x06
     196:	5f 81       	ldd	r21, Y+7	; 0x07
     198:	4a 0d       	add	r20, r10
     19a:	5b 1d       	adc	r21, r11
     19c:	5d 87       	std	Y+13, r21	; 0x0d
     19e:	4c 87       	std	Y+12, r20	; 0x0c
     1a0:	d8 cf       	rjmp	.-80     	; 0x152 <iq_read+0x50>
     1a2:	a8 01       	movw	r20, r16
     1a4:	c6 01       	movw	r24, r12
     1a6:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     1aa:	8c 85       	ldd	r24, Y+12	; 0x0c
     1ac:	9d 85       	ldd	r25, Y+13	; 0x0d
     1ae:	80 0f       	add	r24, r16
     1b0:	91 1f       	adc	r25, r17
     1b2:	9d 87       	std	Y+13, r25	; 0x0d
     1b4:	8c 87       	std	Y+12, r24	; 0x0c
     1b6:	cd cf       	rjmp	.-102    	; 0x152 <iq_read+0x50>

000001b8 <oq_write>:
     1b8:	af 92       	push	r10
     1ba:	bf 92       	push	r11
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
     1ce:	6b 01       	movw	r12, r22
     1d0:	8a 01       	movw	r16, r20
     1d2:	8c 81       	ldd	r24, Y+4	; 0x04
     1d4:	9d 81       	ldd	r25, Y+5	; 0x05
     1d6:	84 17       	cp	r24, r20
     1d8:	95 07       	cpc	r25, r21
     1da:	10 f4       	brcc	.+4      	; 0x1e0 <oq_write+0x28>
     1dc:	0c 81       	ldd	r16, Y+4	; 0x04
     1de:	1d 81       	ldd	r17, Y+5	; 0x05
     1e0:	8a 85       	ldd	r24, Y+10	; 0x0a
     1e2:	9b 85       	ldd	r25, Y+11	; 0x0b
     1e4:	e8 84       	ldd	r14, Y+8	; 0x08
     1e6:	f9 84       	ldd	r15, Y+9	; 0x09
     1e8:	e8 1a       	sub	r14, r24
     1ea:	f9 0a       	sbc	r15, r25
     1ec:	0e 15       	cp	r16, r14
     1ee:	1f 05       	cpc	r17, r15
     1f0:	98 f1       	brcs	.+102    	; 0x258 <oq_write+0xa0>
     1f2:	e0 16       	cp	r14, r16
     1f4:	f1 06       	cpc	r15, r17
     1f6:	d0 f0       	brcs	.+52     	; 0x22c <oq_write+0x74>
     1f8:	a8 01       	movw	r20, r16
     1fa:	b6 01       	movw	r22, r12
     1fc:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     200:	8e 81       	ldd	r24, Y+6	; 0x06
     202:	9f 81       	ldd	r25, Y+7	; 0x07
     204:	9b 87       	std	Y+11, r25	; 0x0b
     206:	8a 87       	std	Y+10, r24	; 0x0a
     208:	8c 81       	ldd	r24, Y+4	; 0x04
     20a:	9d 81       	ldd	r25, Y+5	; 0x05
     20c:	80 1b       	sub	r24, r16
     20e:	91 0b       	sbc	r25, r17
     210:	9d 83       	std	Y+5, r25	; 0x05
     212:	8c 83       	std	Y+4, r24	; 0x04
     214:	c8 01       	movw	r24, r16
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	ff 90       	pop	r15
     220:	ef 90       	pop	r14
     222:	df 90       	pop	r13
     224:	cf 90       	pop	r12
     226:	bf 90       	pop	r11
     228:	af 90       	pop	r10
     22a:	08 95       	ret
     22c:	a7 01       	movw	r20, r14
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     234:	58 01       	movw	r10, r16
     236:	ae 18       	sub	r10, r14
     238:	bf 08       	sbc	r11, r15
     23a:	b6 01       	movw	r22, r12
     23c:	6e 0d       	add	r22, r14
     23e:	7f 1d       	adc	r23, r15
     240:	a5 01       	movw	r20, r10
     242:	8e 81       	ldd	r24, Y+6	; 0x06
     244:	9f 81       	ldd	r25, Y+7	; 0x07
     246:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     24a:	4e 81       	ldd	r20, Y+6	; 0x06
     24c:	5f 81       	ldd	r21, Y+7	; 0x07
     24e:	4a 0d       	add	r20, r10
     250:	5b 1d       	adc	r21, r11
     252:	5b 87       	std	Y+11, r21	; 0x0b
     254:	4a 87       	std	Y+10, r20	; 0x0a
     256:	d8 cf       	rjmp	.-80     	; 0x208 <oq_write+0x50>
     258:	a8 01       	movw	r20, r16
     25a:	b6 01       	movw	r22, r12
     25c:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <memcpy>
     260:	8a 85       	ldd	r24, Y+10	; 0x0a
     262:	9b 85       	ldd	r25, Y+11	; 0x0b
     264:	80 0f       	add	r24, r16
     266:	91 1f       	adc	r25, r17
     268:	9b 87       	std	Y+11, r25	; 0x0b
     26a:	8a 87       	std	Y+10, r24	; 0x0a
     26c:	cd cf       	rjmp	.-102    	; 0x208 <oq_write+0x50>

0000026e <iqObjectInit>:
     26e:	0f 93       	push	r16
     270:	1f 93       	push	r17
     272:	fc 01       	movw	r30, r24
     274:	91 83       	std	Z+1, r25	; 0x01
     276:	80 83       	st	Z, r24
     278:	93 83       	std	Z+3, r25	; 0x03
     27a:	82 83       	std	Z+2, r24	; 0x02
     27c:	15 82       	std	Z+5, r1	; 0x05
     27e:	14 82       	std	Z+4, r1	; 0x04
     280:	77 83       	std	Z+7, r23	; 0x07
     282:	66 83       	std	Z+6, r22	; 0x06
     284:	75 87       	std	Z+13, r23	; 0x0d
     286:	64 87       	std	Z+12, r22	; 0x0c
     288:	73 87       	std	Z+11, r23	; 0x0b
     28a:	62 87       	std	Z+10, r22	; 0x0a
     28c:	64 0f       	add	r22, r20
     28e:	75 1f       	adc	r23, r21
     290:	71 87       	std	Z+9, r23	; 0x09
     292:	60 87       	std	Z+8, r22	; 0x08
     294:	37 87       	std	Z+15, r19	; 0x0f
     296:	26 87       	std	Z+14, r18	; 0x0e
     298:	11 8b       	std	Z+17, r17	; 0x11
     29a:	00 8b       	std	Z+16, r16	; 0x10
     29c:	1f 91       	pop	r17
     29e:	0f 91       	pop	r16
     2a0:	08 95       	ret

000002a2 <iqPutI>:
     2a2:	fc 01       	movw	r30, r24
     2a4:	a2 85       	ldd	r26, Z+10	; 0x0a
     2a6:	b3 85       	ldd	r27, Z+11	; 0x0b
     2a8:	84 85       	ldd	r24, Z+12	; 0x0c
     2aa:	95 85       	ldd	r25, Z+13	; 0x0d
     2ac:	a8 17       	cp	r26, r24
     2ae:	b9 07       	cpc	r27, r25
     2b0:	e9 f0       	breq	.+58     	; 0x2ec <iqPutI+0x4a>
     2b2:	84 81       	ldd	r24, Z+4	; 0x04
     2b4:	95 81       	ldd	r25, Z+5	; 0x05
     2b6:	01 96       	adiw	r24, 0x01	; 1
     2b8:	95 83       	std	Z+5, r25	; 0x05
     2ba:	84 83       	std	Z+4, r24	; 0x04
     2bc:	cd 01       	movw	r24, r26
     2be:	01 96       	adiw	r24, 0x01	; 1
     2c0:	93 87       	std	Z+11, r25	; 0x0b
     2c2:	82 87       	std	Z+10, r24	; 0x0a
     2c4:	6c 93       	st	X, r22
     2c6:	22 85       	ldd	r18, Z+10	; 0x0a
     2c8:	33 85       	ldd	r19, Z+11	; 0x0b
     2ca:	80 85       	ldd	r24, Z+8	; 0x08
     2cc:	91 85       	ldd	r25, Z+9	; 0x09
     2ce:	28 17       	cp	r18, r24
     2d0:	39 07       	cpc	r19, r25
     2d2:	20 f0       	brcs	.+8      	; 0x2dc <iqPutI+0x3a>
     2d4:	86 81       	ldd	r24, Z+6	; 0x06
     2d6:	97 81       	ldd	r25, Z+7	; 0x07
     2d8:	93 87       	std	Z+11, r25	; 0x0b
     2da:	82 87       	std	Z+10, r24	; 0x0a
     2dc:	cf 01       	movw	r24, r30
     2de:	70 e0       	ldi	r23, 0x00	; 0
     2e0:	60 e0       	ldi	r22, 0x00	; 0
     2e2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <chThdDequeueNextI>
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	80 e0       	ldi	r24, 0x00	; 0
     2ea:	08 95       	ret
     2ec:	84 81       	ldd	r24, Z+4	; 0x04
     2ee:	95 81       	ldd	r25, Z+5	; 0x05
     2f0:	89 2b       	or	r24, r25
     2f2:	f9 f2       	breq	.-66     	; 0x2b2 <iqPutI+0x10>
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	9f ef       	ldi	r25, 0xFF	; 255
     2f8:	08 95       	ret

000002fa <iqGetTimeout>:
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
     302:	ec 01       	movw	r28, r24
     304:	8b 01       	movw	r16, r22
     306:	f8 94       	cli
     308:	06 c0       	rjmp	.+12     	; 0x316 <iqGetTimeout+0x1c>
     30a:	b8 01       	movw	r22, r16
     30c:	ce 01       	movw	r24, r28
     30e:	0e 94 cb 09 	call	0x1396	; 0x1396 <chThdEnqueueTimeoutS>
     312:	97 fd       	sbrc	r25, 7
     314:	27 c0       	rjmp	.+78     	; 0x364 <iqGetTimeout+0x6a>
     316:	8c 81       	ldd	r24, Y+4	; 0x04
     318:	9d 81       	ldd	r25, Y+5	; 0x05
     31a:	89 2b       	or	r24, r25
     31c:	b1 f3       	breq	.-20     	; 0x30a <iqGetTimeout+0x10>
     31e:	8c 81       	ldd	r24, Y+4	; 0x04
     320:	9d 81       	ldd	r25, Y+5	; 0x05
     322:	01 97       	sbiw	r24, 0x01	; 1
     324:	9d 83       	std	Y+5, r25	; 0x05
     326:	8c 83       	std	Y+4, r24	; 0x04
     328:	ec 85       	ldd	r30, Y+12	; 0x0c
     32a:	fd 85       	ldd	r31, Y+13	; 0x0d
     32c:	cf 01       	movw	r24, r30
     32e:	01 96       	adiw	r24, 0x01	; 1
     330:	9d 87       	std	Y+13, r25	; 0x0d
     332:	8c 87       	std	Y+12, r24	; 0x0c
     334:	10 81       	ld	r17, Z
     336:	28 85       	ldd	r18, Y+8	; 0x08
     338:	39 85       	ldd	r19, Y+9	; 0x09
     33a:	82 17       	cp	r24, r18
     33c:	93 07       	cpc	r25, r19
     33e:	20 f0       	brcs	.+8      	; 0x348 <iqGetTimeout+0x4e>
     340:	8e 81       	ldd	r24, Y+6	; 0x06
     342:	9f 81       	ldd	r25, Y+7	; 0x07
     344:	9d 87       	std	Y+13, r25	; 0x0d
     346:	8c 87       	std	Y+12, r24	; 0x0c
     348:	ee 85       	ldd	r30, Y+14	; 0x0e
     34a:	ff 85       	ldd	r31, Y+15	; 0x0f
     34c:	30 97       	sbiw	r30, 0x00	; 0
     34e:	11 f0       	breq	.+4      	; 0x354 <iqGetTimeout+0x5a>
     350:	ce 01       	movw	r24, r28
     352:	09 95       	icall
     354:	78 94       	sei
     356:	81 2f       	mov	r24, r17
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	df 91       	pop	r29
     35c:	cf 91       	pop	r28
     35e:	1f 91       	pop	r17
     360:	0f 91       	pop	r16
     362:	08 95       	ret
     364:	78 94       	sei
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	08 95       	ret

00000370 <iqReadTimeout>:
     370:	6f 92       	push	r6
     372:	7f 92       	push	r7
     374:	8f 92       	push	r8
     376:	9f 92       	push	r9
     378:	af 92       	push	r10
     37a:	bf 92       	push	r11
     37c:	cf 92       	push	r12
     37e:	df 92       	push	r13
     380:	ef 92       	push	r14
     382:	ff 92       	push	r15
     384:	0f 93       	push	r16
     386:	1f 93       	push	r17
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	6c 01       	movw	r12, r24
     38e:	7b 01       	movw	r14, r22
     390:	4a 01       	movw	r8, r20
     392:	39 01       	movw	r6, r18
     394:	fc 01       	movw	r30, r24
     396:	a6 84       	ldd	r10, Z+14	; 0x0e
     398:	b7 84       	ldd	r11, Z+15	; 0x0f
     39a:	f8 94       	cli
     39c:	41 15       	cp	r20, r1
     39e:	51 05       	cpc	r21, r1
     3a0:	b9 f0       	breq	.+46     	; 0x3d0 <iqReadTimeout+0x60>
     3a2:	8a 01       	movw	r16, r20
     3a4:	a8 01       	movw	r20, r16
     3a6:	b7 01       	movw	r22, r14
     3a8:	c6 01       	movw	r24, r12
     3aa:	ab de       	rcall	.-682    	; 0x102 <iq_read>
     3ac:	ec 01       	movw	r28, r24
     3ae:	89 2b       	or	r24, r25
     3b0:	01 f1       	breq	.+64     	; 0x3f2 <iqReadTimeout+0x82>
     3b2:	a1 14       	cp	r10, r1
     3b4:	b1 04       	cpc	r11, r1
     3b6:	19 f0       	breq	.+6      	; 0x3be <iqReadTimeout+0x4e>
     3b8:	c6 01       	movw	r24, r12
     3ba:	f5 01       	movw	r30, r10
     3bc:	09 95       	icall
     3be:	78 94       	sei
     3c0:	0c 1b       	sub	r16, r28
     3c2:	1d 0b       	sbc	r17, r29
     3c4:	ec 0e       	add	r14, r28
     3c6:	fd 1e       	adc	r15, r29
     3c8:	f8 94       	cli
     3ca:	01 15       	cp	r16, r1
     3cc:	11 05       	cpc	r17, r1
     3ce:	51 f7       	brne	.-44     	; 0x3a4 <iqReadTimeout+0x34>
     3d0:	c4 01       	movw	r24, r8
     3d2:	78 94       	sei
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	ff 90       	pop	r15
     3de:	ef 90       	pop	r14
     3e0:	df 90       	pop	r13
     3e2:	cf 90       	pop	r12
     3e4:	bf 90       	pop	r11
     3e6:	af 90       	pop	r10
     3e8:	9f 90       	pop	r9
     3ea:	8f 90       	pop	r8
     3ec:	7f 90       	pop	r7
     3ee:	6f 90       	pop	r6
     3f0:	08 95       	ret
     3f2:	b3 01       	movw	r22, r6
     3f4:	c6 01       	movw	r24, r12
     3f6:	cf d7       	rcall	.+3998   	; 0x1396 <chThdEnqueueTimeoutS>
     3f8:	89 2b       	or	r24, r25
     3fa:	a1 f2       	breq	.-88     	; 0x3a4 <iqReadTimeout+0x34>
     3fc:	c4 01       	movw	r24, r8
     3fe:	80 1b       	sub	r24, r16
     400:	91 0b       	sbc	r25, r17
     402:	e7 cf       	rjmp	.-50     	; 0x3d2 <iqReadTimeout+0x62>

00000404 <oqObjectInit>:
     404:	0f 93       	push	r16
     406:	1f 93       	push	r17
     408:	fc 01       	movw	r30, r24
     40a:	91 83       	std	Z+1, r25	; 0x01
     40c:	80 83       	st	Z, r24
     40e:	93 83       	std	Z+3, r25	; 0x03
     410:	82 83       	std	Z+2, r24	; 0x02
     412:	55 83       	std	Z+5, r21	; 0x05
     414:	44 83       	std	Z+4, r20	; 0x04
     416:	77 83       	std	Z+7, r23	; 0x07
     418:	66 83       	std	Z+6, r22	; 0x06
     41a:	75 87       	std	Z+13, r23	; 0x0d
     41c:	64 87       	std	Z+12, r22	; 0x0c
     41e:	73 87       	std	Z+11, r23	; 0x0b
     420:	62 87       	std	Z+10, r22	; 0x0a
     422:	64 0f       	add	r22, r20
     424:	75 1f       	adc	r23, r21
     426:	71 87       	std	Z+9, r23	; 0x09
     428:	60 87       	std	Z+8, r22	; 0x08
     42a:	37 87       	std	Z+15, r19	; 0x0f
     42c:	26 87       	std	Z+14, r18	; 0x0e
     42e:	11 8b       	std	Z+17, r17	; 0x11
     430:	00 8b       	std	Z+16, r16	; 0x10
     432:	1f 91       	pop	r17
     434:	0f 91       	pop	r16
     436:	08 95       	ret

00000438 <oqPutTimeout>:
     438:	ff 92       	push	r15
     43a:	0f 93       	push	r16
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	ec 01       	movw	r28, r24
     444:	f6 2e       	mov	r15, r22
     446:	8a 01       	movw	r16, r20
     448:	f8 94       	cli
     44a:	05 c0       	rjmp	.+10     	; 0x456 <oqPutTimeout+0x1e>
     44c:	b8 01       	movw	r22, r16
     44e:	ce 01       	movw	r24, r28
     450:	a2 d7       	rcall	.+3908   	; 0x1396 <chThdEnqueueTimeoutS>
     452:	97 fd       	sbrc	r25, 7
     454:	2a c0       	rjmp	.+84     	; 0x4aa <oqPutTimeout+0x72>
     456:	8c 81       	ldd	r24, Y+4	; 0x04
     458:	9d 81       	ldd	r25, Y+5	; 0x05
     45a:	89 2b       	or	r24, r25
     45c:	b9 f3       	breq	.-18     	; 0x44c <oqPutTimeout+0x14>
     45e:	8c 81       	ldd	r24, Y+4	; 0x04
     460:	9d 81       	ldd	r25, Y+5	; 0x05
     462:	01 97       	sbiw	r24, 0x01	; 1
     464:	9d 83       	std	Y+5, r25	; 0x05
     466:	8c 83       	std	Y+4, r24	; 0x04
     468:	ea 85       	ldd	r30, Y+10	; 0x0a
     46a:	fb 85       	ldd	r31, Y+11	; 0x0b
     46c:	cf 01       	movw	r24, r30
     46e:	01 96       	adiw	r24, 0x01	; 1
     470:	9b 87       	std	Y+11, r25	; 0x0b
     472:	8a 87       	std	Y+10, r24	; 0x0a
     474:	f0 82       	st	Z, r15
     476:	2a 85       	ldd	r18, Y+10	; 0x0a
     478:	3b 85       	ldd	r19, Y+11	; 0x0b
     47a:	88 85       	ldd	r24, Y+8	; 0x08
     47c:	99 85       	ldd	r25, Y+9	; 0x09
     47e:	28 17       	cp	r18, r24
     480:	39 07       	cpc	r19, r25
     482:	20 f0       	brcs	.+8      	; 0x48c <oqPutTimeout+0x54>
     484:	8e 81       	ldd	r24, Y+6	; 0x06
     486:	9f 81       	ldd	r25, Y+7	; 0x07
     488:	9b 87       	std	Y+11, r25	; 0x0b
     48a:	8a 87       	std	Y+10, r24	; 0x0a
     48c:	ee 85       	ldd	r30, Y+14	; 0x0e
     48e:	ff 85       	ldd	r31, Y+15	; 0x0f
     490:	30 97       	sbiw	r30, 0x00	; 0
     492:	11 f0       	breq	.+4      	; 0x498 <oqPutTimeout+0x60>
     494:	ce 01       	movw	r24, r28
     496:	09 95       	icall
     498:	78 94       	sei
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	80 e0       	ldi	r24, 0x00	; 0
     49e:	df 91       	pop	r29
     4a0:	cf 91       	pop	r28
     4a2:	1f 91       	pop	r17
     4a4:	0f 91       	pop	r16
     4a6:	ff 90       	pop	r15
     4a8:	08 95       	ret
     4aa:	78 94       	sei
     4ac:	df 91       	pop	r29
     4ae:	cf 91       	pop	r28
     4b0:	1f 91       	pop	r17
     4b2:	0f 91       	pop	r16
     4b4:	ff 90       	pop	r15
     4b6:	08 95       	ret

000004b8 <oqGetI>:
     4b8:	cf 93       	push	r28
     4ba:	fc 01       	movw	r30, r24
     4bc:	a4 85       	ldd	r26, Z+12	; 0x0c
     4be:	b5 85       	ldd	r27, Z+13	; 0x0d
     4c0:	82 85       	ldd	r24, Z+10	; 0x0a
     4c2:	93 85       	ldd	r25, Z+11	; 0x0b
     4c4:	8a 17       	cp	r24, r26
     4c6:	9b 07       	cpc	r25, r27
     4c8:	e1 f0       	breq	.+56     	; 0x502 <oqGetI+0x4a>
     4ca:	84 81       	ldd	r24, Z+4	; 0x04
     4cc:	95 81       	ldd	r25, Z+5	; 0x05
     4ce:	01 96       	adiw	r24, 0x01	; 1
     4d0:	95 83       	std	Z+5, r25	; 0x05
     4d2:	84 83       	std	Z+4, r24	; 0x04
     4d4:	cd 01       	movw	r24, r26
     4d6:	01 96       	adiw	r24, 0x01	; 1
     4d8:	95 87       	std	Z+13, r25	; 0x0d
     4da:	84 87       	std	Z+12, r24	; 0x0c
     4dc:	cc 91       	ld	r28, X
     4de:	20 85       	ldd	r18, Z+8	; 0x08
     4e0:	31 85       	ldd	r19, Z+9	; 0x09
     4e2:	82 17       	cp	r24, r18
     4e4:	93 07       	cpc	r25, r19
     4e6:	40 f4       	brcc	.+16     	; 0x4f8 <oqGetI+0x40>
     4e8:	cf 01       	movw	r24, r30
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	60 e0       	ldi	r22, 0x00	; 0
     4ee:	70 d7       	rcall	.+3808   	; 0x13d0 <chThdDequeueNextI>
     4f0:	8c 2f       	mov	r24, r28
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	cf 91       	pop	r28
     4f6:	08 95       	ret
     4f8:	86 81       	ldd	r24, Z+6	; 0x06
     4fa:	97 81       	ldd	r25, Z+7	; 0x07
     4fc:	95 87       	std	Z+13, r25	; 0x0d
     4fe:	84 87       	std	Z+12, r24	; 0x0c
     500:	f3 cf       	rjmp	.-26     	; 0x4e8 <oqGetI+0x30>
     502:	84 81       	ldd	r24, Z+4	; 0x04
     504:	95 81       	ldd	r25, Z+5	; 0x05
     506:	89 2b       	or	r24, r25
     508:	01 f3       	breq	.-64     	; 0x4ca <oqGetI+0x12>
     50a:	8f ef       	ldi	r24, 0xFF	; 255
     50c:	9f ef       	ldi	r25, 0xFF	; 255
     50e:	cf 91       	pop	r28
     510:	08 95       	ret

00000512 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     512:	6f 92       	push	r6
     514:	7f 92       	push	r7
     516:	8f 92       	push	r8
     518:	9f 92       	push	r9
     51a:	af 92       	push	r10
     51c:	bf 92       	push	r11
     51e:	cf 92       	push	r12
     520:	df 92       	push	r13
     522:	ef 92       	push	r14
     524:	ff 92       	push	r15
     526:	0f 93       	push	r16
     528:	1f 93       	push	r17
     52a:	cf 93       	push	r28
     52c:	df 93       	push	r29
     52e:	6c 01       	movw	r12, r24
     530:	7b 01       	movw	r14, r22
     532:	4a 01       	movw	r8, r20
     534:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     536:	fc 01       	movw	r30, r24
     538:	a6 84       	ldd	r10, Z+14	; 0x0e
     53a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     53c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     53e:	41 15       	cp	r20, r1
     540:	51 05       	cpc	r21, r1
     542:	b9 f0       	breq	.+46     	; 0x572 <oqWriteTimeout+0x60>
     544:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     546:	a8 01       	movw	r20, r16
     548:	b7 01       	movw	r22, r14
     54a:	c6 01       	movw	r24, r12
     54c:	35 de       	rcall	.-918    	; 0x1b8 <oq_write>
     54e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     550:	89 2b       	or	r24, r25
     552:	01 f1       	breq	.+64     	; 0x594 <oqWriteTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     554:	a1 14       	cp	r10, r1
     556:	b1 04       	cpc	r11, r1
     558:	19 f0       	breq	.+6      	; 0x560 <oqWriteTimeout+0x4e>
        nfy(oqp);
     55a:	c6 01       	movw	r24, r12
     55c:	f5 01       	movw	r30, r10
     55e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     560:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     562:	0c 1b       	sub	r16, r28
     564:	1d 0b       	sbc	r17, r29
      bp += done;
     566:	ec 0e       	add	r14, r28
     568:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     56a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     56c:	01 15       	cp	r16, r1
     56e:	11 05       	cpc	r17, r1
     570:	51 f7       	brne	.-44     	; 0x546 <oqWriteTimeout+0x34>
     572:	c4 01       	movw	r24, r8
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     574:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	0f 91       	pop	r16
     57e:	ff 90       	pop	r15
     580:	ef 90       	pop	r14
     582:	df 90       	pop	r13
     584:	cf 90       	pop	r12
     586:	bf 90       	pop	r11
     588:	af 90       	pop	r10
     58a:	9f 90       	pop	r9
     58c:	8f 90       	pop	r8
     58e:	7f 90       	pop	r7
     590:	6f 90       	pop	r6
     592:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     594:	b3 01       	movw	r22, r6
     596:	c6 01       	movw	r24, r12
     598:	fe d6       	rcall	.+3580   	; 0x1396 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     59a:	89 2b       	or	r24, r25
     59c:	a1 f2       	breq	.-88     	; 0x546 <oqWriteTimeout+0x34>
     59e:	c4 01       	movw	r24, r8
     5a0:	80 1b       	sub	r24, r16
     5a2:	91 0b       	sbc	r25, r17
     5a4:	e7 cf       	rjmp	.-50     	; 0x574 <oqWriteTimeout+0x62>

000005a6 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     5a6:	05 96       	adiw	r24, 0x05	; 5
     5a8:	e3 ce       	rjmp	.-570    	; 0x370 <iqReadTimeout>

000005aa <_read>:
     5aa:	2f ef       	ldi	r18, 0xFF	; 255
     5ac:	3f ef       	ldi	r19, 0xFF	; 255
     5ae:	05 96       	adiw	r24, 0x05	; 5
     5b0:	df ce       	rjmp	.-578    	; 0x370 <iqReadTimeout>

000005b2 <_writet>:
     5b2:	47 96       	adiw	r24, 0x17	; 23
     5b4:	ae cf       	rjmp	.-164    	; 0x512 <oqWriteTimeout>

000005b6 <_write>:
     5b6:	2f ef       	ldi	r18, 0xFF	; 255
     5b8:	3f ef       	ldi	r19, 0xFF	; 255
     5ba:	47 96       	adiw	r24, 0x17	; 23
     5bc:	aa cf       	rjmp	.-172    	; 0x512 <oqWriteTimeout>

000005be <_gett>:
     5be:	05 96       	adiw	r24, 0x05	; 5
     5c0:	9c ce       	rjmp	.-712    	; 0x2fa <iqGetTimeout>

000005c2 <_get>:
     5c2:	6f ef       	ldi	r22, 0xFF	; 255
     5c4:	7f ef       	ldi	r23, 0xFF	; 255
     5c6:	05 96       	adiw	r24, 0x05	; 5
     5c8:	98 ce       	rjmp	.-720    	; 0x2fa <iqGetTimeout>

000005ca <_putt>:
     5ca:	47 96       	adiw	r24, 0x17	; 23
     5cc:	35 cf       	rjmp	.-406    	; 0x438 <oqPutTimeout>

000005ce <_put>:
     5ce:	4f ef       	ldi	r20, 0xFF	; 255
     5d0:	5f ef       	ldi	r21, 0xFF	; 255
     5d2:	47 96       	adiw	r24, 0x17	; 23
     5d4:	31 cf       	rjmp	.-414    	; 0x438 <oqPutTimeout>

000005d6 <_ctl>:
     5d6:	61 30       	cpi	r22, 0x01	; 1
     5d8:	71 05       	cpc	r23, r1
     5da:	19 f0       	breq	.+6      	; 0x5e2 <_ctl+0xc>
     5dc:	8c ee       	ldi	r24, 0xEC	; 236
     5de:	9f ef       	ldi	r25, 0xFF	; 255
     5e0:	08 95       	ret
     5e2:	90 e0       	ldi	r25, 0x00	; 0
     5e4:	80 e0       	ldi	r24, 0x00	; 0
     5e6:	08 95       	ret

000005e8 <sdInit>:
     5e8:	46 c1       	rjmp	.+652    	; 0x876 <sd_lld_init>

000005ea <sdObjectInit>:
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	1f 93       	push	r17
     5f2:	cf 93       	push	r28
     5f4:	df 93       	push	r29
     5f6:	ec 01       	movw	r28, r24
     5f8:	9b 01       	movw	r18, r22
     5fa:	7a 01       	movw	r14, r20
     5fc:	fc 01       	movw	r30, r24
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	81 93       	st	Z+, r24
     604:	91 93       	st	Z+, r25
     606:	fb 83       	std	Y+3, r31	; 0x03
     608:	ea 83       	std	Y+2, r30	; 0x02
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	8c 83       	std	Y+4, r24	; 0x04
     60e:	be 01       	movw	r22, r28
     610:	67 5d       	subi	r22, 0xD7	; 215
     612:	7f 4f       	sbci	r23, 0xFF	; 255
     614:	8e 01       	movw	r16, r28
     616:	40 e1       	ldi	r20, 0x10	; 16
     618:	50 e0       	ldi	r21, 0x00	; 0
     61a:	ce 01       	movw	r24, r28
     61c:	05 96       	adiw	r24, 0x05	; 5
     61e:	27 de       	rcall	.-946    	; 0x26e <iqObjectInit>
     620:	be 01       	movw	r22, r28
     622:	67 5c       	subi	r22, 0xC7	; 199
     624:	7f 4f       	sbci	r23, 0xFF	; 255
     626:	97 01       	movw	r18, r14
     628:	40 e1       	ldi	r20, 0x10	; 16
     62a:	50 e0       	ldi	r21, 0x00	; 0
     62c:	ce 01       	movw	r24, r28
     62e:	47 96       	adiw	r24, 0x17	; 23
     630:	e9 de       	rcall	.-558    	; 0x404 <oqObjectInit>
     632:	df 91       	pop	r29
     634:	cf 91       	pop	r28
     636:	1f 91       	pop	r17
     638:	0f 91       	pop	r16
     63a:	ff 90       	pop	r15
     63c:	ef 90       	pop	r14
     63e:	08 95       	ret

00000640 <sdStart>:
     640:	cf 93       	push	r28
     642:	df 93       	push	r29
     644:	ec 01       	movw	r28, r24
     646:	f8 94       	cli
     648:	1d d1       	rcall	.+570    	; 0x884 <sd_lld_start>
     64a:	82 e0       	ldi	r24, 0x02	; 2
     64c:	8c 83       	std	Y+4, r24	; 0x04
     64e:	78 94       	sei
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	80 e0       	ldi	r24, 0x00	; 0
     654:	df 91       	pop	r29
     656:	cf 91       	pop	r28
     658:	08 95       	ret

0000065a <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     65a:	1f 93       	push	r17
     65c:	cf 93       	push	r28
     65e:	df 93       	push	r29
     660:	ec 01       	movw	r28, r24
     662:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     664:	89 85       	ldd	r24, Y+9	; 0x09
     666:	9a 85       	ldd	r25, Y+10	; 0x0a
     668:	89 2b       	or	r24, r25
     66a:	51 f0       	breq	.+20     	; 0x680 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     66c:	61 2f       	mov	r22, r17
     66e:	ce 01       	movw	r24, r28
     670:	05 96       	adiw	r24, 0x05	; 5
     672:	17 de       	rcall	.-978    	; 0x2a2 <iqPutI>
     674:	97 fd       	sbrc	r25, 7
     676:	0e c0       	rjmp	.+28     	; 0x694 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     678:	df 91       	pop	r29
     67a:	cf 91       	pop	r28
     67c:	1f 91       	pop	r17
     67e:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     680:	64 e0       	ldi	r22, 0x04	; 4
     682:	ce 01       	movw	r24, r28
     684:	02 96       	adiw	r24, 0x02	; 2
     686:	db d6       	rcall	.+3510   	; 0x143e <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     688:	61 2f       	mov	r22, r17
     68a:	ce 01       	movw	r24, r28
     68c:	05 96       	adiw	r24, 0x05	; 5
     68e:	09 de       	rcall	.-1006   	; 0x2a2 <iqPutI>
     690:	97 ff       	sbrs	r25, 7
     692:	f2 cf       	rjmp	.-28     	; 0x678 <sdIncomingDataI+0x1e>
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	ce 01       	movw	r24, r28
     698:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	ce c6       	rjmp	.+3484   	; 0x143e <chEvtBroadcastFlagsI>

000006a2 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     6a2:	0f 93       	push	r16
     6a4:	1f 93       	push	r17
     6a6:	cf 93       	push	r28
     6a8:	df 93       	push	r29
     6aa:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     6ac:	47 96       	adiw	r24, 0x17	; 23
     6ae:	04 df       	rcall	.-504    	; 0x4b8 <oqGetI>
     6b0:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     6b2:	97 fd       	sbrc	r25, 7
     6b4:	06 c0       	rjmp	.+12     	; 0x6c2 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     6b6:	ce 01       	movw	r24, r28
     6b8:	df 91       	pop	r29
     6ba:	cf 91       	pop	r28
     6bc:	1f 91       	pop	r17
     6be:	0f 91       	pop	r16
     6c0:	08 95       	ret
     6c2:	68 e0       	ldi	r22, 0x08	; 8
     6c4:	c8 01       	movw	r24, r16
     6c6:	02 96       	adiw	r24, 0x02	; 2
     6c8:	ba d6       	rcall	.+3444   	; 0x143e <chEvtBroadcastFlagsI>
     6ca:	ce 01       	movw	r24, r28
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	08 95       	ret

000006d6 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6d6:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6da:	1d ba       	out	0x1d, r1	; 29

}
     6dc:	08 95       	ret

000006de <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
     6de:	08 95       	ret

000006e0 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6e0:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6e2:	80 81       	ld	r24, Z
     6e4:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6e6:	81 81       	ldd	r24, Z+1	; 0x01
     6e8:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ea:	82 81       	ldd	r24, Z+2	; 0x02
     6ec:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6ee:	83 81       	ldd	r24, Z+3	; 0x03
     6f0:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6f2:	84 81       	ldd	r24, Z+4	; 0x04
     6f4:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6f6:	85 81       	ldd	r24, Z+5	; 0x05
     6f8:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
     6fa:	08 95       	ret

000006fc <__vector_11>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for free running mode.
 */
OSAL_IRQ_HANDLER(TIMER1_COMPA_vect) {
     6fc:	1f 92       	push	r1
     6fe:	0f 92       	push	r0
     700:	0f b6       	in	r0, 0x3f	; 63
     702:	0f 92       	push	r0
     704:	11 24       	eor	r1, r1
     706:	2f 93       	push	r18
     708:	3f 93       	push	r19
     70a:	4f 93       	push	r20
     70c:	5f 93       	push	r21
     70e:	6f 93       	push	r22
     710:	7f 93       	push	r23
     712:	8f 93       	push	r24
     714:	9f 93       	push	r25
     716:	af 93       	push	r26
     718:	bf 93       	push	r27
     71a:	ef 93       	push	r30
     71c:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     71e:	81 e0       	ldi	r24, 0x01	; 1
     720:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     724:	00 d1       	rcall	.+512    	; 0x926 <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     726:	10 92 81 03 	sts	0x0381, r1	; 0x800381 <__avr_in_isr>
     72a:	57 d4       	rcall	.+2222   	; 0xfda <chSchIsPreemptionRequired>
     72c:	81 11       	cpse	r24, r1
     72e:	65 d4       	rcall	.+2250   	; 0xffa <chSchDoPreemption>
}
     730:	ff 91       	pop	r31
     732:	ef 91       	pop	r30
     734:	bf 91       	pop	r27
     736:	af 91       	pop	r26
     738:	9f 91       	pop	r25
     73a:	8f 91       	pop	r24
     73c:	7f 91       	pop	r23
     73e:	6f 91       	pop	r22
     740:	5f 91       	pop	r21
     742:	4f 91       	pop	r20
     744:	3f 91       	pop	r19
     746:	2f 91       	pop	r18
     748:	0f 90       	pop	r0
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	0f 90       	pop	r0
     74e:	1f 90       	pop	r1
     750:	18 95       	reti

00000752 <st_lld_init>:
  /*
   * Periodic mode uses Timer 1 (16 bit).
   */

  /* CTC mode, no clock source. */
  TCCR1A     = 0;
     752:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
  TCCR1B     = _BV(WGM12);
     756:	e1 e8       	ldi	r30, 0x81	; 129
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	88 e0       	ldi	r24, 0x08	; 8
     75c:	80 83       	st	Z, r24

  /* Start disabled. */
  TCCR1C     = 0;
     75e:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x7f8082>
  OCR1A      = 0;
     762:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     766:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
  TCNT1      = 0;
     76a:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     76e:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
  TIFR_REG   = _BV(OCF1A);                              /* Reset pending.   */
     772:	82 e0       	ldi	r24, 0x02	; 2
     774:	86 bb       	out	0x16, r24	; 22
  TIMSK_REG  = 0;
     776:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
  TCCR1B     = PRESCALER;
     77a:	85 e0       	ldi	r24, 0x05	; 5
     77c:	80 83       	st	Z, r24
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
     77e:	08 95       	ret

00000780 <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     780:	e1 ec       	ldi	r30, 0xC1	; 193
     782:	f0 e0       	ldi	r31, 0x00	; 0
     784:	80 81       	ld	r24, Z
     786:	80 62       	ori	r24, 0x20	; 32
     788:	80 83       	st	Z, r24
}
     78a:	08 95       	ret

0000078c <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     78c:	1f 92       	push	r1
     78e:	0f 92       	push	r0
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	0f 92       	push	r0
     794:	11 24       	eor	r1, r1
     796:	2f 93       	push	r18
     798:	3f 93       	push	r19
     79a:	4f 93       	push	r20
     79c:	5f 93       	push	r21
     79e:	6f 93       	push	r22
     7a0:	7f 93       	push	r23
     7a2:	8f 93       	push	r24
     7a4:	9f 93       	push	r25
     7a6:	af 93       	push	r26
     7a8:	bf 93       	push	r27
     7aa:	ef 93       	push	r30
     7ac:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__avr_in_isr>

  sra = UCSR0A;
     7b4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7b8:	98 2f       	mov	r25, r24
     7ba:	9c 71       	andi	r25, 0x1C	; 28
     7bc:	41 f0       	breq	.+16     	; 0x7ce <__vector_18+0x42>
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     7be:	60 e2       	ldi	r22, 0x20	; 32
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7c0:	82 ff       	sbrs	r24, 2
     7c2:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7c4:	84 fd       	sbrc	r24, 4
     7c6:	1e c0       	rjmp	.+60     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7c8:	80 ef       	ldi	r24, 0xF0	; 240
     7ca:	92 e0       	ldi	r25, 0x02	; 2
     7cc:	38 d6       	rcall	.+3184   	; 0x143e <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7ce:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     7d2:	8e ee       	ldi	r24, 0xEE	; 238
     7d4:	92 e0       	ldi	r25, 0x02	; 2
     7d6:	41 df       	rcall	.-382    	; 0x65a <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     7d8:	10 92 81 03 	sts	0x0381, r1	; 0x800381 <__avr_in_isr>
     7dc:	fe d3       	rcall	.+2044   	; 0xfda <chSchIsPreemptionRequired>
     7de:	81 11       	cpse	r24, r1
     7e0:	0c d4       	rcall	.+2072   	; 0xffa <chSchDoPreemption>
}
     7e2:	ff 91       	pop	r31
     7e4:	ef 91       	pop	r30
     7e6:	bf 91       	pop	r27
     7e8:	af 91       	pop	r26
     7ea:	9f 91       	pop	r25
     7ec:	8f 91       	pop	r24
     7ee:	7f 91       	pop	r23
     7f0:	6f 91       	pop	r22
     7f2:	5f 91       	pop	r21
     7f4:	4f 91       	pop	r20
     7f6:	3f 91       	pop	r19
     7f8:	2f 91       	pop	r18
     7fa:	0f 90       	pop	r0
     7fc:	0f be       	out	0x3f, r0	; 63
     7fe:	0f 90       	pop	r0
     800:	1f 90       	pop	r1
     802:	18 95       	reti
  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
    sts |= SD_FRAMING_ERROR;
     804:	60 64       	ori	r22, 0x40	; 64
     806:	e0 cf       	rjmp	.-64     	; 0x7c8 <__vector_18+0x3c>

00000808 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     808:	1f 92       	push	r1
     80a:	0f 92       	push	r0
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	0f 92       	push	r0
     810:	11 24       	eor	r1, r1
     812:	2f 93       	push	r18
     814:	3f 93       	push	r19
     816:	4f 93       	push	r20
     818:	5f 93       	push	r21
     81a:	6f 93       	push	r22
     81c:	7f 93       	push	r23
     81e:	8f 93       	push	r24
     820:	9f 93       	push	r25
     822:	af 93       	push	r26
     824:	bf 93       	push	r27
     826:	ef 93       	push	r30
     828:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     830:	8e ee       	ldi	r24, 0xEE	; 238
     832:	92 e0       	ldi	r25, 0x02	; 2
     834:	36 df       	rcall	.-404    	; 0x6a2 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     836:	97 fd       	sbrc	r25, 7
     838:	18 c0       	rjmp	.+48     	; 0x86a <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     83a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     83e:	10 92 81 03 	sts	0x0381, r1	; 0x800381 <__avr_in_isr>
     842:	cb d3       	rcall	.+1942   	; 0xfda <chSchIsPreemptionRequired>
     844:	81 11       	cpse	r24, r1
     846:	d9 d3       	rcall	.+1970   	; 0xffa <chSchDoPreemption>
}
     848:	ff 91       	pop	r31
     84a:	ef 91       	pop	r30
     84c:	bf 91       	pop	r27
     84e:	af 91       	pop	r26
     850:	9f 91       	pop	r25
     852:	8f 91       	pop	r24
     854:	7f 91       	pop	r23
     856:	6f 91       	pop	r22
     858:	5f 91       	pop	r21
     85a:	4f 91       	pop	r20
     85c:	3f 91       	pop	r19
     85e:	2f 91       	pop	r18
     860:	0f 90       	pop	r0
     862:	0f be       	out	0x3f, r0	; 63
     864:	0f 90       	pop	r0
     866:	1f 90       	pop	r1
     868:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     86a:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     86e:	8f 7d       	andi	r24, 0xDF	; 223
     870:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     874:	e4 cf       	rjmp	.-56     	; 0x83e <__vector_19+0x36>

00000876 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     876:	40 ec       	ldi	r20, 0xC0	; 192
     878:	53 e0       	ldi	r21, 0x03	; 3
     87a:	70 e0       	ldi	r23, 0x00	; 0
     87c:	60 e0       	ldi	r22, 0x00	; 0
     87e:	8e ee       	ldi	r24, 0xEE	; 238
     880:	92 e0       	ldi	r25, 0x02	; 2
     882:	b3 ce       	rjmp	.-666    	; 0x5ea <sdObjectInit>

00000884 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
     884:	61 15       	cp	r22, r1
     886:	71 05       	cpc	r23, r1
     888:	21 f0       	breq	.+8      	; 0x892 <sd_lld_start+0xe>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     88a:	8e 5e       	subi	r24, 0xEE	; 238
     88c:	92 40       	sbci	r25, 0x02	; 2
     88e:	89 f0       	breq	.+34     	; 0x8b2 <sd_lld_start+0x2e>
  if (&SD2 == sdp) {
    usart1_init(config);
    return;
  }
#endif
}
     890:	08 95       	ret

  if (config == NULL)
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     892:	8e 5e       	subi	r24, 0xEE	; 238
     894:	92 40       	sbci	r25, 0x02	; 2
     896:	e1 f7       	brne	.-8      	; 0x890 <sd_lld_start+0xc>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     898:	83 e3       	ldi	r24, 0x33	; 51
     89a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     89e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8a2:	82 e0       	ldi	r24, 0x02	; 2
     8a4:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8a8:	88 e9       	ldi	r24, 0x98	; 152
     8aa:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    UCSR0B |= (1 << UCSZ02);
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8ae:	86 e0       	ldi	r24, 0x06	; 6
     8b0:	1c c0       	rjmp	.+56     	; 0x8ea <sd_lld_start+0x66>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     8b2:	fb 01       	movw	r30, r22
     8b4:	80 81       	ld	r24, Z
     8b6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     8ba:	81 81       	ldd	r24, Z+1	; 0x01
     8bc:	8f 70       	andi	r24, 0x0F	; 15
     8be:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8c2:	82 e0       	ldi	r24, 0x02	; 2
     8c4:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8c8:	88 e9       	ldi	r24, 0x98	; 152
     8ca:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  switch (config->sc_bits_per_char) {
     8ce:	82 81       	ldd	r24, Z+2	; 0x02
     8d0:	81 30       	cpi	r24, 0x01	; 1
     8d2:	91 f0       	breq	.+36     	; 0x8f8 <sd_lld_start+0x74>
     8d4:	78 f0       	brcs	.+30     	; 0x8f4 <sd_lld_start+0x70>
     8d6:	82 30       	cpi	r24, 0x02	; 2
     8d8:	59 f0       	breq	.+22     	; 0x8f0 <sd_lld_start+0x6c>
     8da:	84 30       	cpi	r24, 0x04	; 4
     8dc:	41 f7       	brne	.-48     	; 0x8ae <sd_lld_start+0x2a>
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
     8de:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8e2:	84 60       	ori	r24, 0x04	; 4
     8e4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8e8:	86 e0       	ldi	r24, 0x06	; 6
  }

#if defined(__AVR_ATmega162__)
  UCSR0C = (1 << URSEL0) | ucsr0c;
#else
  UCSR0C = ucsr0c;
     8ea:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     8ee:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
     8f0:	84 e0       	ldi	r24, 0x04	; 4
     8f2:	fb cf       	rjmp	.-10     	; 0x8ea <sd_lld_start+0x66>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
  UCSR0A = (1 << U2X0);
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    ucsr0c = 0;
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	f9 cf       	rjmp	.-14     	; 0x8ea <sd_lld_start+0x66>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
     8f8:	82 e0       	ldi	r24, 0x02	; 2
     8fa:	f7 cf       	rjmp	.-18     	; 0x8ea <sd_lld_start+0x66>

000008fc <chSysInit>:
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	c7 e3       	ldi	r28, 0x37	; 55
     902:	d3 e0       	ldi	r29, 0x03	; 3
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	88 83       	st	Y, r24
     908:	1a 82       	std	Y+2, r1	; 0x02
     90a:	19 82       	std	Y+1, r1	; 0x01
     90c:	bd d5       	rcall	.+2938   	; 0x1488 <__core_init>
     90e:	ec d5       	rcall	.+3032   	; 0x14e8 <__heap_init>
     910:	6d e1       	ldi	r22, 0x1D	; 29
     912:	71 e0       	ldi	r23, 0x01	; 1
     914:	8a e3       	ldi	r24, 0x3A	; 58
     916:	93 e0       	ldi	r25, 0x03	; 3
     918:	b0 d3       	rcall	.+1888   	; 0x107a <chInstanceObjectInit>
     91a:	82 e0       	ldi	r24, 0x02	; 2
     91c:	88 83       	st	Y, r24
     91e:	78 94       	sei
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	08 95       	ret

00000926 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     926:	81 c1       	rjmp	.+770    	; 0xc2a <chVTDoTickI>

00000928 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
     928:	0f 93       	push	r16
     92a:	1f 93       	push	r17

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
     92c:	ea e3       	ldi	r30, 0x3A	; 58
     92e:	f3 e0       	ldi	r31, 0x03	; 3
     930:	05 8d       	ldd	r16, Z+29	; 0x1d
     932:	16 8d       	ldd	r17, Z+30	; 0x1e
     934:	27 8d       	ldd	r18, Z+31	; 0x1f
     936:	30 a1       	ldd	r19, Z+32	; 0x20
     938:	dc 01       	movw	r26, r24
     93a:	cb 01       	movw	r24, r22
     93c:	80 2b       	or	r24, r16
     93e:	91 2b       	or	r25, r17
     940:	a2 2b       	or	r26, r18
     942:	b3 2b       	or	r27, r19
     944:	85 8f       	std	Z+29, r24	; 0x1d
     946:	96 8f       	std	Z+30, r25	; 0x1e
     948:	a7 8f       	std	Z+31, r26	; 0x1f
     94a:	b0 a3       	std	Z+32, r27	; 0x20
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
     94c:	1f 91       	pop	r17
     94e:	0f 91       	pop	r16
     950:	08 95       	ret

00000952 <vt_insert_first.constprop.5>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     952:	cf 92       	push	r12
     954:	df 92       	push	r13
     956:	ef 92       	push	r14
     958:	ff 92       	push	r15
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
     962:	fc 01       	movw	r30, r24
     964:	8b 01       	movw	r16, r22
     966:	70 93 48 03 	sts	0x0348, r23	; 0x800348 <ch0+0xe>
     96a:	60 93 47 03 	sts	0x0347, r22	; 0x800347 <ch0+0xd>
     96e:	44 83       	std	Z+4, r20	; 0x04
     970:	55 83       	std	Z+5, r21	; 0x05
     972:	81 e4       	ldi	r24, 0x41	; 65
     974:	93 e0       	ldi	r25, 0x03	; 3
     976:	93 83       	std	Z+3, r25	; 0x03
     978:	82 83       	std	Z+2, r24	; 0x02
     97a:	a0 91 41 03 	lds	r26, 0x0341	; 0x800341 <ch0+0x7>
     97e:	b0 91 42 03 	lds	r27, 0x0342	; 0x800342 <ch0+0x8>
     982:	b1 83       	std	Z+1, r27	; 0x01
     984:	a0 83       	st	Z, r26
     986:	13 96       	adiw	r26, 0x03	; 3
     988:	fc 93       	st	X, r31
     98a:	ee 93       	st	-X, r30
     98c:	12 97       	sbiw	r26, 0x02	; 2
     98e:	f0 93 42 03 	sts	0x0342, r31	; 0x800342 <ch0+0x8>
     992:	e0 93 41 03 	sts	0x0341, r30	; 0x800341 <ch0+0x7>
     996:	ea 01       	movw	r28, r20
     998:	42 30       	cpi	r20, 0x02	; 2
     99a:	51 05       	cpc	r21, r1
     99c:	10 f4       	brcc	.+4      	; 0x9a2 <vt_insert_first.constprop.5+0x50>
     99e:	c2 e0       	ldi	r28, 0x02	; 2
     9a0:	d0 e0       	ldi	r29, 0x00	; 0
     9a2:	c8 01       	movw	r24, r16
     9a4:	8c 0f       	add	r24, r28
     9a6:	9d 1f       	adc	r25, r29
     9a8:	9b db       	rcall	.-2250   	; 0xe0 <stStartAlarm>
     9aa:	82 e0       	ldi	r24, 0x02	; 2
     9ac:	c8 2e       	mov	r12, r24
     9ae:	d1 2c       	mov	r13, r1
     9b0:	08 c0       	rjmp	.+16     	; 0x9c2 <vt_insert_first.constprop.5+0x70>
     9b2:	e6 01       	movw	r28, r12
     9b4:	21 96       	adiw	r28, 0x01	; 1
     9b6:	c8 01       	movw	r24, r16
     9b8:	8c 0f       	add	r24, r28
     9ba:	9d 1f       	adc	r25, r29
     9bc:	9d db       	rcall	.-2246   	; 0xf8 <stSetAlarm>
     9be:	87 01       	movw	r16, r14
     9c0:	6e 01       	movw	r12, r28
     9c2:	89 db       	rcall	.-2286   	; 0xd6 <stGetCounter>
     9c4:	7c 01       	movw	r14, r24
     9c6:	80 1b       	sub	r24, r16
     9c8:	91 0b       	sbc	r25, r17
     9ca:	8c 17       	cp	r24, r28
     9cc:	9d 07       	cpc	r25, r29
     9ce:	88 f7       	brcc	.-30     	; 0x9b2 <vt_insert_first.constprop.5+0x60>
     9d0:	83 e0       	ldi	r24, 0x03	; 3
     9d2:	c8 16       	cp	r12, r24
     9d4:	d1 04       	cpc	r13, r1
     9d6:	48 f4       	brcc	.+18     	; 0x9ea <vt_insert_first.constprop.5+0x98>
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	ff 90       	pop	r15
     9e2:	ef 90       	pop	r14
     9e4:	df 90       	pop	r13
     9e6:	cf 90       	pop	r12
     9e8:	08 95       	ret
     9ea:	61 e0       	ldi	r22, 0x01	; 1
     9ec:	70 e0       	ldi	r23, 0x00	; 0
     9ee:	80 e0       	ldi	r24, 0x00	; 0
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	1f 91       	pop	r17
     9f8:	0f 91       	pop	r16
     9fa:	ff 90       	pop	r15
     9fc:	ef 90       	pop	r14
     9fe:	df 90       	pop	r13
     a00:	cf 90       	pop	r12
     a02:	92 cf       	rjmp	.-220    	; 0x928 <chRFCUCollectFaultsI>

00000a04 <vt_set_alarm>:
     a04:	ef 92       	push	r14
     a06:	ff 92       	push	r15
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	8c 01       	movw	r16, r24
     a12:	eb 01       	movw	r28, r22
     a14:	62 30       	cpi	r22, 0x02	; 2
     a16:	71 05       	cpc	r23, r1
     a18:	10 f4       	brcc	.+4      	; 0xa1e <vt_set_alarm+0x1a>
     a1a:	c2 e0       	ldi	r28, 0x02	; 2
     a1c:	d0 e0       	ldi	r29, 0x00	; 0
     a1e:	82 e0       	ldi	r24, 0x02	; 2
     a20:	e8 2e       	mov	r14, r24
     a22:	f1 2c       	mov	r15, r1
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <vt_set_alarm+0x2a>
     a26:	e7 01       	movw	r28, r14
     a28:	21 96       	adiw	r28, 0x01	; 1
     a2a:	8c 01       	movw	r16, r24
     a2c:	7e 01       	movw	r14, r28
     a2e:	c8 01       	movw	r24, r16
     a30:	8c 0f       	add	r24, r28
     a32:	9d 1f       	adc	r25, r29
     a34:	61 db       	rcall	.-2366   	; 0xf8 <stSetAlarm>
     a36:	4f db       	rcall	.-2402   	; 0xd6 <stGetCounter>
     a38:	9c 01       	movw	r18, r24
     a3a:	20 1b       	sub	r18, r16
     a3c:	31 0b       	sbc	r19, r17
     a3e:	2c 17       	cp	r18, r28
     a40:	3d 07       	cpc	r19, r29
     a42:	88 f7       	brcc	.-30     	; 0xa26 <vt_set_alarm+0x22>
     a44:	83 e0       	ldi	r24, 0x03	; 3
     a46:	e8 16       	cp	r14, r24
     a48:	f1 04       	cpc	r15, r1
     a4a:	38 f4       	brcc	.+14     	; 0xa5a <vt_set_alarm+0x56>
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	ff 90       	pop	r15
     a56:	ef 90       	pop	r14
     a58:	08 95       	ret
     a5a:	61 e0       	ldi	r22, 0x01	; 1
     a5c:	70 e0       	ldi	r23, 0x00	; 0
     a5e:	80 e0       	ldi	r24, 0x00	; 0
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	1f 91       	pop	r17
     a68:	0f 91       	pop	r16
     a6a:	ff 90       	pop	r15
     a6c:	ef 90       	pop	r14
     a6e:	5c cf       	rjmp	.-328    	; 0x928 <chRFCUCollectFaultsI>

00000a70 <vt_enqueue.constprop.4>:
     a70:	ef 92       	push	r14
     a72:	ff 92       	push	r15
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	8c 01       	movw	r16, r24
     a7e:	7b 01       	movw	r14, r22
     a80:	2a db       	rcall	.-2476   	; 0xd6 <stGetCounter>
     a82:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <ch0+0x7>
     a86:	f0 91 42 03 	lds	r31, 0x0342	; 0x800342 <ch0+0x8>
     a8a:	23 e0       	ldi	r18, 0x03	; 3
     a8c:	e1 34       	cpi	r30, 0x41	; 65
     a8e:	f2 07       	cpc	r31, r18
     a90:	09 f4       	brne	.+2      	; 0xa94 <vt_enqueue.constprop.4+0x24>
     a92:	54 c0       	rjmp	.+168    	; 0xb3c <vt_enqueue.constprop.4+0xcc>
     a94:	20 91 47 03 	lds	r18, 0x0347	; 0x800347 <ch0+0xd>
     a98:	30 91 48 03 	lds	r19, 0x0348	; 0x800348 <ch0+0xe>
     a9c:	ac 01       	movw	r20, r24
     a9e:	42 1b       	sub	r20, r18
     aa0:	53 0b       	sbc	r21, r19
     aa2:	e7 01       	movw	r28, r14
     aa4:	c4 0f       	add	r28, r20
     aa6:	d5 1f       	adc	r29, r21
     aa8:	c4 17       	cp	r28, r20
     aaa:	d5 07       	cpc	r29, r21
     aac:	c0 f1       	brcs	.+112    	; 0xb1e <vt_enqueue.constprop.4+0xae>
     aae:	24 81       	ldd	r18, Z+4	; 0x04
     ab0:	35 81       	ldd	r19, Z+5	; 0x05
     ab2:	c2 17       	cp	r28, r18
     ab4:	d3 07       	cpc	r29, r19
     ab6:	c8 f1       	brcs	.+114    	; 0xb2a <vt_enqueue.constprop.4+0xba>
     ab8:	2c 17       	cp	r18, r28
     aba:	3d 07       	cpc	r19, r29
     abc:	50 f4       	brcc	.+20     	; 0xad2 <vt_enqueue.constprop.4+0x62>
     abe:	c2 1b       	sub	r28, r18
     ac0:	d3 0b       	sbc	r29, r19
     ac2:	01 90       	ld	r0, Z+
     ac4:	f0 81       	ld	r31, Z
     ac6:	e0 2d       	mov	r30, r0
     ac8:	24 81       	ldd	r18, Z+4	; 0x04
     aca:	35 81       	ldd	r19, Z+5	; 0x05
     acc:	2c 17       	cp	r18, r28
     ace:	3d 07       	cpc	r19, r29
     ad0:	b0 f3       	brcs	.-20     	; 0xabe <vt_enqueue.constprop.4+0x4e>
     ad2:	d8 01       	movw	r26, r16
     ad4:	15 96       	adiw	r26, 0x05	; 5
     ad6:	dc 93       	st	X, r29
     ad8:	ce 93       	st	-X, r28
     ada:	14 97       	sbiw	r26, 0x04	; 4
     adc:	11 96       	adiw	r26, 0x01	; 1
     ade:	fc 93       	st	X, r31
     ae0:	ee 93       	st	-X, r30
     ae2:	82 81       	ldd	r24, Z+2	; 0x02
     ae4:	93 81       	ldd	r25, Z+3	; 0x03
     ae6:	13 96       	adiw	r26, 0x03	; 3
     ae8:	9c 93       	st	X, r25
     aea:	8e 93       	st	-X, r24
     aec:	12 97       	sbiw	r26, 0x02	; 2
     aee:	dc 01       	movw	r26, r24
     af0:	0d 93       	st	X+, r16
     af2:	1c 93       	st	X, r17
     af4:	13 83       	std	Z+3, r17	; 0x03
     af6:	02 83       	std	Z+2, r16	; 0x02
     af8:	84 81       	ldd	r24, Z+4	; 0x04
     afa:	95 81       	ldd	r25, Z+5	; 0x05
     afc:	8c 1b       	sub	r24, r28
     afe:	9d 0b       	sbc	r25, r29
     b00:	95 83       	std	Z+5, r25	; 0x05
     b02:	84 83       	std	Z+4, r24	; 0x04
     b04:	8f ef       	ldi	r24, 0xFF	; 255
     b06:	9f ef       	ldi	r25, 0xFF	; 255
     b08:	90 93 46 03 	sts	0x0346, r25	; 0x800346 <ch0+0xc>
     b0c:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <ch0+0xb>
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	1f 91       	pop	r17
     b16:	0f 91       	pop	r16
     b18:	ff 90       	pop	r15
     b1a:	ef 90       	pop	r14
     b1c:	08 95       	ret
     b1e:	e7 01       	movw	r28, r14
     b20:	24 81       	ldd	r18, Z+4	; 0x04
     b22:	35 81       	ldd	r19, Z+5	; 0x05
     b24:	c2 17       	cp	r28, r18
     b26:	d3 07       	cpc	r29, r19
     b28:	38 f6       	brcc	.-114    	; 0xab8 <vt_enqueue.constprop.4+0x48>
     b2a:	b7 01       	movw	r22, r14
     b2c:	6b df       	rcall	.-298    	; 0xa04 <vt_set_alarm>
     b2e:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <ch0+0x7>
     b32:	f0 91 42 03 	lds	r31, 0x0342	; 0x800342 <ch0+0x8>
     b36:	24 81       	ldd	r18, Z+4	; 0x04
     b38:	35 81       	ldd	r19, Z+5	; 0x05
     b3a:	be cf       	rjmp	.-132    	; 0xab8 <vt_enqueue.constprop.4+0x48>
     b3c:	a7 01       	movw	r20, r14
     b3e:	bc 01       	movw	r22, r24
     b40:	c8 01       	movw	r24, r16
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	1f 91       	pop	r17
     b48:	0f 91       	pop	r16
     b4a:	ff 90       	pop	r15
     b4c:	ef 90       	pop	r14
     b4e:	01 cf       	rjmp	.-510    	; 0x952 <vt_insert_first.constprop.5>

00000b50 <chVTDoSetI>:
     b50:	fc 01       	movw	r30, r24
     b52:	31 87       	std	Z+9, r19	; 0x09
     b54:	20 87       	std	Z+8, r18	; 0x08
     b56:	57 83       	std	Z+7, r21	; 0x07
     b58:	46 83       	std	Z+6, r20	; 0x06
     b5a:	13 86       	std	Z+11, r1	; 0x0b
     b5c:	12 86       	std	Z+10, r1	; 0x0a
     b5e:	88 cf       	rjmp	.-240    	; 0xa70 <vt_enqueue.constprop.4>

00000b60 <chVTDoResetI>:
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29
     b64:	fc 01       	movw	r30, r24
     b66:	a0 81       	ld	r26, Z
     b68:	b1 81       	ldd	r27, Z+1	; 0x01
     b6a:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <ch0+0x7>
     b6e:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <ch0+0x8>
     b72:	e8 17       	cp	r30, r24
     b74:	f9 07       	cpc	r31, r25
     b76:	09 f1       	breq	.+66     	; 0xbba <chVTDoResetI+0x5a>
     b78:	c2 81       	ldd	r28, Z+2	; 0x02
     b7a:	d3 81       	ldd	r29, Z+3	; 0x03
     b7c:	b9 83       	std	Y+1, r27	; 0x01
     b7e:	a8 83       	st	Y, r26
     b80:	a0 81       	ld	r26, Z
     b82:	b1 81       	ldd	r27, Z+1	; 0x01
     b84:	13 96       	adiw	r26, 0x03	; 3
     b86:	dc 93       	st	X, r29
     b88:	ce 93       	st	-X, r28
     b8a:	12 97       	sbiw	r26, 0x02	; 2
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	8d 91       	ld	r24, X+
     b90:	9c 91       	ld	r25, X
     b92:	15 97       	sbiw	r26, 0x05	; 5
     b94:	24 81       	ldd	r18, Z+4	; 0x04
     b96:	35 81       	ldd	r19, Z+5	; 0x05
     b98:	82 0f       	add	r24, r18
     b9a:	93 1f       	adc	r25, r19
     b9c:	15 96       	adiw	r26, 0x05	; 5
     b9e:	9c 93       	st	X, r25
     ba0:	8e 93       	st	-X, r24
     ba2:	14 97       	sbiw	r26, 0x04	; 4
     ba4:	11 82       	std	Z+1, r1	; 0x01
     ba6:	10 82       	st	Z, r1
     ba8:	8f ef       	ldi	r24, 0xFF	; 255
     baa:	9f ef       	ldi	r25, 0xFF	; 255
     bac:	90 93 46 03 	sts	0x0346, r25	; 0x800346 <ch0+0xc>
     bb0:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <ch0+0xb>
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	08 95       	ret
     bba:	b0 93 42 03 	sts	0x0342, r27	; 0x800342 <ch0+0x8>
     bbe:	a0 93 41 03 	sts	0x0341, r26	; 0x800341 <ch0+0x7>
     bc2:	81 e4       	ldi	r24, 0x41	; 65
     bc4:	93 e0       	ldi	r25, 0x03	; 3
     bc6:	13 96       	adiw	r26, 0x03	; 3
     bc8:	9c 93       	st	X, r25
     bca:	8e 93       	st	-X, r24
     bcc:	12 97       	sbiw	r26, 0x02	; 2
     bce:	11 82       	std	Z+1, r1	; 0x01
     bd0:	10 82       	st	Z, r1
     bd2:	a0 91 41 03 	lds	r26, 0x0341	; 0x800341 <ch0+0x7>
     bd6:	b0 91 42 03 	lds	r27, 0x0342	; 0x800342 <ch0+0x8>
     bda:	a8 17       	cp	r26, r24
     bdc:	b9 07       	cpc	r27, r25
     bde:	11 f1       	breq	.+68     	; 0xc24 <chVTDoResetI+0xc4>
     be0:	14 96       	adiw	r26, 0x04	; 4
     be2:	8d 91       	ld	r24, X+
     be4:	9c 91       	ld	r25, X
     be6:	15 97       	sbiw	r26, 0x05	; 5
     be8:	24 81       	ldd	r18, Z+4	; 0x04
     bea:	35 81       	ldd	r19, Z+5	; 0x05
     bec:	82 0f       	add	r24, r18
     bee:	93 1f       	adc	r25, r19
     bf0:	15 96       	adiw	r26, 0x05	; 5
     bf2:	9c 93       	st	X, r25
     bf4:	8e 93       	st	-X, r24
     bf6:	14 97       	sbiw	r26, 0x04	; 4
     bf8:	6e da       	rcall	.-2852   	; 0xd6 <stGetCounter>
     bfa:	20 91 47 03 	lds	r18, 0x0347	; 0x800347 <ch0+0xd>
     bfe:	30 91 48 03 	lds	r19, 0x0348	; 0x800348 <ch0+0xe>
     c02:	ac 01       	movw	r20, r24
     c04:	42 1b       	sub	r20, r18
     c06:	53 0b       	sbc	r21, r19
     c08:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <ch0+0x7>
     c0c:	f0 91 42 03 	lds	r31, 0x0342	; 0x800342 <ch0+0x8>
     c10:	64 81       	ldd	r22, Z+4	; 0x04
     c12:	75 81       	ldd	r23, Z+5	; 0x05
     c14:	46 17       	cp	r20, r22
     c16:	57 07       	cpc	r21, r23
     c18:	68 f6       	brcc	.-102    	; 0xbb4 <chVTDoResetI+0x54>
     c1a:	64 1b       	sub	r22, r20
     c1c:	75 0b       	sbc	r23, r21
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	f0 ce       	rjmp	.-544    	; 0xa04 <vt_set_alarm>
     c24:	df 91       	pop	r29
     c26:	cf 91       	pop	r28
     c28:	64 ca       	rjmp	.-2872   	; 0xf2 <stStopAlarm>

00000c2a <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ef 92       	push	r14
     c30:	ff 92       	push	r15
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     c3a:	ee 24       	eor	r14, r14
     c3c:	ea 94       	dec	r14
     c3e:	fe 2c       	mov	r15, r14
     c40:	0b c0       	rjmp	.+22     	; 0xc58 <chVTDoTickI+0x2e>
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
     c42:	68 85       	ldd	r22, Y+8	; 0x08
     c44:	79 85       	ldd	r23, Y+9	; 0x09
     c46:	ee 81       	ldd	r30, Y+6	; 0x06
     c48:	ff 81       	ldd	r31, Y+7	; 0x07
     c4a:	ce 01       	movw	r24, r28
     c4c:	09 95       	icall

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
     c4e:	8a 85       	ldd	r24, Y+10	; 0x0a
     c50:	9b 85       	ldd	r25, Y+11	; 0x0b
     c52:	89 2b       	or	r24, r25
     c54:	09 f0       	breq	.+2      	; 0xc58 <chVTDoTickI+0x2e>
     c56:	47 c0       	rjmp	.+142    	; 0xce6 <chVTDoTickI+0xbc>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
     c58:	c0 91 41 03 	lds	r28, 0x0341	; 0x800341 <ch0+0x7>
     c5c:	d0 91 42 03 	lds	r29, 0x0342	; 0x800342 <ch0+0x8>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     c60:	3a da       	rcall	.-2956   	; 0xd6 <stGetCounter>

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
     c62:	00 91 47 03 	lds	r16, 0x0347	; 0x800347 <ch0+0xd>
     c66:	10 91 48 03 	lds	r17, 0x0348	; 0x800348 <ch0+0xe>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     c6a:	9c 01       	movw	r18, r24
     c6c:	20 1b       	sub	r18, r16
     c6e:	31 0b       	sbc	r19, r17

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
     c70:	6c 81       	ldd	r22, Y+4	; 0x04
     c72:	7d 81       	ldd	r23, Y+5	; 0x05
     c74:	26 17       	cp	r18, r22
     c76:	37 07       	cpc	r19, r23
     c78:	e8 f0       	brcs	.+58     	; 0xcb4 <chVTDoTickI+0x8a>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
     c7a:	06 0f       	add	r16, r22
     c7c:	17 1f       	adc	r17, r23
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;
     c7e:	10 93 48 03 	sts	0x0348, r17	; 0x800348 <ch0+0xe>
     c82:	00 93 47 03 	sts	0x0347, r16	; 0x800347 <ch0+0xd>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     c86:	ea 81       	ldd	r30, Y+2	; 0x02
     c88:	fb 81       	ldd	r31, Y+3	; 0x03
     c8a:	88 81       	ld	r24, Y
     c8c:	99 81       	ldd	r25, Y+1	; 0x01
     c8e:	91 83       	std	Z+1, r25	; 0x01
     c90:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     c92:	a8 81       	ld	r26, Y
     c94:	b9 81       	ldd	r27, Y+1	; 0x01
     c96:	13 96       	adiw	r26, 0x03	; 3
     c98:	fc 93       	st	X, r31
     c9a:	ee 93       	st	-X, r30
     c9c:	12 97       	sbiw	r26, 0x02	; 2

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
     c9e:	19 82       	std	Y+1, r1	; 0x01
     ca0:	18 82       	st	Y, r1

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
     ca2:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <ch0+0x7>
     ca6:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <ch0+0x8>
     caa:	81 54       	subi	r24, 0x41	; 65
     cac:	93 40       	sbci	r25, 0x03	; 3
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
     cae:	49 f6       	brne	.-110    	; 0xc42 <chVTDoTickI+0x18>
     cb0:	20 da       	rcall	.-3008   	; 0xf2 <stStopAlarm>
     cb2:	c7 cf       	rjmp	.-114    	; 0xc42 <chVTDoTickI+0x18>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
     cb4:	40 91 41 03 	lds	r20, 0x0341	; 0x800341 <ch0+0x7>
     cb8:	50 91 42 03 	lds	r21, 0x0342	; 0x800342 <ch0+0x8>
     cbc:	41 54       	subi	r20, 0x41	; 65
     cbe:	53 40       	sbci	r21, 0x03	; 3
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <chVTDoTickI+0x9a>
     cc2:	4a c0       	rjmp	.+148    	; 0xd58 <chVTDoTickI+0x12e>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
     cc4:	90 93 48 03 	sts	0x0348, r25	; 0x800348 <ch0+0xe>
     cc8:	80 93 47 03 	sts	0x0347, r24	; 0x800347 <ch0+0xd>
  vtp->dlist.delta -= nowdelta;
     ccc:	62 1b       	sub	r22, r18
     cce:	73 0b       	sbc	r23, r19
     cd0:	7d 83       	std	Y+5, r23	; 0x05
     cd2:	6c 83       	std	Y+4, r22	; 0x04

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	ff 90       	pop	r15
     cde:	ef 90       	pop	r14
     ce0:	df 90       	pop	r13
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
     ce2:	cf 90       	pop	r12
     ce4:	8f ce       	rjmp	.-738    	; 0xa04 <vt_set_alarm>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     ce6:	f7 d9       	rcall	.-3090   	; 0xd6 <stGetCounter>
     ce8:	6c 01       	movw	r12, r24
     cea:	80 1b       	sub	r24, r16
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     cec:	91 0b       	sbc	r25, r17
     cee:	8c 01       	movw	r16, r24
     cf0:	4a 85       	ldd	r20, Y+10	; 0x0a
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
     cf2:	5b 85       	ldd	r21, Y+11	; 0x0b
     cf4:	48 17       	cp	r20, r24
     cf6:	59 07       	cpc	r21, r25
     cf8:	c0 f1       	brcs	.+112    	; 0xd6a <chVTDoTickI+0x140>
     cfa:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     cfe:	f0 91 42 03 	lds	r31, 0x0342	; 0x800342 <ch0+0x8>
     d02:	23 e0       	ldi	r18, 0x03	; 3
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     d04:	e1 34       	cpi	r30, 0x41	; 65
     d06:	f2 07       	cpc	r31, r18
     d08:	09 f4       	brne	.+2      	; 0xd0c <chVTDoTickI+0xe2>
     d0a:	3e c0       	rjmp	.+124    	; 0xd88 <chVTDoTickI+0x15e>
     d0c:	84 81       	ldd	r24, Z+4	; 0x04
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     d0e:	95 81       	ldd	r25, Z+5	; 0x05
     d10:	84 17       	cp	r24, r20
     d12:	95 07       	cpc	r25, r21
     d14:	50 f4       	brcc	.+20     	; 0xd2a <chVTDoTickI+0x100>
     d16:	48 1b       	sub	r20, r24
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     d18:	59 0b       	sbc	r21, r25
     d1a:	01 90       	ld	r0, Z+
    dlp = dlp->next;
     d1c:	f0 81       	ld	r31, Z
     d1e:	e0 2d       	mov	r30, r0
     d20:	84 81       	ldd	r24, Z+4	; 0x04
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     d22:	95 81       	ldd	r25, Z+5	; 0x05
     d24:	84 17       	cp	r24, r20
     d26:	95 07       	cpc	r25, r21
     d28:	b0 f3       	brcs	.-20     	; 0xd16 <chVTDoTickI+0xec>
     d2a:	5d 83       	std	Y+5, r21	; 0x05
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     d2c:	4c 83       	std	Y+4, r20	; 0x04
     d2e:	f9 83       	std	Y+1, r31	; 0x01
  dlp->next       = dlhp;
     d30:	e8 83       	st	Y, r30
     d32:	a2 81       	ldd	r26, Z+2	; 0x02
  dlp->prev       = dlp->next->prev;
     d34:	b3 81       	ldd	r27, Z+3	; 0x03
     d36:	bb 83       	std	Y+3, r27	; 0x03
     d38:	aa 83       	std	Y+2, r26	; 0x02
     d3a:	cd 93       	st	X+, r28
  dlp->prev->next = dlp;
     d3c:	dc 93       	st	X, r29
     d3e:	d3 83       	std	Z+3, r29	; 0x03
  dlhp->prev      = dlp;
     d40:	c2 83       	std	Z+2, r28	; 0x02
     d42:	84 81       	ldd	r24, Z+4	; 0x04

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     d44:	95 81       	ldd	r25, Z+5	; 0x05
     d46:	84 1b       	sub	r24, r20
     d48:	95 0b       	sbc	r25, r21
     d4a:	95 83       	std	Z+5, r25	; 0x05
     d4c:	84 83       	std	Z+4, r24	; 0x04
     d4e:	f0 92 46 03 	sts	0x0346, r15	; 0x800346 <ch0+0xc>

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     d52:	e0 92 45 03 	sts	0x0345, r14	; 0x800345 <ch0+0xb>
     d56:	80 cf       	rjmp	.-256    	; 0xc58 <chVTDoTickI+0x2e>
     d58:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     d5a:	cf 91       	pop	r28
     d5c:	1f 91       	pop	r17
     d5e:	0f 91       	pop	r16
     d60:	ff 90       	pop	r15
     d62:	ef 90       	pop	r14
     d64:	df 90       	pop	r13
     d66:	cf 90       	pop	r12
     d68:	08 95       	ret
     d6a:	62 e0       	ldi	r22, 0x02	; 2
      if (nowdelta > vtp->reload) {
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
     d6c:	70 e0       	ldi	r23, 0x00	; 0
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	da dd       	rcall	.-1100   	; 0x928 <chRFCUCollectFaultsI>
     d74:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     d78:	f0 91 42 03 	lds	r31, 0x0342	; 0x800342 <ch0+0x8>
     d7c:	93 e0       	ldi	r25, 0x03	; 3
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     d7e:	e1 34       	cpi	r30, 0x41	; 65
     d80:	f9 07       	cpc	r31, r25
     d82:	79 f0       	breq	.+30     	; 0xda2 <chVTDoTickI+0x178>
     d84:	a8 01       	movw	r20, r16
     d86:	c2 cf       	rjmp	.-124    	; 0xd0c <chVTDoTickI+0xe2>
     d88:	48 1b       	sub	r20, r24

        delay = (sysinterval_t)0;
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
     d8a:	59 0b       	sbc	r21, r25
     d8c:	b6 01       	movw	r22, r12
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     d8e:	ce 01       	movw	r24, r28
     d90:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     d92:	cf 91       	pop	r28
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	ff 90       	pop	r15
     d9a:	ef 90       	pop	r14
     d9c:	df 90       	pop	r13
     d9e:	cf 90       	pop	r12
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     da0:	d8 cd       	rjmp	.-1104   	; 0x952 <vt_insert_first.constprop.5>
     da2:	50 e0       	ldi	r21, 0x00	; 0
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);

        delay = (sysinterval_t)0;
     da4:	40 e0       	ldi	r20, 0x00	; 0
     da6:	f2 cf       	rjmp	.-28     	; 0xd8c <chVTDoTickI+0x162>

00000da8 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     dae:	1f 96       	adiw	r26, 0x0f	; 15
     db0:	8c 91       	ld	r24, X
     db2:	1f 97       	sbiw	r26, 0x0f	; 15
     db4:	84 30       	cpi	r24, 0x04	; 4
     db6:	f1 f1       	breq	.+124    	; 0xe34 <__sch_wakeup+0x8c>
     db8:	80 f5       	brcc	.+96     	; 0xe1a <__sch_wakeup+0x72>
     dba:	88 23       	and	r24, r24
     dbc:	59 f1       	breq	.+86     	; 0xe14 <__sch_wakeup+0x6c>
     dbe:	83 30       	cpi	r24, 0x03	; 3
     dc0:	31 f4       	brne	.+12     	; 0xdce <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     dc2:	52 96       	adiw	r26, 0x12	; 18
     dc4:	ed 91       	ld	r30, X+
     dc6:	fc 91       	ld	r31, X
     dc8:	53 97       	sbiw	r26, 0x13	; 19
     dca:	11 82       	std	Z+1, r1	; 0x01
     dcc:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     dce:	8f ef       	ldi	r24, 0xFF	; 255
     dd0:	9f ef       	ldi	r25, 0xFF	; 255
     dd2:	53 96       	adiw	r26, 0x13	; 19
     dd4:	9c 93       	st	X, r25
     dd6:	8e 93       	st	-X, r24
     dd8:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     dda:	1f 96       	adiw	r26, 0x0f	; 15
     ddc:	1c 92       	st	X, r1
     dde:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     de0:	1b 96       	adiw	r26, 0x0b	; 11
     de2:	ed 91       	ld	r30, X+
     de4:	fc 91       	ld	r31, X
     de6:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     de8:	14 96       	adiw	r26, 0x04	; 4
     dea:	9c 91       	ld	r25, X
     dec:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     dee:	01 90       	ld	r0, Z+
     df0:	f0 81       	ld	r31, Z
     df2:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     df4:	84 81       	ldd	r24, Z+4	; 0x04
     df6:	89 17       	cp	r24, r25
     df8:	d0 f7       	brcc	.-12     	; 0xdee <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     dfa:	11 96       	adiw	r26, 0x01	; 1
     dfc:	fc 93       	st	X, r31
     dfe:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     e00:	c2 81       	ldd	r28, Z+2	; 0x02
     e02:	d3 81       	ldd	r29, Z+3	; 0x03
     e04:	13 96       	adiw	r26, 0x03	; 3
     e06:	dc 93       	st	X, r29
     e08:	ce 93       	st	-X, r28
     e0a:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     e0c:	b9 83       	std	Y+1, r27	; 0x01
     e0e:	a8 83       	st	Y, r26
  pqp->prev     = p;
     e10:	b3 83       	std	Z+3, r27	; 0x03
     e12:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     e1a:	87 30       	cpi	r24, 0x07	; 7
     e1c:	59 f0       	breq	.+22     	; 0xe34 <__sch_wakeup+0x8c>
     e1e:	8c 30       	cpi	r24, 0x0C	; 12
     e20:	49 f0       	breq	.+18     	; 0xe34 <__sch_wakeup+0x8c>
     e22:	85 30       	cpi	r24, 0x05	; 5
     e24:	a1 f6       	brne	.-88     	; 0xdce <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     e26:	52 96       	adiw	r26, 0x12	; 18
     e28:	ed 91       	ld	r30, X+
     e2a:	fc 91       	ld	r31, X
     e2c:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     e2e:	84 81       	ldd	r24, Z+4	; 0x04
     e30:	8f 5f       	subi	r24, 0xFF	; 255
     e32:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     e34:	12 96       	adiw	r26, 0x02	; 2
     e36:	ed 91       	ld	r30, X+
     e38:	fc 91       	ld	r31, X
     e3a:	13 97       	sbiw	r26, 0x03	; 3
     e3c:	8d 91       	ld	r24, X+
     e3e:	9c 91       	ld	r25, X
     e40:	11 97       	sbiw	r26, 0x01	; 1
     e42:	91 83       	std	Z+1, r25	; 0x01
     e44:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     e46:	cd 91       	ld	r28, X+
     e48:	dc 91       	ld	r29, X
     e4a:	11 97       	sbiw	r26, 0x01	; 1
     e4c:	fb 83       	std	Y+3, r31	; 0x03
     e4e:	ea 83       	std	Y+2, r30	; 0x02
     e50:	be cf       	rjmp	.-132    	; 0xdce <__sch_wakeup+0x26>

00000e52 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     e58:	1f 96       	adiw	r26, 0x0f	; 15
     e5a:	1c 92       	st	X, r1
     e5c:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     e5e:	1b 96       	adiw	r26, 0x0b	; 11
     e60:	ed 91       	ld	r30, X+
     e62:	fc 91       	ld	r31, X
     e64:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     e66:	14 96       	adiw	r26, 0x04	; 4
     e68:	8c 91       	ld	r24, X
     e6a:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     e6c:	01 90       	ld	r0, Z+
     e6e:	f0 81       	ld	r31, Z
     e70:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     e72:	94 81       	ldd	r25, Z+4	; 0x04
     e74:	98 17       	cp	r25, r24
     e76:	d0 f7       	brcc	.-12     	; 0xe6c <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     e78:	11 96       	adiw	r26, 0x01	; 1
     e7a:	fc 93       	st	X, r31
     e7c:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     e7e:	c2 81       	ldd	r28, Z+2	; 0x02
     e80:	d3 81       	ldd	r29, Z+3	; 0x03
     e82:	13 96       	adiw	r26, 0x03	; 3
     e84:	dc 93       	st	X, r29
     e86:	ce 93       	st	-X, r28
     e88:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     e8a:	b9 83       	std	Y+1, r27	; 0x01
     e8c:	a8 83       	st	Y, r26
  pqp->prev     = p;
     e8e:	b3 83       	std	Z+3, r27	; 0x03
     e90:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     e92:	cd 01       	movw	r24, r26
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	08 95       	ret

00000e9a <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     e9a:	cf 93       	push	r28
     e9c:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     e9e:	ea e3       	ldi	r30, 0x3A	; 58
     ea0:	f3 e0       	ldi	r31, 0x03	; 3
     ea2:	65 81       	ldd	r22, Z+5	; 0x05
     ea4:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     ea6:	db 01       	movw	r26, r22
     ea8:	1f 96       	adiw	r26, 0x0f	; 15
     eaa:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     eac:	80 81       	ld	r24, Z
     eae:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     eb0:	ec 01       	movw	r28, r24
     eb2:	a8 81       	ld	r26, Y
     eb4:	b9 81       	ldd	r27, Y+1	; 0x01
     eb6:	b1 83       	std	Z+1, r27	; 0x01
     eb8:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     eba:	13 96       	adiw	r26, 0x03	; 3
     ebc:	fc 93       	st	X, r31
     ebe:	ee 93       	st	-X, r30
     ec0:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     ec2:	21 e0       	ldi	r18, 0x01	; 1
     ec4:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     ec6:	96 83       	std	Z+6, r25	; 0x06
     ec8:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     eca:	1b d3       	rcall	.+1590   	; 0x1502 <_port_switch>
}
     ecc:	df 91       	pop	r29
     ece:	cf 91       	pop	r28
     ed0:	08 95       	ret

00000ed2 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	1f 93       	push	r17
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	cd b7       	in	r28, 0x3d	; 61
     ede:	de b7       	in	r29, 0x3e	; 62
     ee0:	2c 97       	sbiw	r28, 0x0c	; 12
     ee2:	0f b6       	in	r0, 0x3f	; 63
     ee4:	f8 94       	cli
     ee6:	de bf       	out	0x3e, r29	; 62
     ee8:	0f be       	out	0x3f, r0	; 63
     eea:	cd bf       	out	0x3d, r28	; 61
     eec:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     eee:	00 91 3f 03 	lds	r16, 0x033F	; 0x80033f <ch0+0x5>
     ef2:	10 91 40 03 	lds	r17, 0x0340	; 0x800340 <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     ef6:	6f 3f       	cpi	r22, 0xFF	; 255
     ef8:	76 07       	cpc	r23, r22
     efa:	f1 f0       	breq	.+60     	; 0xf38 <chSchGoSleepTimeoutS+0x66>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     efc:	98 01       	movw	r18, r16
     efe:	44 ed       	ldi	r20, 0xD4	; 212
     f00:	56 e0       	ldi	r21, 0x06	; 6
     f02:	ce 01       	movw	r24, r28
     f04:	01 96       	adiw	r24, 0x01	; 1
     f06:	24 de       	rcall	.-952    	; 0xb50 <chVTDoSetI>
    chSchGoSleepS(newstate);
     f08:	8f 2d       	mov	r24, r15
     f0a:	c7 df       	rcall	.-114    	; 0xe9a <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	9a 81       	ldd	r25, Y+2	; 0x02
     f10:	89 2b       	or	r24, r25
     f12:	19 f0       	breq	.+6      	; 0xf1a <chSchGoSleepTimeoutS+0x48>
      chVTDoResetI(&vt);
     f14:	ce 01       	movw	r24, r28
     f16:	01 96       	adiw	r24, 0x01	; 1
     f18:	23 de       	rcall	.-954    	; 0xb60 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     f1a:	f8 01       	movw	r30, r16
     f1c:	82 89       	ldd	r24, Z+18	; 0x12
     f1e:	93 89       	ldd	r25, Z+19	; 0x13
     f20:	2c 96       	adiw	r28, 0x0c	; 12
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	f8 94       	cli
     f26:	de bf       	out	0x3e, r29	; 62
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	cd bf       	out	0x3d, r28	; 61
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     f36:	08 95       	ret
     f38:	8f 2d       	mov	r24, r15
     f3a:	af df       	rcall	.-162    	; 0xe9a <chSchGoSleepS>
     f3c:	ee cf       	rjmp	.-36     	; 0xf1a <chSchGoSleepTimeoutS+0x48>

00000f3e <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     f44:	c0 91 3f 03 	lds	r28, 0x033F	; 0x80033f <ch0+0x5>
     f48:	d0 91 40 03 	lds	r29, 0x0340	; 0x800340 <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     f4c:	53 96       	adiw	r26, 0x13	; 19
     f4e:	7c 93       	st	X, r23
     f50:	6e 93       	st	-X, r22
     f52:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     f54:	14 96       	adiw	r26, 0x04	; 4
     f56:	2c 91       	ld	r18, X
     f58:	14 97       	sbiw	r26, 0x04	; 4
     f5a:	9c 81       	ldd	r25, Y+4	; 0x04
     f5c:	92 17       	cp	r25, r18
     f5e:	e8 f0       	brcs	.+58     	; 0xf9a <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     f60:	1f 96       	adiw	r26, 0x0f	; 15
     f62:	1c 92       	st	X, r1
     f64:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     f66:	1b 96       	adiw	r26, 0x0b	; 11
     f68:	ed 91       	ld	r30, X+
     f6a:	fc 91       	ld	r31, X
     f6c:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     f6e:	01 90       	ld	r0, Z+
     f70:	f0 81       	ld	r31, Z
     f72:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     f74:	84 81       	ldd	r24, Z+4	; 0x04
     f76:	82 17       	cp	r24, r18
     f78:	d0 f7       	brcc	.-12     	; 0xf6e <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     f7a:	11 96       	adiw	r26, 0x01	; 1
     f7c:	fc 93       	st	X, r31
     f7e:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     f80:	c2 81       	ldd	r28, Z+2	; 0x02
     f82:	d3 81       	ldd	r29, Z+3	; 0x03
     f84:	13 96       	adiw	r26, 0x03	; 3
     f86:	dc 93       	st	X, r29
     f88:	ce 93       	st	-X, r28
     f8a:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     f8c:	b9 83       	std	Y+1, r27	; 0x01
     f8e:	a8 83       	st	Y, r26
  pqp->prev     = p;
     f90:	b3 83       	std	Z+3, r27	; 0x03
     f92:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     f9a:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     f9c:	eb 85       	ldd	r30, Y+11	; 0x0b
     f9e:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     fa0:	01 90       	ld	r0, Z+
     fa2:	f0 81       	ld	r31, Z
     fa4:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     fa6:	84 81       	ldd	r24, Z+4	; 0x04
     fa8:	98 17       	cp	r25, r24
     faa:	d0 f3       	brcs	.-12     	; 0xfa0 <chSchWakeupS+0x62>
     fac:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     fae:	f9 83       	std	Y+1, r31	; 0x01
     fb0:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     fb2:	a2 81       	ldd	r26, Z+2	; 0x02
     fb4:	b3 81       	ldd	r27, Z+3	; 0x03
     fb6:	bb 83       	std	Y+3, r27	; 0x03
     fb8:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     fba:	cd 93       	st	X+, r28
     fbc:	dc 93       	st	X, r29
  pqp->prev     = p;
     fbe:	d3 83       	std	Z+3, r29	; 0x03
     fc0:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     fc2:	21 e0       	ldi	r18, 0x01	; 1
     fc4:	fc 01       	movw	r30, r24
     fc6:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     fc8:	90 93 40 03 	sts	0x0340, r25	; 0x800340 <ch0+0x6>
     fcc:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     fd0:	be 01       	movw	r22, r28
     fd2:	97 d2       	rcall	.+1326   	; 0x1502 <_port_switch>
  }
}
     fd4:	df 91       	pop	r29
     fd6:	cf 91       	pop	r28
     fd8:	08 95       	ret

00000fda <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     fda:	a0 91 3a 03 	lds	r26, 0x033A	; 0x80033a <ch0>
     fde:	b0 91 3b 03 	lds	r27, 0x033B	; 0x80033b <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     fe2:	e0 91 3f 03 	lds	r30, 0x033F	; 0x80033f <ch0+0x5>
     fe6:	f0 91 40 03 	lds	r31, 0x0340	; 0x800340 <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	14 96       	adiw	r26, 0x04	; 4
     fee:	2c 91       	ld	r18, X
     ff0:	94 81       	ldd	r25, Z+4	; 0x04
     ff2:	92 17       	cp	r25, r18
     ff4:	08 f0       	brcs	.+2      	; 0xff8 <chSchIsPreemptionRequired+0x1e>
     ff6:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     ff8:	08 95       	ret

00000ffa <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     ffa:	cf 93       	push	r28
     ffc:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     ffe:	a0 91 3f 03 	lds	r26, 0x033F	; 0x80033f <ch0+0x5>
    1002:	b0 91 40 03 	lds	r27, 0x0340	; 0x800340 <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
    1006:	40 91 3a 03 	lds	r20, 0x033A	; 0x80033a <ch0>
    100a:	50 91 3b 03 	lds	r21, 0x033B	; 0x80033b <ch0+0x1>

  pqp->next       = p->next;
    100e:	ea 01       	movw	r28, r20
    1010:	e8 81       	ld	r30, Y
    1012:	f9 81       	ldd	r31, Y+1	; 0x01
    1014:	f0 93 3b 03 	sts	0x033B, r31	; 0x80033b <ch0+0x1>
    1018:	e0 93 3a 03 	sts	0x033A, r30	; 0x80033a <ch0>
  pqp->next->prev = pqp;
    101c:	8a e3       	ldi	r24, 0x3A	; 58
    101e:	93 e0       	ldi	r25, 0x03	; 3
    1020:	93 83       	std	Z+3, r25	; 0x03
    1022:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
    1024:	81 e0       	ldi	r24, 0x01	; 1
    1026:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
    1028:	50 93 40 03 	sts	0x0340, r21	; 0x800340 <ch0+0x6>
    102c:	40 93 3f 03 	sts	0x033F, r20	; 0x80033f <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    1030:	1f 96       	adiw	r26, 0x0f	; 15
    1032:	1c 92       	st	X, r1
    1034:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
    1036:	1b 96       	adiw	r26, 0x0b	; 11
    1038:	ed 91       	ld	r30, X+
    103a:	fc 91       	ld	r31, X
    103c:	1c 97       	sbiw	r26, 0x0c	; 12
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
    103e:	14 96       	adiw	r26, 0x04	; 4
    1040:	2c 91       	ld	r18, X
    1042:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    1044:	01 90       	ld	r0, Z+
    1046:	f0 81       	ld	r31, Z
    1048:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
    104a:	94 81       	ldd	r25, Z+4	; 0x04
    104c:	29 17       	cp	r18, r25
    104e:	d0 f3       	brcs	.-12     	; 0x1044 <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
    1050:	11 96       	adiw	r26, 0x01	; 1
    1052:	fc 93       	st	X, r31
    1054:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    1056:	82 81       	ldd	r24, Z+2	; 0x02
    1058:	93 81       	ldd	r25, Z+3	; 0x03
    105a:	13 96       	adiw	r26, 0x03	; 3
    105c:	9c 93       	st	X, r25
    105e:	8e 93       	st	-X, r24
    1060:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    1062:	ec 01       	movw	r28, r24
    1064:	b9 83       	std	Y+1, r27	; 0x01
    1066:	a8 83       	st	Y, r26
  pqp->prev     = p;
    1068:	b3 83       	std	Z+3, r27	; 0x03
    106a:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
    106c:	bd 01       	movw	r22, r26
    106e:	ca 01       	movw	r24, r20
    1070:	48 d2       	rcall	.+1168   	; 0x1502 <_port_switch>
}
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
    1078:	ff cf       	rjmp	.-2      	; 0x1078 <__idle_thread>

0000107a <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
    107a:	cf 92       	push	r12
    107c:	df 92       	push	r13
    107e:	ff 92       	push	r15
    1080:	0f 93       	push	r16
    1082:	1f 93       	push	r17
    1084:	cf 93       	push	r28
    1086:	df 93       	push	r29
    1088:	cd b7       	in	r28, 0x3d	; 61
    108a:	de b7       	in	r29, 0x3e	; 62
    108c:	2b 97       	sbiw	r28, 0x0b	; 11
    108e:	0f b6       	in	r0, 0x3f	; 63
    1090:	f8 94       	cli
    1092:	de bf       	out	0x3e, r29	; 62
    1094:	0f be       	out	0x3f, r0	; 63
    1096:	cd bf       	out	0x3d, r28	; 61
    1098:	8c 01       	movw	r16, r24
    109a:	6b 01       	movw	r12, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
    109c:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <ch_system+0x2>
    10a0:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
    10a4:	fc 01       	movw	r30, r24
    10a6:	14 8e       	std	Z+28, r1	; 0x1c
    10a8:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
    10aa:	72 a3       	std	Z+34, r23	; 0x22
    10ac:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
    10ae:	ff 24       	eor	r15, r15
    10b0:	f3 94       	inc	r15
    10b2:	f0 92 81 03 	sts	0x0381, r15	; 0x800381 <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
    10b6:	91 83       	std	Z+1, r25	; 0x01
    10b8:	80 83       	st	Z, r24
  pqp->prev = pqp;
    10ba:	93 83       	std	Z+3, r25	; 0x03
    10bc:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
    10be:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
    10c0:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
    10c2:	90 8f       	std	Z+24, r25	; 0x18
    10c4:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
    10c6:	92 8f       	std	Z+26, r25	; 0x1a
    10c8:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
    10ca:	15 8e       	std	Z+29, r1	; 0x1d
    10cc:	16 8e       	std	Z+30, r1	; 0x1e
    10ce:	17 8e       	std	Z+31, r1	; 0x1f
    10d0:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
    10d2:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
    10d4:	90 87       	std	Z+8, r25	; 0x08
    10d6:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
    10d8:	92 87       	std	Z+10, r25	; 0x0a
    10da:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
    10dc:	8f ef       	ldi	r24, 0xFF	; 255
    10de:	9f ef       	ldi	r25, 0xFF	; 255
    10e0:	94 87       	std	Z+12, r25	; 0x0c
    10e2:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
    10e4:	16 86       	std	Z+14, r1	; 0x0e
    10e6:	15 86       	std	Z+13, r1	; 0x0d
    10e8:	0e 94 6b 00 	call	0xd6	; 0xd6 <stGetCounter>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
    10ec:	9c 01       	movw	r18, r24
    10ee:	f8 01       	movw	r30, r16
    10f0:	27 87       	std	Z+15, r18	; 0x0f
    10f2:	30 8b       	std	Z+16, r19	; 0x10
    10f4:	11 8a       	std	Z+17, r1	; 0x11
    10f6:	12 8a       	std	Z+18, r1	; 0x12
    10f8:	13 8a       	std	Z+19, r1	; 0x13
    10fa:	14 8a       	std	Z+20, r1	; 0x14
    10fc:	15 8a       	std	Z+21, r1	; 0x15
    10fe:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
    1100:	ef 5b       	subi	r30, 0xBF	; 191
    1102:	ff 4f       	sbci	r31, 0xFF	; 255
    1104:	11 82       	std	Z+1, r1	; 0x01
    1106:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
    1108:	b8 01       	movw	r22, r16
    110a:	6d 5d       	subi	r22, 0xDD	; 221
    110c:	7f 4f       	sbci	r23, 0xFF	; 255
    110e:	20 e8       	ldi	r18, 0x80	; 128
    1110:	4f e2       	ldi	r20, 0x2F	; 47
    1112:	51 e0       	ldi	r21, 0x01	; 1
    1114:	c8 01       	movw	r24, r16
    1116:	2a d0       	rcall	.+84     	; 0x116c <__thd_object_init>
    1118:	f8 01       	movw	r30, r16
    111a:	96 83       	std	Z+6, r25	; 0x06
    111c:	85 83       	std	Z+5, r24	; 0x05
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
    111e:	fc 01       	movw	r30, r24
    1120:	f7 86       	std	Z+15, r15	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
    1122:	83 e2       	ldi	r24, 0x23	; 35
    1124:	91 e0       	ldi	r25, 0x01	; 1
    1126:	9a 83       	std	Y+2, r25	; 0x02
    1128:	89 83       	std	Y+1, r24	; 0x01
    112a:	f6 01       	movw	r30, r12
    112c:	82 81       	ldd	r24, Z+2	; 0x02
    112e:	93 81       	ldd	r25, Z+3	; 0x03
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03
    1134:	84 81       	ldd	r24, Z+4	; 0x04
    1136:	95 81       	ldd	r25, Z+5	; 0x05
    1138:	9e 83       	std	Y+6, r25	; 0x06
    113a:	8d 83       	std	Y+5, r24	; 0x05
    113c:	ff 82       	std	Y+7, r15	; 0x07
    113e:	8c e3       	ldi	r24, 0x3C	; 60
    1140:	98 e0       	ldi	r25, 0x08	; 8
    1142:	99 87       	std	Y+9, r25	; 0x09
    1144:	88 87       	std	Y+8, r24	; 0x08
    1146:	1b 86       	std	Y+11, r1	; 0x0b
    1148:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
    114a:	ce 01       	movw	r24, r28
    114c:	01 96       	adiw	r24, 0x01	; 1
    114e:	9e d0       	rcall	.+316    	; 0x128c <chThdCreateI>
  }
#endif
}
    1150:	2b 96       	adiw	r28, 0x0b	; 11
    1152:	0f b6       	in	r0, 0x3f	; 63
    1154:	f8 94       	cli
    1156:	de bf       	out	0x3e, r29	; 62
    1158:	0f be       	out	0x3f, r0	; 63
    115a:	cd bf       	out	0x3d, r28	; 61
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	1f 91       	pop	r17
    1162:	0f 91       	pop	r16
    1164:	ff 90       	pop	r15
    1166:	df 90       	pop	r13
    1168:	cf 90       	pop	r12
    116a:	08 95       	ret

0000116c <__thd_object_init>:
void chThdResume(thread_reference_t *trp, msg_t msg) {

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	fb 01       	movw	r30, r22
    1172:	24 83       	std	Z+4, r18	; 0x04
    1174:	32 e0       	ldi	r19, 0x02	; 2
    1176:	37 87       	std	Z+15, r19	; 0x0f
    1178:	10 8a       	std	Z+16, r1	; 0x10
    117a:	94 87       	std	Z+12, r25	; 0x0c
    117c:	83 87       	std	Z+11, r24	; 0x0b
    117e:	25 8f       	std	Z+29, r18	; 0x1d
    1180:	14 8e       	std	Z+28, r1	; 0x1c
    1182:	13 8e       	std	Z+27, r1	; 0x1b
    1184:	12 8e       	std	Z+26, r1	; 0x1a
    1186:	21 e0       	ldi	r18, 0x01	; 1
    1188:	21 8b       	std	Z+17, r18	; 0x11
    118a:	56 87       	std	Z+14, r21	; 0x0e
    118c:	45 87       	std	Z+13, r20	; 0x0d
    118e:	9b 01       	movw	r18, r22
    1190:	29 5f       	subi	r18, 0xF9	; 249
    1192:	3f 4f       	sbci	r19, 0xFF	; 255
    1194:	ac 01       	movw	r20, r24
    1196:	49 5e       	subi	r20, 0xE9	; 233
    1198:	5f 4f       	sbci	r21, 0xFF	; 255
    119a:	50 87       	std	Z+8, r21	; 0x08
    119c:	47 83       	std	Z+7, r20	; 0x07
    119e:	ec 01       	movw	r28, r24
    11a0:	a9 8d       	ldd	r26, Y+25	; 0x19
    11a2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    11a4:	b2 87       	std	Z+10, r27	; 0x0a
    11a6:	a1 87       	std	Z+9, r26	; 0x09
    11a8:	2d 93       	st	X+, r18
    11aa:	3c 93       	st	X, r19
    11ac:	3a 8f       	std	Y+26, r19	; 0x1a
    11ae:	29 8f       	std	Y+25, r18	; 0x19
    11b0:	cb 01       	movw	r24, r22
    11b2:	44 96       	adiw	r24, 0x14	; 20
    11b4:	95 8b       	std	Z+21, r25	; 0x15
    11b6:	84 8b       	std	Z+20, r24	; 0x14
    11b8:	02 96       	adiw	r24, 0x02	; 2
    11ba:	97 8b       	std	Z+23, r25	; 0x17
    11bc:	86 8b       	std	Z+22, r24	; 0x16
    11be:	91 8f       	std	Z+25, r25	; 0x19
    11c0:	80 8f       	std	Z+24, r24	; 0x18
    11c2:	cb 01       	movw	r24, r22
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	08 95       	ret

000011ca <chThdCreateSuspendedI>:
    11ca:	cf 93       	push	r28
    11cc:	df 93       	push	r29
    11ce:	dc 01       	movw	r26, r24
    11d0:	14 96       	adiw	r26, 0x04	; 4
    11d2:	2d 91       	ld	r18, X+
    11d4:	3c 91       	ld	r19, X
    11d6:	15 97       	sbiw	r26, 0x05	; 5
    11d8:	f9 01       	movw	r30, r18
    11da:	7e 97       	sbiw	r30, 0x1e	; 30
    11dc:	e9 01       	movw	r28, r18
    11de:	e3 97       	sbiw	r28, 0x33	; 51
    11e0:	d6 83       	std	Z+6, r29	; 0x06
    11e2:	c5 83       	std	Z+5, r28	; 0x05
    11e4:	17 96       	adiw	r26, 0x07	; 7
    11e6:	9c 91       	ld	r25, X
    11e8:	17 97       	sbiw	r26, 0x07	; 7
    11ea:	18 96       	adiw	r26, 0x08	; 8
    11ec:	8c 91       	ld	r24, X
    11ee:	18 97       	sbiw	r26, 0x08	; 8
    11f0:	9a 8b       	std	Y+18, r25	; 0x12
    11f2:	89 8b       	std	Y+17, r24	; 0x11
    11f4:	19 96       	adiw	r26, 0x09	; 9
    11f6:	9c 91       	ld	r25, X
    11f8:	19 97       	sbiw	r26, 0x09	; 9
    11fa:	1a 96       	adiw	r26, 0x0a	; 10
    11fc:	8c 91       	ld	r24, X
    11fe:	1a 97       	sbiw	r26, 0x0a	; 10
    1200:	98 8b       	std	Y+16, r25	; 0x10
    1202:	8f 87       	std	Y+15, r24	; 0x0f
    1204:	80 eb       	ldi	r24, 0xB0	; 176
    1206:	9a e0       	ldi	r25, 0x0A	; 10
    1208:	9b 8b       	std	Y+19, r25	; 0x13
    120a:	8c 8b       	std	Y+20, r24	; 0x14
    120c:	16 96       	adiw	r26, 0x06	; 6
    120e:	8c 91       	ld	r24, X
    1210:	16 97       	sbiw	r26, 0x06	; 6
    1212:	4d 91       	ld	r20, X+
    1214:	5c 91       	ld	r21, X
    1216:	84 83       	std	Z+4, r24	; 0x04
    1218:	92 e0       	ldi	r25, 0x02	; 2
    121a:	97 87       	std	Z+15, r25	; 0x0f
    121c:	10 8a       	std	Z+16, r1	; 0x10
    121e:	6a e3       	ldi	r22, 0x3A	; 58
    1220:	73 e0       	ldi	r23, 0x03	; 3
    1222:	74 87       	std	Z+12, r23	; 0x0c
    1224:	63 87       	std	Z+11, r22	; 0x0b
    1226:	85 8f       	std	Z+29, r24	; 0x1d
    1228:	14 8e       	std	Z+28, r1	; 0x1c
    122a:	13 8e       	std	Z+27, r1	; 0x1b
    122c:	12 8e       	std	Z+26, r1	; 0x1a
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	81 8b       	std	Z+17, r24	; 0x11
    1232:	56 87       	std	Z+14, r21	; 0x0e
    1234:	45 87       	std	Z+13, r20	; 0x0d
    1236:	d9 01       	movw	r26, r18
    1238:	57 97       	sbiw	r26, 0x17	; 23
    123a:	81 e5       	ldi	r24, 0x51	; 81
    123c:	93 e0       	ldi	r25, 0x03	; 3
    123e:	11 96       	adiw	r26, 0x01	; 1
    1240:	9c 93       	st	X, r25
    1242:	8e 93       	st	-X, r24
    1244:	eb 01       	movw	r28, r22
    1246:	89 8d       	ldd	r24, Y+25	; 0x19
    1248:	9a 8d       	ldd	r25, Y+26	; 0x1a
    124a:	13 96       	adiw	r26, 0x03	; 3
    124c:	9c 93       	st	X, r25
    124e:	8e 93       	st	-X, r24
    1250:	12 97       	sbiw	r26, 0x02	; 2
    1252:	ec 01       	movw	r28, r24
    1254:	b9 83       	std	Y+1, r27	; 0x01
    1256:	a8 83       	st	Y, r26
    1258:	eb 01       	movw	r28, r22
    125a:	ba 8f       	std	Y+26, r27	; 0x1a
    125c:	a9 8f       	std	Y+25, r26	; 0x19
    125e:	1d 96       	adiw	r26, 0x0d	; 13
    1260:	0b 2e       	mov	r0, r27
    1262:	11 96       	adiw	r26, 0x01	; 1
    1264:	0c 92       	st	X, r0
    1266:	11 97       	sbiw	r26, 0x01	; 1
    1268:	ac 93       	st	X, r26
    126a:	12 96       	adiw	r26, 0x02	; 2
    126c:	0b 2e       	mov	r0, r27
    126e:	11 96       	adiw	r26, 0x01	; 1
    1270:	0c 92       	st	X, r0
    1272:	11 97       	sbiw	r26, 0x01	; 1
    1274:	ac 93       	st	X, r26
    1276:	0a 2e       	mov	r0, r26
    1278:	1b 2e       	mov	r1, r27
    127a:	13 96       	adiw	r26, 0x03	; 3
    127c:	1c 92       	st	X, r1
    127e:	0e 92       	st	-X, r0
    1280:	11 24       	eor	r1, r1
    1282:	12 97       	sbiw	r26, 0x02	; 2
    1284:	cf 01       	movw	r24, r30
    1286:	df 91       	pop	r29
    1288:	cf 91       	pop	r28
    128a:	08 95       	ret

0000128c <chThdCreateI>:
    128c:	9e df       	rcall	.-196    	; 0x11ca <chThdCreateSuspendedI>
    128e:	e1 cd       	rjmp	.-1086   	; 0xe52 <chSchReadyI>

00001290 <chThdCreateStatic>:
    1290:	0f 93       	push	r16
    1292:	1f 93       	push	r17
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	f8 94       	cli
    129a:	6e 51       	subi	r22, 0x1E	; 30
    129c:	71 09       	sbc	r23, r1
    129e:	ec 01       	movw	r28, r24
    12a0:	c6 0f       	add	r28, r22
    12a2:	d7 1f       	adc	r29, r23
    12a4:	fe 01       	movw	r30, r28
    12a6:	75 97       	sbiw	r30, 0x15	; 21
    12a8:	fe 83       	std	Y+6, r31	; 0x06
    12aa:	ed 83       	std	Y+5, r30	; 0x05
    12ac:	22 8b       	std	Z+18, r18	; 0x12
    12ae:	31 8b       	std	Z+17, r19	; 0x11
    12b0:	00 8b       	std	Z+16, r16	; 0x10
    12b2:	17 87       	std	Z+15, r17	; 0x0f
    12b4:	80 eb       	ldi	r24, 0xB0	; 176
    12b6:	9a e0       	ldi	r25, 0x0A	; 10
    12b8:	93 8b       	std	Z+19, r25	; 0x13
    12ba:	84 8b       	std	Z+20, r24	; 0x14
    12bc:	4c 83       	std	Y+4, r20	; 0x04
    12be:	82 e0       	ldi	r24, 0x02	; 2
    12c0:	8f 87       	std	Y+15, r24	; 0x0f
    12c2:	18 8a       	std	Y+16, r1	; 0x10
    12c4:	ea e3       	ldi	r30, 0x3A	; 58
    12c6:	f3 e0       	ldi	r31, 0x03	; 3
    12c8:	fc 87       	std	Y+12, r31	; 0x0c
    12ca:	eb 87       	std	Y+11, r30	; 0x0b
    12cc:	4d 8f       	std	Y+29, r20	; 0x1d
    12ce:	1c 8e       	std	Y+28, r1	; 0x1c
    12d0:	1b 8e       	std	Y+27, r1	; 0x1b
    12d2:	1a 8e       	std	Y+26, r1	; 0x1a
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	89 8b       	std	Y+17, r24	; 0x11
    12d8:	88 e2       	ldi	r24, 0x28	; 40
    12da:	91 e0       	ldi	r25, 0x01	; 1
    12dc:	9e 87       	std	Y+14, r25	; 0x0e
    12de:	8d 87       	std	Y+13, r24	; 0x0d
    12e0:	ce 01       	movw	r24, r28
    12e2:	07 96       	adiw	r24, 0x07	; 7
    12e4:	21 e5       	ldi	r18, 0x51	; 81
    12e6:	33 e0       	ldi	r19, 0x03	; 3
    12e8:	38 87       	std	Y+8, r19	; 0x08
    12ea:	2f 83       	std	Y+7, r18	; 0x07
    12ec:	a1 8d       	ldd	r26, Z+25	; 0x19
    12ee:	b2 8d       	ldd	r27, Z+26	; 0x1a
    12f0:	ba 87       	std	Y+10, r27	; 0x0a
    12f2:	a9 87       	std	Y+9, r26	; 0x09
    12f4:	8d 93       	st	X+, r24
    12f6:	9c 93       	st	X, r25
    12f8:	92 8f       	std	Z+26, r25	; 0x1a
    12fa:	81 8f       	std	Z+25, r24	; 0x19
    12fc:	0d 96       	adiw	r24, 0x0d	; 13
    12fe:	9d 8b       	std	Y+21, r25	; 0x15
    1300:	8c 8b       	std	Y+20, r24	; 0x14
    1302:	02 96       	adiw	r24, 0x02	; 2
    1304:	9f 8b       	std	Y+23, r25	; 0x17
    1306:	8e 8b       	std	Y+22, r24	; 0x16
    1308:	99 8f       	std	Y+25, r25	; 0x19
    130a:	88 8f       	std	Y+24, r24	; 0x18
    130c:	70 e0       	ldi	r23, 0x00	; 0
    130e:	60 e0       	ldi	r22, 0x00	; 0
    1310:	ce 01       	movw	r24, r28
    1312:	15 de       	rcall	.-982    	; 0xf3e <chSchWakeupS>
    1314:	78 94       	sei
    1316:	ce 01       	movw	r24, r28
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	08 95       	ret

00001322 <chThdExitS>:
    1322:	0f 93       	push	r16
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	c0 91 3f 03 	lds	r28, 0x033F	; 0x80033f <ch0+0x5>
    132e:	d0 91 40 03 	lds	r29, 0x0340	; 0x800340 <ch0+0x6>
    1332:	9b 8b       	std	Y+19, r25	; 0x13
    1334:	8a 8b       	std	Y+18, r24	; 0x12
    1336:	8e 01       	movw	r16, r28
    1338:	0c 5e       	subi	r16, 0xEC	; 236
    133a:	1f 4f       	sbci	r17, 0xFF	; 255
    133c:	8c 89       	ldd	r24, Y+20	; 0x14
    133e:	9d 89       	ldd	r25, Y+21	; 0x15
    1340:	08 17       	cp	r16, r24
    1342:	19 07       	cpc	r17, r25
    1344:	59 f0       	breq	.+22     	; 0x135c <chThdExitS+0x3a>
    1346:	fc 01       	movw	r30, r24
    1348:	20 81       	ld	r18, Z
    134a:	31 81       	ldd	r19, Z+1	; 0x01
    134c:	3d 8b       	std	Y+21, r19	; 0x15
    134e:	2c 8b       	std	Y+20, r18	; 0x14
    1350:	80 dd       	rcall	.-1280   	; 0xe52 <chSchReadyI>
    1352:	8c 89       	ldd	r24, Y+20	; 0x14
    1354:	9d 89       	ldd	r25, Y+21	; 0x15
    1356:	80 17       	cp	r24, r16
    1358:	91 07       	cpc	r25, r17
    135a:	a9 f7       	brne	.-22     	; 0x1346 <chThdExitS+0x24>
    135c:	89 89       	ldd	r24, Y+17	; 0x11
    135e:	81 11       	cpse	r24, r1
    1360:	0c c0       	rjmp	.+24     	; 0x137a <chThdExitS+0x58>
    1362:	e9 85       	ldd	r30, Y+9	; 0x09
    1364:	fa 85       	ldd	r31, Y+10	; 0x0a
    1366:	8f 81       	ldd	r24, Y+7	; 0x07
    1368:	98 85       	ldd	r25, Y+8	; 0x08
    136a:	91 83       	std	Z+1, r25	; 0x01
    136c:	80 83       	st	Z, r24
    136e:	af 81       	ldd	r26, Y+7	; 0x07
    1370:	b8 85       	ldd	r27, Y+8	; 0x08
    1372:	13 96       	adiw	r26, 0x03	; 3
    1374:	fc 93       	st	X, r31
    1376:	ee 93       	st	-X, r30
    1378:	12 97       	sbiw	r26, 0x02	; 2
    137a:	8f e0       	ldi	r24, 0x0F	; 15
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	1f 91       	pop	r17
    1382:	0f 91       	pop	r16
    1384:	8a cd       	rjmp	.-1260   	; 0xe9a <chSchGoSleepS>

00001386 <chThdExit>:
    1386:	f8 94       	cli
    1388:	cc cf       	rjmp	.-104    	; 0x1322 <chThdExitS>

0000138a <chThdSleep>:
    138a:	f8 94       	cli
    138c:	bc 01       	movw	r22, r24
    138e:	88 e0       	ldi	r24, 0x08	; 8
    1390:	a0 dd       	rcall	.-1216   	; 0xed2 <chSchGoSleepTimeoutS>
    1392:	78 94       	sei
    1394:	08 95       	ret

00001396 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    139a:	e0 91 3f 03 	lds	r30, 0x033F	; 0x80033f <ch0+0x5>
    139e:	f0 91 40 03 	lds	r31, 0x0340	; 0x800340 <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    13a2:	61 15       	cp	r22, r1
    13a4:	71 05       	cpc	r23, r1
    13a6:	79 f0       	breq	.+30     	; 0x13c6 <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    13a8:	91 83       	std	Z+1, r25	; 0x01
    13aa:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    13ac:	ec 01       	movw	r28, r24
    13ae:	aa 81       	ldd	r26, Y+2	; 0x02
    13b0:	bb 81       	ldd	r27, Y+3	; 0x03
    13b2:	b3 83       	std	Z+3, r27	; 0x03
    13b4:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    13b6:	ed 93       	st	X+, r30
    13b8:	fc 93       	st	X, r31
  qp->prev      = p;
    13ba:	fb 83       	std	Y+3, r31	; 0x03
    13bc:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    13be:	84 e0       	ldi	r24, 0x04	; 4
}
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    13c4:	86 cd       	rjmp	.-1268   	; 0xed2 <chSchGoSleepTimeoutS>
}
    13c6:	8f ef       	ldi	r24, 0xFF	; 255
    13c8:	9f ef       	ldi	r25, 0xFF	; 255
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	08 95       	ret

000013d0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    13d6:	80 81       	ld	r24, Z
    13d8:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    13da:	e8 17       	cp	r30, r24
    13dc:	f9 07       	cpc	r31, r25
    13de:	71 f0       	breq	.+28     	; 0x13fc <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    13e0:	ec 01       	movw	r28, r24
    13e2:	a8 81       	ld	r26, Y
    13e4:	b9 81       	ldd	r27, Y+1	; 0x01
    13e6:	b1 83       	std	Z+1, r27	; 0x01
    13e8:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    13ea:	13 96       	adiw	r26, 0x03	; 3
    13ec:	fc 93       	st	X, r31
    13ee:	ee 93       	st	-X, r30
    13f0:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    13f2:	7b 8b       	std	Y+19, r23	; 0x13
    13f4:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    13fa:	2b cd       	rjmp	.-1450   	; 0xe52 <chSchReadyI>
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	08 95       	ret

00001402 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1402:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
    1404:	91 83       	std	Z+1, r25	; 0x01
    1406:	80 83       	st	Z, r24
  qp->prev = qp;
    1408:	93 83       	std	Z+3, r25	; 0x03
    140a:	82 83       	std	Z+2, r24	; 0x02

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
    140c:	15 82       	std	Z+5, r1	; 0x05
    140e:	14 82       	std	Z+4, r1	; 0x04
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
    1410:	08 95       	ret

00001412 <chEvtSignalI>:

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
  chSysUnlock();
}
    1412:	fc 01       	movw	r30, r24
    1414:	82 8d       	ldd	r24, Z+26	; 0x1a
    1416:	68 2b       	or	r22, r24
    1418:	62 8f       	std	Z+26, r22	; 0x1a
    141a:	87 85       	ldd	r24, Z+15	; 0x0f
    141c:	8a 30       	cpi	r24, 0x0A	; 10
    141e:	59 f0       	breq	.+22     	; 0x1436 <chEvtSignalI+0x24>
    1420:	8b 30       	cpi	r24, 0x0B	; 11
    1422:	09 f0       	breq	.+2      	; 0x1426 <chEvtSignalI+0x14>
    1424:	08 95       	ret
    1426:	82 89       	ldd	r24, Z+18	; 0x12
    1428:	68 23       	and	r22, r24
    142a:	86 13       	cpse	r24, r22
    142c:	fb cf       	rjmp	.-10     	; 0x1424 <chEvtSignalI+0x12>
    142e:	13 8a       	std	Z+19, r1	; 0x13
    1430:	12 8a       	std	Z+18, r1	; 0x12
    1432:	cf 01       	movw	r24, r30
    1434:	0e cd       	rjmp	.-1508   	; 0xe52 <chSchReadyI>
    1436:	82 89       	ldd	r24, Z+18	; 0x12
    1438:	68 23       	and	r22, r24
    143a:	c9 f7       	brne	.-14     	; 0x142e <chEvtSignalI+0x1c>
    143c:	08 95       	ret

0000143e <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    143e:	ef 92       	push	r14
    1440:	ff 92       	push	r15
    1442:	1f 93       	push	r17
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	7c 01       	movw	r14, r24
    144a:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    144c:	fc 01       	movw	r30, r24
    144e:	c0 81       	ld	r28, Z
    1450:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1452:	8c 17       	cp	r24, r28
    1454:	9d 07       	cpc	r25, r29
    1456:	91 f0       	breq	.+36     	; 0x147c <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    1458:	8d 81       	ldd	r24, Y+5	; 0x05
    145a:	81 2b       	or	r24, r17
    145c:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    145e:	11 23       	and	r17, r17
    1460:	19 f0       	breq	.+6      	; 0x1468 <chEvtBroadcastFlagsI+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
    1462:	8e 81       	ldd	r24, Y+6	; 0x06
    1464:	81 23       	and	r24, r17
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1466:	21 f0       	breq	.+8      	; 0x1470 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1468:	6c 81       	ldd	r22, Y+4	; 0x04
    146a:	8a 81       	ldd	r24, Y+2	; 0x02
    146c:	9b 81       	ldd	r25, Y+3	; 0x03
    146e:	d1 df       	rcall	.-94     	; 0x1412 <chEvtSignalI>
    }
    elp = elp->next;
    1470:	09 90       	ld	r0, Y+
    1472:	d8 81       	ld	r29, Y
    1474:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1476:	ec 16       	cp	r14, r28
    1478:	fd 06       	cpc	r15, r29
    147a:	71 f7       	brne	.-36     	; 0x1458 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	1f 91       	pop	r17
    1482:	ff 90       	pop	r15
    1484:	ef 90       	pop	r14
    1486:	08 95       	ret

00001488 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1488:	ed e7       	ldi	r30, 0x7D	; 125
    148a:	f3 e0       	ldi	r31, 0x03	; 3
    148c:	8d ed       	ldi	r24, 0xDD	; 221
    148e:	91 e0       	ldi	r25, 0x01	; 1
    1490:	91 83       	std	Z+1, r25	; 0x01
    1492:	80 83       	st	Z, r24
    1494:	8d e5       	ldi	r24, 0x5D	; 93
    1496:	92 e0       	ldi	r25, 0x02	; 2
    1498:	93 83       	std	Z+3, r25	; 0x03
    149a:	82 83       	std	Z+2, r24	; 0x02
    149c:	08 95       	ret

0000149e <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    149e:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    14a0:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <ch_memcore+0x2>
    14a4:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <ch_memcore+0x3>
    14a8:	9f 01       	movw	r18, r30
    14aa:	28 1b       	sub	r18, r24
    14ac:	39 0b       	sbc	r19, r25
    14ae:	c9 01       	movw	r24, r18
    14b0:	71 95       	neg	r23
    14b2:	61 95       	neg	r22
    14b4:	71 09       	sbc	r23, r1
    14b6:	86 23       	and	r24, r22
    14b8:	97 23       	and	r25, r23
  prev = p - offset;
    14ba:	9c 01       	movw	r18, r24
    14bc:	24 1b       	sub	r18, r20
    14be:	35 0b       	sbc	r19, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    14c0:	40 91 7d 03 	lds	r20, 0x037D	; 0x80037d <ch_memcore>
    14c4:	50 91 7e 03 	lds	r21, 0x037E	; 0x80037e <ch_memcore+0x1>
    14c8:	24 17       	cp	r18, r20
    14ca:	35 07       	cpc	r19, r21
    14cc:	48 f0       	brcs	.+18     	; 0x14e0 <chCoreAllocFromTop+0x42>
    14ce:	e2 17       	cp	r30, r18
    14d0:	f3 07       	cpc	r31, r19
    14d2:	30 f0       	brcs	.+12     	; 0x14e0 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    14d4:	30 93 80 03 	sts	0x0380, r19	; 0x800380 <ch_memcore+0x3>
    14d8:	20 93 7f 03 	sts	0x037F, r18	; 0x80037f <ch_memcore+0x2>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    14dc:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    14de:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    14e0:	90 e0       	ldi	r25, 0x00	; 0
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    14e6:	08 95       	ret

000014e8 <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
    14e8:	ed e5       	ldi	r30, 0x5D	; 93
    14ea:	f2 e0       	ldi	r31, 0x02	; 2
    14ec:	8f e4       	ldi	r24, 0x4F	; 79
    14ee:	9a e0       	ldi	r25, 0x0A	; 10
    14f0:	91 83       	std	Z+1, r25	; 0x01
    14f2:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
    14f4:	13 82       	std	Z+3, r1	; 0x03
    14f6:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
    14f8:	15 82       	std	Z+5, r1	; 0x05
    14fa:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    14fc:	83 e6       	ldi	r24, 0x63	; 99
    14fe:	92 e0       	ldi	r25, 0x02	; 2
    1500:	80 cf       	rjmp	.-256    	; 0x1402 <chMtxObjectInit>

00001502 <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    1502:	2f 92       	push	r2
  asm volatile ("push    r3");
    1504:	3f 92       	push	r3
  asm volatile ("push    r4");
    1506:	4f 92       	push	r4
  asm volatile ("push    r5");
    1508:	5f 92       	push	r5
  asm volatile ("push    r6");
    150a:	6f 92       	push	r6
  asm volatile ("push    r7");
    150c:	7f 92       	push	r7
  asm volatile ("push    r8");
    150e:	8f 92       	push	r8
  asm volatile ("push    r9");
    1510:	9f 92       	push	r9
  asm volatile ("push    r10");
    1512:	af 92       	push	r10
  asm volatile ("push    r11");
    1514:	bf 92       	push	r11
  asm volatile ("push    r12");
    1516:	cf 92       	push	r12
  asm volatile ("push    r13");
    1518:	df 92       	push	r13
  asm volatile ("push    r14");
    151a:	ef 92       	push	r14
  asm volatile ("push    r15");
    151c:	ff 92       	push	r15
  asm volatile ("push    r16");
    151e:	0f 93       	push	r16
  asm volatile ("push    r17");
    1520:	1f 93       	push	r17
  asm volatile ("push    r28");
    1522:	cf 93       	push	r28
  asm volatile ("push    r29");
    1524:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    1526:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    1528:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    152a:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    152c:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    152e:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    1530:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    1532:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    1534:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    1536:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1538:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    153a:	df 91       	pop	r29
  asm volatile ("pop     r28");
    153c:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    153e:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1540:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    1542:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    1544:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    1546:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1548:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    154a:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    154c:	af 90       	pop	r10
  asm volatile ("pop     r9");
    154e:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1550:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    1552:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    1554:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    1556:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1558:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    155a:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    155c:	2f 90       	pop	r2
  asm volatile ("ret");
    155e:	08 95       	ret

00001560 <_port_thread_start>:
    1560:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    1562:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    1564:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    1566:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1568:	0e cf       	rjmp	.-484    	; 0x1386 <chThdExit>
}
    156a:	08 95       	ret

0000156c <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    156c:	e0 91 3f 03 	lds	r30, 0x033F	; 0x80033f <ch0+0x5>
    1570:	f0 91 40 03 	lds	r31, 0x0340	; 0x800340 <ch0+0x6>
    1574:	8a e5       	ldi	r24, 0x5A	; 90
    1576:	91 e0       	ldi	r25, 0x01	; 1
    1578:	96 87       	std	Z+14, r25	; 0x0e
    157a:	85 87       	std	Z+13, r24	; 0x0d
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("Blinker");
  while (true) {
    palTogglePad(IOPORT2, PORTB_LED1);
    157c:	c0 e2       	ldi	r28, 0x20	; 32
    157e:	85 b1       	in	r24, 0x05	; 5
    1580:	8c 27       	eor	r24, r28
    1582:	85 b9       	out	0x05, r24	; 5
    chThdSleepMilliseconds(100);
    1584:	8b e1       	ldi	r24, 0x1B	; 27
    1586:	96 e0       	ldi	r25, 0x06	; 6
    1588:	00 df       	rcall	.-512    	; 0x138a <chThdSleep>
    158a:	f9 cf       	rjmp	.-14     	; 0x157e <Thread1+0x12>

0000158c <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    158c:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
  chSysInit();
    1590:	b5 d9       	rcall	.-3222   	; 0x8fc <chSysInit>

  /*
   * Activates the serial driver 1 using the driver default configuration.
   */
  sdStart(&SD1, NULL);
    1592:	70 e0       	ldi	r23, 0x00	; 0
    1594:	60 e0       	ldi	r22, 0x00	; 0
    1596:	8e ee       	ldi	r24, 0xEE	; 238
    1598:	92 e0       	ldi	r25, 0x02	; 2
    159a:	52 d8       	rcall	.-3932   	; 0x640 <sdStart>

  /*
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    159c:	10 e0       	ldi	r17, 0x00	; 0
    159e:	00 e0       	ldi	r16, 0x00	; 0
    15a0:	26 eb       	ldi	r18, 0xB6	; 182
    15a2:	3a e0       	ldi	r19, 0x0A	; 10
    15a4:	40 e8       	ldi	r20, 0x80	; 128
    15a6:	63 e8       	ldi	r22, 0x83	; 131
    15a8:	70 e0       	ldi	r23, 0x00	; 0
    15aa:	8b e6       	ldi	r24, 0x6B	; 107
    15ac:	92 e0       	ldi	r25, 0x02	; 2
    15ae:	70 de       	rcall	.-800    	; 0x1290 <chThdCreateStatic>

  chnWrite(&SD1, (const uint8_t *)"Hello World!\r\n", 14);
    15b0:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <SD1>
    15b4:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <SD1+0x1>
    15b8:	02 80       	ldd	r0, Z+2	; 0x02
    15ba:	f3 81       	ldd	r31, Z+3	; 0x03
    15bc:	e0 2d       	mov	r30, r0
    15be:	4e e0       	ldi	r20, 0x0E	; 14
    15c0:	50 e0       	ldi	r21, 0x00	; 0
    15c2:	62 e6       	ldi	r22, 0x62	; 98
    15c4:	71 e0       	ldi	r23, 0x01	; 1
    15c6:	8e ee       	ldi	r24, 0xEE	; 238
    15c8:	92 e0       	ldi	r25, 0x02	; 2
    15ca:	09 95       	icall

  while (true) {
    chThdSleepMilliseconds(1000);
    15cc:	88 e0       	ldi	r24, 0x08	; 8
    15ce:	9d e3       	ldi	r25, 0x3D	; 61
    15d0:	dc de       	rcall	.-584    	; 0x138a <chThdSleep>
    15d2:	fc cf       	rjmp	.-8      	; 0x15cc <main+0x40>

000015d4 <vfprintf>:
    15d4:	ab e0       	ldi	r26, 0x0B	; 11
    15d6:	b0 e0       	ldi	r27, 0x00	; 0
    15d8:	ef ee       	ldi	r30, 0xEF	; 239
    15da:	fa e0       	ldi	r31, 0x0A	; 10
    15dc:	c4 c2       	rjmp	.+1416   	; 0x1b66 <__prologue_saves__+0x8>
    15de:	6c 01       	movw	r12, r24
    15e0:	7b 01       	movw	r14, r22
    15e2:	3a 01       	movw	r6, r20
    15e4:	fc 01       	movw	r30, r24
    15e6:	17 82       	std	Z+7, r1	; 0x07
    15e8:	16 82       	std	Z+6, r1	; 0x06
    15ea:	83 81       	ldd	r24, Z+3	; 0x03
    15ec:	81 ff       	sbrs	r24, 1
    15ee:	ff c0       	rjmp	.+510    	; 0x17ee <vfprintf+0x21a>
    15f0:	ce 01       	movw	r24, r28
    15f2:	01 96       	adiw	r24, 0x01	; 1
    15f4:	4c 01       	movw	r8, r24
    15f6:	f6 01       	movw	r30, r12
    15f8:	b3 80       	ldd	r11, Z+3	; 0x03
    15fa:	f7 01       	movw	r30, r14
    15fc:	b3 fc       	sbrc	r11, 3
    15fe:	05 91       	lpm	r16, Z+
    1600:	b3 fe       	sbrs	r11, 3
    1602:	01 91       	ld	r16, Z+
    1604:	7f 01       	movw	r14, r30
    1606:	00 23       	and	r16, r16
    1608:	41 f1       	breq	.+80     	; 0x165a <vfprintf+0x86>
    160a:	05 32       	cpi	r16, 0x25	; 37
    160c:	39 f4       	brne	.+14     	; 0x161c <vfprintf+0x48>
    160e:	b3 fc       	sbrc	r11, 3
    1610:	05 91       	lpm	r16, Z+
    1612:	b3 fe       	sbrs	r11, 3
    1614:	01 91       	ld	r16, Z+
    1616:	7f 01       	movw	r14, r30
    1618:	05 32       	cpi	r16, 0x25	; 37
    161a:	39 f5       	brne	.+78     	; 0x166a <vfprintf+0x96>
    161c:	b6 01       	movw	r22, r12
    161e:	80 2f       	mov	r24, r16
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	2c d3       	rcall	.+1624   	; 0x1c7c <fputc>
    1624:	53 01       	movw	r10, r6
    1626:	35 01       	movw	r6, r10
    1628:	e6 cf       	rjmp	.-52     	; 0x15f6 <vfprintf+0x22>
    162a:	10 68       	ori	r17, 0x80	; 128
    162c:	f7 01       	movw	r30, r14
    162e:	b3 fc       	sbrc	r11, 3
    1630:	05 91       	lpm	r16, Z+
    1632:	b3 fe       	sbrs	r11, 3
    1634:	01 91       	ld	r16, Z+
    1636:	7f 01       	movw	r14, r30
    1638:	17 fd       	sbrc	r17, 7
    163a:	0d c0       	rjmp	.+26     	; 0x1656 <vfprintf+0x82>
    163c:	00 23       	and	r16, r16
    163e:	69 f0       	breq	.+26     	; 0x165a <vfprintf+0x86>
    1640:	60 2f       	mov	r22, r16
    1642:	70 e0       	ldi	r23, 0x00	; 0
    1644:	8f e6       	ldi	r24, 0x6F	; 111
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	c9 d2       	rcall	.+1426   	; 0x1bdc <strchr_P>
    164a:	89 2b       	or	r24, r25
    164c:	79 f7       	brne	.-34     	; 0x162c <vfprintf+0x58>
    164e:	03 32       	cpi	r16, 0x23	; 35
    1650:	51 f0       	breq	.+20     	; 0x1666 <vfprintf+0x92>
    1652:	0c 36       	cpi	r16, 0x6C	; 108
    1654:	51 f3       	breq	.-44     	; 0x162a <vfprintf+0x56>
    1656:	01 11       	cpse	r16, r1
    1658:	0a c0       	rjmp	.+20     	; 0x166e <vfprintf+0x9a>
    165a:	f6 01       	movw	r30, r12
    165c:	86 81       	ldd	r24, Z+6	; 0x06
    165e:	97 81       	ldd	r25, Z+7	; 0x07
    1660:	2b 96       	adiw	r28, 0x0b	; 11
    1662:	ee e0       	ldi	r30, 0x0E	; 14
    1664:	9c c2       	rjmp	.+1336   	; 0x1b9e <__epilogue_restores__+0x8>
    1666:	10 e1       	ldi	r17, 0x10	; 16
    1668:	e1 cf       	rjmp	.-62     	; 0x162c <vfprintf+0x58>
    166a:	10 e0       	ldi	r17, 0x00	; 0
    166c:	e5 cf       	rjmp	.-54     	; 0x1638 <vfprintf+0x64>
    166e:	60 2f       	mov	r22, r16
    1670:	70 e0       	ldi	r23, 0x00	; 0
    1672:	88 e6       	ldi	r24, 0x68	; 104
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	b2 d2       	rcall	.+1380   	; 0x1bdc <strchr_P>
    1678:	89 2b       	or	r24, r25
    167a:	49 f0       	breq	.+18     	; 0x168e <vfprintf+0xba>
    167c:	53 01       	movw	r10, r6
    167e:	f4 e0       	ldi	r31, 0x04	; 4
    1680:	af 0e       	add	r10, r31
    1682:	b1 1c       	adc	r11, r1
    1684:	b6 01       	movw	r22, r12
    1686:	8f e3       	ldi	r24, 0x3F	; 63
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	f8 d2       	rcall	.+1520   	; 0x1c7c <fputc>
    168c:	cc cf       	rjmp	.-104    	; 0x1626 <vfprintf+0x52>
    168e:	03 36       	cpi	r16, 0x63	; 99
    1690:	09 f4       	brne	.+2      	; 0x1694 <vfprintf+0xc0>
    1692:	52 c0       	rjmp	.+164    	; 0x1738 <vfprintf+0x164>
    1694:	03 37       	cpi	r16, 0x73	; 115
    1696:	09 f4       	brne	.+2      	; 0x169a <vfprintf+0xc6>
    1698:	59 c0       	rjmp	.+178    	; 0x174c <vfprintf+0x178>
    169a:	03 35       	cpi	r16, 0x53	; 83
    169c:	09 f4       	brne	.+2      	; 0x16a0 <vfprintf+0xcc>
    169e:	55 c0       	rjmp	.+170    	; 0x174a <vfprintf+0x176>
    16a0:	04 36       	cpi	r16, 0x64	; 100
    16a2:	19 f0       	breq	.+6      	; 0x16aa <vfprintf+0xd6>
    16a4:	09 36       	cpi	r16, 0x69	; 105
    16a6:	09 f0       	breq	.+2      	; 0x16aa <vfprintf+0xd6>
    16a8:	70 c0       	rjmp	.+224    	; 0x178a <vfprintf+0x1b6>
    16aa:	53 01       	movw	r10, r6
    16ac:	17 ff       	sbrs	r17, 7
    16ae:	62 c0       	rjmp	.+196    	; 0x1774 <vfprintf+0x1a0>
    16b0:	f4 e0       	ldi	r31, 0x04	; 4
    16b2:	af 0e       	add	r10, r31
    16b4:	b1 1c       	adc	r11, r1
    16b6:	f3 01       	movw	r30, r6
    16b8:	60 81       	ld	r22, Z
    16ba:	71 81       	ldd	r23, Z+1	; 0x01
    16bc:	82 81       	ldd	r24, Z+2	; 0x02
    16be:	93 81       	ldd	r25, Z+3	; 0x03
    16c0:	1f 7e       	andi	r17, 0xEF	; 239
    16c2:	97 ff       	sbrs	r25, 7
    16c4:	08 c0       	rjmp	.+16     	; 0x16d6 <vfprintf+0x102>
    16c6:	90 95       	com	r25
    16c8:	80 95       	com	r24
    16ca:	70 95       	com	r23
    16cc:	61 95       	neg	r22
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	8f 4f       	sbci	r24, 0xFF	; 255
    16d2:	9f 4f       	sbci	r25, 0xFF	; 255
    16d4:	10 64       	ori	r17, 0x40	; 64
    16d6:	2a e0       	ldi	r18, 0x0A	; 10
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	a4 01       	movw	r20, r8
    16dc:	17 d3       	rcall	.+1582   	; 0x1d0c <__ultoa_invert>
    16de:	08 2f       	mov	r16, r24
    16e0:	08 19       	sub	r16, r8
    16e2:	16 ff       	sbrs	r17, 6
    16e4:	04 c0       	rjmp	.+8      	; 0x16ee <vfprintf+0x11a>
    16e6:	b6 01       	movw	r22, r12
    16e8:	8d e2       	ldi	r24, 0x2D	; 45
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	c7 d2       	rcall	.+1422   	; 0x1c7c <fputc>
    16ee:	14 ff       	sbrs	r17, 4
    16f0:	13 c0       	rjmp	.+38     	; 0x1718 <vfprintf+0x144>
    16f2:	fe 01       	movw	r30, r28
    16f4:	e0 0f       	add	r30, r16
    16f6:	f1 1d       	adc	r31, r1
    16f8:	80 81       	ld	r24, Z
    16fa:	80 33       	cpi	r24, 0x30	; 48
    16fc:	69 f0       	breq	.+26     	; 0x1718 <vfprintf+0x144>
    16fe:	b6 01       	movw	r22, r12
    1700:	80 e3       	ldi	r24, 0x30	; 48
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	bb d2       	rcall	.+1398   	; 0x1c7c <fputc>
    1706:	12 ff       	sbrs	r17, 2
    1708:	07 c0       	rjmp	.+14     	; 0x1718 <vfprintf+0x144>
    170a:	10 72       	andi	r17, 0x20	; 32
    170c:	81 2f       	mov	r24, r17
    170e:	90 e0       	ldi	r25, 0x00	; 0
    1710:	b6 01       	movw	r22, r12
    1712:	88 5a       	subi	r24, 0xA8	; 168
    1714:	9f 4f       	sbci	r25, 0xFF	; 255
    1716:	b2 d2       	rcall	.+1380   	; 0x1c7c <fputc>
    1718:	01 50       	subi	r16, 0x01	; 1
    171a:	10 e0       	ldi	r17, 0x00	; 0
    171c:	0f 5f       	subi	r16, 0xFF	; 255
    171e:	1f 4f       	sbci	r17, 0xFF	; 255
    1720:	08 0d       	add	r16, r8
    1722:	19 1d       	adc	r17, r9
    1724:	f8 01       	movw	r30, r16
    1726:	82 91       	ld	r24, -Z
    1728:	8f 01       	movw	r16, r30
    172a:	b6 01       	movw	r22, r12
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	a6 d2       	rcall	.+1356   	; 0x1c7c <fputc>
    1730:	08 15       	cp	r16, r8
    1732:	19 05       	cpc	r17, r9
    1734:	b9 f7       	brne	.-18     	; 0x1724 <vfprintf+0x150>
    1736:	77 cf       	rjmp	.-274    	; 0x1626 <vfprintf+0x52>
    1738:	53 01       	movw	r10, r6
    173a:	82 e0       	ldi	r24, 0x02	; 2
    173c:	a8 0e       	add	r10, r24
    173e:	b1 1c       	adc	r11, r1
    1740:	b6 01       	movw	r22, r12
    1742:	f3 01       	movw	r30, r6
    1744:	80 81       	ld	r24, Z
    1746:	91 81       	ldd	r25, Z+1	; 0x01
    1748:	a0 cf       	rjmp	.-192    	; 0x168a <vfprintf+0xb6>
    174a:	11 60       	ori	r17, 0x01	; 1
    174c:	53 01       	movw	r10, r6
    174e:	f2 e0       	ldi	r31, 0x02	; 2
    1750:	af 0e       	add	r10, r31
    1752:	b1 1c       	adc	r11, r1
    1754:	f3 01       	movw	r30, r6
    1756:	60 80       	ld	r6, Z
    1758:	71 80       	ldd	r7, Z+1	; 0x01
    175a:	f3 01       	movw	r30, r6
    175c:	10 fd       	sbrc	r17, 0
    175e:	85 91       	lpm	r24, Z+
    1760:	10 ff       	sbrs	r17, 0
    1762:	81 91       	ld	r24, Z+
    1764:	3f 01       	movw	r6, r30
    1766:	88 23       	and	r24, r24
    1768:	09 f4       	brne	.+2      	; 0x176c <vfprintf+0x198>
    176a:	5d cf       	rjmp	.-326    	; 0x1626 <vfprintf+0x52>
    176c:	b6 01       	movw	r22, r12
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	85 d2       	rcall	.+1290   	; 0x1c7c <fputc>
    1772:	f3 cf       	rjmp	.-26     	; 0x175a <vfprintf+0x186>
    1774:	f2 e0       	ldi	r31, 0x02	; 2
    1776:	af 0e       	add	r10, r31
    1778:	b1 1c       	adc	r11, r1
    177a:	f3 01       	movw	r30, r6
    177c:	60 81       	ld	r22, Z
    177e:	71 81       	ldd	r23, Z+1	; 0x01
    1780:	07 2e       	mov	r0, r23
    1782:	00 0c       	add	r0, r0
    1784:	88 0b       	sbc	r24, r24
    1786:	99 0b       	sbc	r25, r25
    1788:	9b cf       	rjmp	.-202    	; 0x16c0 <vfprintf+0xec>
    178a:	00 37       	cpi	r16, 0x70	; 112
    178c:	09 f1       	breq	.+66     	; 0x17d0 <vfprintf+0x1fc>
    178e:	40 f4       	brcc	.+16     	; 0x17a0 <vfprintf+0x1cc>
    1790:	08 35       	cpi	r16, 0x58	; 88
    1792:	01 f1       	breq	.+64     	; 0x17d4 <vfprintf+0x200>
    1794:	0f 36       	cpi	r16, 0x6F	; 111
    1796:	09 f0       	breq	.+2      	; 0x179a <vfprintf+0x1c6>
    1798:	60 cf       	rjmp	.-320    	; 0x165a <vfprintf+0x86>
    179a:	28 e0       	ldi	r18, 0x08	; 8
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	0c c0       	rjmp	.+24     	; 0x17b8 <vfprintf+0x1e4>
    17a0:	05 37       	cpi	r16, 0x75	; 117
    17a2:	39 f0       	breq	.+14     	; 0x17b2 <vfprintf+0x1de>
    17a4:	08 37       	cpi	r16, 0x78	; 120
    17a6:	09 f0       	breq	.+2      	; 0x17aa <vfprintf+0x1d6>
    17a8:	58 cf       	rjmp	.-336    	; 0x165a <vfprintf+0x86>
    17aa:	14 62       	ori	r17, 0x24	; 36
    17ac:	20 e1       	ldi	r18, 0x10	; 16
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	03 c0       	rjmp	.+6      	; 0x17b8 <vfprintf+0x1e4>
    17b2:	1f 7e       	andi	r17, 0xEF	; 239
    17b4:	2a e0       	ldi	r18, 0x0A	; 10
    17b6:	30 e0       	ldi	r19, 0x00	; 0
    17b8:	53 01       	movw	r10, r6
    17ba:	17 ff       	sbrs	r17, 7
    17bc:	0f c0       	rjmp	.+30     	; 0x17dc <vfprintf+0x208>
    17be:	f4 e0       	ldi	r31, 0x04	; 4
    17c0:	af 0e       	add	r10, r31
    17c2:	b1 1c       	adc	r11, r1
    17c4:	f3 01       	movw	r30, r6
    17c6:	60 81       	ld	r22, Z
    17c8:	71 81       	ldd	r23, Z+1	; 0x01
    17ca:	82 81       	ldd	r24, Z+2	; 0x02
    17cc:	93 81       	ldd	r25, Z+3	; 0x03
    17ce:	85 cf       	rjmp	.-246    	; 0x16da <vfprintf+0x106>
    17d0:	10 61       	ori	r17, 0x10	; 16
    17d2:	eb cf       	rjmp	.-42     	; 0x17aa <vfprintf+0x1d6>
    17d4:	14 60       	ori	r17, 0x04	; 4
    17d6:	20 e1       	ldi	r18, 0x10	; 16
    17d8:	32 e0       	ldi	r19, 0x02	; 2
    17da:	ee cf       	rjmp	.-36     	; 0x17b8 <vfprintf+0x1e4>
    17dc:	f2 e0       	ldi	r31, 0x02	; 2
    17de:	af 0e       	add	r10, r31
    17e0:	b1 1c       	adc	r11, r1
    17e2:	f3 01       	movw	r30, r6
    17e4:	60 81       	ld	r22, Z
    17e6:	71 81       	ldd	r23, Z+1	; 0x01
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	80 e0       	ldi	r24, 0x00	; 0
    17ec:	76 cf       	rjmp	.-276    	; 0x16da <vfprintf+0x106>
    17ee:	8f ef       	ldi	r24, 0xFF	; 255
    17f0:	9f ef       	ldi	r25, 0xFF	; 255
    17f2:	36 cf       	rjmp	.-404    	; 0x1660 <vfprintf+0x8c>

000017f4 <putval>:
    17f4:	20 fd       	sbrc	r18, 0
    17f6:	09 c0       	rjmp	.+18     	; 0x180a <putval+0x16>
    17f8:	fc 01       	movw	r30, r24
    17fa:	23 fd       	sbrc	r18, 3
    17fc:	05 c0       	rjmp	.+10     	; 0x1808 <putval+0x14>
    17fe:	22 ff       	sbrs	r18, 2
    1800:	02 c0       	rjmp	.+4      	; 0x1806 <putval+0x12>
    1802:	73 83       	std	Z+3, r23	; 0x03
    1804:	62 83       	std	Z+2, r22	; 0x02
    1806:	51 83       	std	Z+1, r21	; 0x01
    1808:	40 83       	st	Z, r20
    180a:	08 95       	ret

0000180c <mulacc>:
    180c:	44 fd       	sbrc	r20, 4
    180e:	17 c0       	rjmp	.+46     	; 0x183e <mulacc+0x32>
    1810:	46 fd       	sbrc	r20, 6
    1812:	1d c0       	rjmp	.+58     	; 0x184e <mulacc+0x42>
    1814:	db 01       	movw	r26, r22
    1816:	fc 01       	movw	r30, r24
    1818:	aa 0f       	add	r26, r26
    181a:	bb 1f       	adc	r27, r27
    181c:	ee 1f       	adc	r30, r30
    181e:	ff 1f       	adc	r31, r31
    1820:	10 94       	com	r1
    1822:	d1 f7       	brne	.-12     	; 0x1818 <mulacc+0xc>
    1824:	6a 0f       	add	r22, r26
    1826:	7b 1f       	adc	r23, r27
    1828:	8e 1f       	adc	r24, r30
    182a:	9f 1f       	adc	r25, r31
    182c:	66 0f       	add	r22, r22
    182e:	77 1f       	adc	r23, r23
    1830:	88 1f       	adc	r24, r24
    1832:	99 1f       	adc	r25, r25
    1834:	62 0f       	add	r22, r18
    1836:	71 1d       	adc	r23, r1
    1838:	81 1d       	adc	r24, r1
    183a:	91 1d       	adc	r25, r1
    183c:	08 95       	ret
    183e:	33 e0       	ldi	r19, 0x03	; 3
    1840:	66 0f       	add	r22, r22
    1842:	77 1f       	adc	r23, r23
    1844:	88 1f       	adc	r24, r24
    1846:	99 1f       	adc	r25, r25
    1848:	31 50       	subi	r19, 0x01	; 1
    184a:	d1 f7       	brne	.-12     	; 0x1840 <mulacc+0x34>
    184c:	f3 cf       	rjmp	.-26     	; 0x1834 <mulacc+0x28>
    184e:	34 e0       	ldi	r19, 0x04	; 4
    1850:	f7 cf       	rjmp	.-18     	; 0x1840 <mulacc+0x34>

00001852 <skip_spaces>:
    1852:	0f 93       	push	r16
    1854:	1f 93       	push	r17
    1856:	cf 93       	push	r28
    1858:	df 93       	push	r29
    185a:	8c 01       	movw	r16, r24
    185c:	c8 01       	movw	r24, r16
    185e:	d2 d1       	rcall	.+932    	; 0x1c04 <fgetc>
    1860:	ec 01       	movw	r28, r24
    1862:	97 fd       	sbrc	r25, 7
    1864:	06 c0       	rjmp	.+12     	; 0x1872 <skip_spaces+0x20>
    1866:	b2 d1       	rcall	.+868    	; 0x1bcc <isspace>
    1868:	89 2b       	or	r24, r25
    186a:	c1 f7       	brne	.-16     	; 0x185c <skip_spaces+0xa>
    186c:	b8 01       	movw	r22, r16
    186e:	ce 01       	movw	r24, r28
    1870:	35 d2       	rcall	.+1130   	; 0x1cdc <ungetc>
    1872:	ce 01       	movw	r24, r28
    1874:	df 91       	pop	r29
    1876:	cf 91       	pop	r28
    1878:	1f 91       	pop	r17
    187a:	0f 91       	pop	r16
    187c:	08 95       	ret

0000187e <conv_int>:
    187e:	8f 92       	push	r8
    1880:	9f 92       	push	r9
    1882:	af 92       	push	r10
    1884:	bf 92       	push	r11
    1886:	ef 92       	push	r14
    1888:	ff 92       	push	r15
    188a:	0f 93       	push	r16
    188c:	1f 93       	push	r17
    188e:	cf 93       	push	r28
    1890:	df 93       	push	r29
    1892:	8c 01       	movw	r16, r24
    1894:	d6 2f       	mov	r29, r22
    1896:	7a 01       	movw	r14, r20
    1898:	b2 2e       	mov	r11, r18
    189a:	b4 d1       	rcall	.+872    	; 0x1c04 <fgetc>
    189c:	9c 01       	movw	r18, r24
    189e:	33 27       	eor	r19, r19
    18a0:	2b 32       	cpi	r18, 0x2B	; 43
    18a2:	31 05       	cpc	r19, r1
    18a4:	29 f0       	breq	.+10     	; 0x18b0 <conv_int+0x32>
    18a6:	2d 32       	cpi	r18, 0x2D	; 45
    18a8:	31 05       	cpc	r19, r1
    18aa:	a1 f4       	brne	.+40     	; 0x18d4 <conv_int+0x56>
    18ac:	68 94       	set
    18ae:	b7 f8       	bld	r11, 7
    18b0:	d1 50       	subi	r29, 0x01	; 1
    18b2:	61 f4       	brne	.+24     	; 0x18cc <conv_int+0x4e>
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	df 91       	pop	r29
    18b8:	cf 91       	pop	r28
    18ba:	1f 91       	pop	r17
    18bc:	0f 91       	pop	r16
    18be:	ff 90       	pop	r15
    18c0:	ef 90       	pop	r14
    18c2:	bf 90       	pop	r11
    18c4:	af 90       	pop	r10
    18c6:	9f 90       	pop	r9
    18c8:	8f 90       	pop	r8
    18ca:	08 95       	ret
    18cc:	c8 01       	movw	r24, r16
    18ce:	9a d1       	rcall	.+820    	; 0x1c04 <fgetc>
    18d0:	97 fd       	sbrc	r25, 7
    18d2:	f0 cf       	rjmp	.-32     	; 0x18b4 <conv_int+0x36>
    18d4:	cb 2d       	mov	r28, r11
    18d6:	cd 7f       	andi	r28, 0xFD	; 253
    18d8:	2b 2d       	mov	r18, r11
    18da:	20 73       	andi	r18, 0x30	; 48
    18dc:	e9 f4       	brne	.+58     	; 0x1918 <conv_int+0x9a>
    18de:	80 33       	cpi	r24, 0x30	; 48
    18e0:	d9 f4       	brne	.+54     	; 0x1918 <conv_int+0x9a>
    18e2:	aa 24       	eor	r10, r10
    18e4:	aa 94       	dec	r10
    18e6:	ad 0e       	add	r10, r29
    18e8:	79 f0       	breq	.+30     	; 0x1908 <conv_int+0x8a>
    18ea:	c8 01       	movw	r24, r16
    18ec:	8b d1       	rcall	.+790    	; 0x1c04 <fgetc>
    18ee:	97 fd       	sbrc	r25, 7
    18f0:	0b c0       	rjmp	.+22     	; 0x1908 <conv_int+0x8a>
    18f2:	28 2f       	mov	r18, r24
    18f4:	2f 7d       	andi	r18, 0xDF	; 223
    18f6:	28 35       	cpi	r18, 0x58	; 88
    18f8:	59 f4       	brne	.+22     	; 0x1910 <conv_int+0x92>
    18fa:	c2 64       	ori	r28, 0x42	; 66
    18fc:	d2 50       	subi	r29, 0x02	; 2
    18fe:	21 f0       	breq	.+8      	; 0x1908 <conv_int+0x8a>
    1900:	c8 01       	movw	r24, r16
    1902:	80 d1       	rcall	.+768    	; 0x1c04 <fgetc>
    1904:	97 ff       	sbrs	r25, 7
    1906:	08 c0       	rjmp	.+16     	; 0x1918 <conv_int+0x9a>
    1908:	81 2c       	mov	r8, r1
    190a:	91 2c       	mov	r9, r1
    190c:	54 01       	movw	r10, r8
    190e:	1a c0       	rjmp	.+52     	; 0x1944 <conv_int+0xc6>
    1910:	b6 fe       	sbrs	r11, 6
    1912:	29 c0       	rjmp	.+82     	; 0x1966 <conv_int+0xe8>
    1914:	c2 60       	ori	r28, 0x02	; 2
    1916:	da 2d       	mov	r29, r10
    1918:	81 2c       	mov	r8, r1
    191a:	91 2c       	mov	r9, r1
    191c:	54 01       	movw	r10, r8
    191e:	20 ed       	ldi	r18, 0xD0	; 208
    1920:	28 0f       	add	r18, r24
    1922:	28 30       	cpi	r18, 0x08	; 8
    1924:	18 f1       	brcs	.+70     	; 0x196c <conv_int+0xee>
    1926:	c4 fd       	sbrc	r28, 4
    1928:	09 c0       	rjmp	.+18     	; 0x193c <conv_int+0xbe>
    192a:	2a 30       	cpi	r18, 0x0A	; 10
    192c:	f8 f0       	brcs	.+62     	; 0x196c <conv_int+0xee>
    192e:	c6 ff       	sbrs	r28, 6
    1930:	05 c0       	rjmp	.+10     	; 0x193c <conv_int+0xbe>
    1932:	2f 7d       	andi	r18, 0xDF	; 223
    1934:	3f ee       	ldi	r19, 0xEF	; 239
    1936:	32 0f       	add	r19, r18
    1938:	36 30       	cpi	r19, 0x06	; 6
    193a:	b8 f0       	brcs	.+46     	; 0x196a <conv_int+0xec>
    193c:	b8 01       	movw	r22, r16
    193e:	ce d1       	rcall	.+924    	; 0x1cdc <ungetc>
    1940:	c1 ff       	sbrs	r28, 1
    1942:	b8 cf       	rjmp	.-144    	; 0x18b4 <conv_int+0x36>
    1944:	c7 ff       	sbrs	r28, 7
    1946:	08 c0       	rjmp	.+16     	; 0x1958 <conv_int+0xda>
    1948:	b0 94       	com	r11
    194a:	a0 94       	com	r10
    194c:	90 94       	com	r9
    194e:	80 94       	com	r8
    1950:	81 1c       	adc	r8, r1
    1952:	91 1c       	adc	r9, r1
    1954:	a1 1c       	adc	r10, r1
    1956:	b1 1c       	adc	r11, r1
    1958:	2c 2f       	mov	r18, r28
    195a:	b5 01       	movw	r22, r10
    195c:	a4 01       	movw	r20, r8
    195e:	c7 01       	movw	r24, r14
    1960:	49 df       	rcall	.-366    	; 0x17f4 <putval>
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	a8 cf       	rjmp	.-176    	; 0x18b6 <conv_int+0x38>
    1966:	c2 61       	ori	r28, 0x12	; 18
    1968:	d6 cf       	rjmp	.-84     	; 0x1916 <conv_int+0x98>
    196a:	27 50       	subi	r18, 0x07	; 7
    196c:	4c 2f       	mov	r20, r28
    196e:	c5 01       	movw	r24, r10
    1970:	b4 01       	movw	r22, r8
    1972:	4c df       	rcall	.-360    	; 0x180c <mulacc>
    1974:	4b 01       	movw	r8, r22
    1976:	5c 01       	movw	r10, r24
    1978:	c2 60       	ori	r28, 0x02	; 2
    197a:	d1 50       	subi	r29, 0x01	; 1
    197c:	19 f3       	breq	.-58     	; 0x1944 <conv_int+0xc6>
    197e:	c8 01       	movw	r24, r16
    1980:	41 d1       	rcall	.+642    	; 0x1c04 <fgetc>
    1982:	97 ff       	sbrs	r25, 7
    1984:	cc cf       	rjmp	.-104    	; 0x191e <conv_int+0xa0>
    1986:	dc cf       	rjmp	.-72     	; 0x1940 <conv_int+0xc2>

00001988 <vfscanf>:
    1988:	b0 e0       	ldi	r27, 0x00	; 0
    198a:	a0 e0       	ldi	r26, 0x00	; 0
    198c:	e9 ec       	ldi	r30, 0xC9	; 201
    198e:	fc e0       	ldi	r31, 0x0C	; 12
    1990:	e9 c0       	rjmp	.+466    	; 0x1b64 <__prologue_saves__+0x6>
    1992:	6c 01       	movw	r12, r24
    1994:	eb 01       	movw	r28, r22
    1996:	5a 01       	movw	r10, r20
    1998:	fc 01       	movw	r30, r24
    199a:	17 82       	std	Z+7, r1	; 0x07
    199c:	16 82       	std	Z+6, r1	; 0x06
    199e:	51 2c       	mov	r5, r1
    19a0:	f6 01       	movw	r30, r12
    19a2:	f3 80       	ldd	r15, Z+3	; 0x03
    19a4:	fe 01       	movw	r30, r28
    19a6:	f3 fc       	sbrc	r15, 3
    19a8:	85 91       	lpm	r24, Z+
    19aa:	f3 fe       	sbrs	r15, 3
    19ac:	81 91       	ld	r24, Z+
    19ae:	18 2f       	mov	r17, r24
    19b0:	ef 01       	movw	r28, r30
    19b2:	88 23       	and	r24, r24
    19b4:	c9 f0       	breq	.+50     	; 0x19e8 <vfscanf+0x60>
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	09 d1       	rcall	.+530    	; 0x1bcc <isspace>
    19ba:	89 2b       	or	r24, r25
    19bc:	19 f0       	breq	.+6      	; 0x19c4 <vfscanf+0x3c>
    19be:	c6 01       	movw	r24, r12
    19c0:	48 df       	rcall	.-368    	; 0x1852 <skip_spaces>
    19c2:	ee cf       	rjmp	.-36     	; 0x19a0 <vfscanf+0x18>
    19c4:	15 32       	cpi	r17, 0x25	; 37
    19c6:	41 f4       	brne	.+16     	; 0x19d8 <vfscanf+0x50>
    19c8:	fe 01       	movw	r30, r28
    19ca:	f3 fc       	sbrc	r15, 3
    19cc:	15 91       	lpm	r17, Z+
    19ce:	f3 fe       	sbrs	r15, 3
    19d0:	11 91       	ld	r17, Z+
    19d2:	ef 01       	movw	r28, r30
    19d4:	15 32       	cpi	r17, 0x25	; 37
    19d6:	59 f4       	brne	.+22     	; 0x19ee <vfscanf+0x66>
    19d8:	c6 01       	movw	r24, r12
    19da:	14 d1       	rcall	.+552    	; 0x1c04 <fgetc>
    19dc:	97 fd       	sbrc	r25, 7
    19de:	98 c0       	rjmp	.+304    	; 0x1b10 <vfscanf+0x188>
    19e0:	18 17       	cp	r17, r24
    19e2:	f1 f2       	breq	.-68     	; 0x19a0 <vfscanf+0x18>
    19e4:	b6 01       	movw	r22, r12
    19e6:	7a d1       	rcall	.+756    	; 0x1cdc <ungetc>
    19e8:	85 2d       	mov	r24, r5
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	95 c0       	rjmp	.+298    	; 0x1b18 <vfscanf+0x190>
    19ee:	00 e0       	ldi	r16, 0x00	; 0
    19f0:	1a 32       	cpi	r17, 0x2A	; 42
    19f2:	31 f4       	brne	.+12     	; 0x1a00 <vfscanf+0x78>
    19f4:	f3 fc       	sbrc	r15, 3
    19f6:	15 91       	lpm	r17, Z+
    19f8:	f3 fe       	sbrs	r15, 3
    19fa:	11 91       	ld	r17, Z+
    19fc:	ef 01       	movw	r28, r30
    19fe:	01 e0       	ldi	r16, 0x01	; 1
    1a00:	e1 2c       	mov	r14, r1
    1a02:	20 ed       	ldi	r18, 0xD0	; 208
    1a04:	21 0f       	add	r18, r17
    1a06:	2a 30       	cpi	r18, 0x0A	; 10
    1a08:	38 f1       	brcs	.+78     	; 0x1a58 <vfscanf+0xd0>
    1a0a:	01 ff       	sbrs	r16, 1
    1a0c:	34 c0       	rjmp	.+104    	; 0x1a76 <vfscanf+0xee>
    1a0e:	ee 20       	and	r14, r14
    1a10:	59 f3       	breq	.-42     	; 0x19e8 <vfscanf+0x60>
    1a12:	18 36       	cpi	r17, 0x68	; 104
    1a14:	99 f1       	breq	.+102    	; 0x1a7c <vfscanf+0xf4>
    1a16:	1c 36       	cpi	r17, 0x6C	; 108
    1a18:	09 f4       	brne	.+2      	; 0x1a1c <vfscanf+0x94>
    1a1a:	3a c0       	rjmp	.+116    	; 0x1a90 <vfscanf+0x108>
    1a1c:	11 23       	and	r17, r17
    1a1e:	21 f3       	breq	.-56     	; 0x19e8 <vfscanf+0x60>
    1a20:	61 2f       	mov	r22, r17
    1a22:	70 e0       	ldi	r23, 0x00	; 0
    1a24:	8f e7       	ldi	r24, 0x7F	; 127
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	d9 d0       	rcall	.+434    	; 0x1bdc <strchr_P>
    1a2a:	89 2b       	or	r24, r25
    1a2c:	e9 f2       	breq	.-70     	; 0x19e8 <vfscanf+0x60>
    1a2e:	91 2c       	mov	r9, r1
    1a30:	81 2c       	mov	r8, r1
    1a32:	00 fd       	sbrc	r16, 0
    1a34:	06 c0       	rjmp	.+12     	; 0x1a42 <vfscanf+0xba>
    1a36:	f5 01       	movw	r30, r10
    1a38:	80 80       	ld	r8, Z
    1a3a:	91 80       	ldd	r9, Z+1	; 0x01
    1a3c:	c5 01       	movw	r24, r10
    1a3e:	02 96       	adiw	r24, 0x02	; 2
    1a40:	5c 01       	movw	r10, r24
    1a42:	1e 36       	cpi	r17, 0x6E	; 110
    1a44:	69 f5       	brne	.+90     	; 0x1aa0 <vfscanf+0x118>
    1a46:	f6 01       	movw	r30, r12
    1a48:	46 81       	ldd	r20, Z+6	; 0x06
    1a4a:	57 81       	ldd	r21, Z+7	; 0x07
    1a4c:	70 e0       	ldi	r23, 0x00	; 0
    1a4e:	60 e0       	ldi	r22, 0x00	; 0
    1a50:	20 2f       	mov	r18, r16
    1a52:	c4 01       	movw	r24, r8
    1a54:	cf de       	rcall	.-610    	; 0x17f4 <putval>
    1a56:	a4 cf       	rjmp	.-184    	; 0x19a0 <vfscanf+0x18>
    1a58:	02 60       	ori	r16, 0x02	; 2
    1a5a:	6e 2d       	mov	r22, r14
    1a5c:	70 e0       	ldi	r23, 0x00	; 0
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    1a62:	40 e2       	ldi	r20, 0x20	; 32
    1a64:	d3 de       	rcall	.-602    	; 0x180c <mulacc>
    1a66:	e6 2e       	mov	r14, r22
    1a68:	fe 01       	movw	r30, r28
    1a6a:	f3 fc       	sbrc	r15, 3
    1a6c:	15 91       	lpm	r17, Z+
    1a6e:	f3 fe       	sbrs	r15, 3
    1a70:	11 91       	ld	r17, Z+
    1a72:	ef 01       	movw	r28, r30
    1a74:	c6 cf       	rjmp	.-116    	; 0x1a02 <vfscanf+0x7a>
    1a76:	ee 24       	eor	r14, r14
    1a78:	ea 94       	dec	r14
    1a7a:	cb cf       	rjmp	.-106    	; 0x1a12 <vfscanf+0x8a>
    1a7c:	fe 01       	movw	r30, r28
    1a7e:	f3 fc       	sbrc	r15, 3
    1a80:	15 91       	lpm	r17, Z+
    1a82:	f3 fe       	sbrs	r15, 3
    1a84:	11 91       	ld	r17, Z+
    1a86:	ef 01       	movw	r28, r30
    1a88:	18 36       	cpi	r17, 0x68	; 104
    1a8a:	09 f0       	breq	.+2      	; 0x1a8e <vfscanf+0x106>
    1a8c:	c7 cf       	rjmp	.-114    	; 0x1a1c <vfscanf+0x94>
    1a8e:	08 60       	ori	r16, 0x08	; 8
    1a90:	04 60       	ori	r16, 0x04	; 4
    1a92:	fe 01       	movw	r30, r28
    1a94:	f3 fc       	sbrc	r15, 3
    1a96:	15 91       	lpm	r17, Z+
    1a98:	f3 fe       	sbrs	r15, 3
    1a9a:	11 91       	ld	r17, Z+
    1a9c:	ef 01       	movw	r28, r30
    1a9e:	be cf       	rjmp	.-132    	; 0x1a1c <vfscanf+0x94>
    1aa0:	13 36       	cpi	r17, 0x63	; 99
    1aa2:	b9 f4       	brne	.+46     	; 0x1ad2 <vfscanf+0x14a>
    1aa4:	01 fd       	sbrc	r16, 1
    1aa6:	02 c0       	rjmp	.+4      	; 0x1aac <vfscanf+0x124>
    1aa8:	ee 24       	eor	r14, r14
    1aaa:	e3 94       	inc	r14
    1aac:	c6 01       	movw	r24, r12
    1aae:	aa d0       	rcall	.+340    	; 0x1c04 <fgetc>
    1ab0:	97 fd       	sbrc	r25, 7
    1ab2:	2e c0       	rjmp	.+92     	; 0x1b10 <vfscanf+0x188>
    1ab4:	81 14       	cp	r8, r1
    1ab6:	91 04       	cpc	r9, r1
    1ab8:	29 f0       	breq	.+10     	; 0x1ac4 <vfscanf+0x13c>
    1aba:	f4 01       	movw	r30, r8
    1abc:	80 83       	st	Z, r24
    1abe:	c4 01       	movw	r24, r8
    1ac0:	01 96       	adiw	r24, 0x01	; 1
    1ac2:	4c 01       	movw	r8, r24
    1ac4:	ea 94       	dec	r14
    1ac6:	e1 10       	cpse	r14, r1
    1ac8:	f1 cf       	rjmp	.-30     	; 0x1aac <vfscanf+0x124>
    1aca:	00 fd       	sbrc	r16, 0
    1acc:	69 cf       	rjmp	.-302    	; 0x19a0 <vfscanf+0x18>
    1ace:	53 94       	inc	r5
    1ad0:	67 cf       	rjmp	.-306    	; 0x19a0 <vfscanf+0x18>
    1ad2:	c6 01       	movw	r24, r12
    1ad4:	be de       	rcall	.-644    	; 0x1852 <skip_spaces>
    1ad6:	97 fd       	sbrc	r25, 7
    1ad8:	1b c0       	rjmp	.+54     	; 0x1b10 <vfscanf+0x188>
    1ada:	1f 36       	cpi	r17, 0x6F	; 111
    1adc:	09 f4       	brne	.+2      	; 0x1ae0 <vfscanf+0x158>
    1ade:	3d c0       	rjmp	.+122    	; 0x1b5a <vfscanf+0x1d2>
    1ae0:	30 f4       	brcc	.+12     	; 0x1aee <vfscanf+0x166>
    1ae2:	14 36       	cpi	r17, 0x64	; 100
    1ae4:	41 f0       	breq	.+16     	; 0x1af6 <vfscanf+0x16e>
    1ae6:	19 36       	cpi	r17, 0x69	; 105
    1ae8:	39 f0       	breq	.+14     	; 0x1af8 <vfscanf+0x170>
    1aea:	00 64       	ori	r16, 0x40	; 64
    1aec:	05 c0       	rjmp	.+10     	; 0x1af8 <vfscanf+0x170>
    1aee:	13 37       	cpi	r17, 0x73	; 115
    1af0:	11 f1       	breq	.+68     	; 0x1b36 <vfscanf+0x1ae>
    1af2:	15 37       	cpi	r17, 0x75	; 117
    1af4:	d1 f7       	brne	.-12     	; 0x1aea <vfscanf+0x162>
    1af6:	00 62       	ori	r16, 0x20	; 32
    1af8:	20 2f       	mov	r18, r16
    1afa:	a4 01       	movw	r20, r8
    1afc:	6e 2d       	mov	r22, r14
    1afe:	c6 01       	movw	r24, r12
    1b00:	be de       	rcall	.-644    	; 0x187e <conv_int>
    1b02:	81 11       	cpse	r24, r1
    1b04:	e2 cf       	rjmp	.-60     	; 0x1aca <vfscanf+0x142>
    1b06:	f6 01       	movw	r30, r12
    1b08:	83 81       	ldd	r24, Z+3	; 0x03
    1b0a:	80 73       	andi	r24, 0x30	; 48
    1b0c:	09 f4       	brne	.+2      	; 0x1b10 <vfscanf+0x188>
    1b0e:	6c cf       	rjmp	.-296    	; 0x19e8 <vfscanf+0x60>
    1b10:	8f ef       	ldi	r24, 0xFF	; 255
    1b12:	9f ef       	ldi	r25, 0xFF	; 255
    1b14:	51 10       	cpse	r5, r1
    1b16:	68 cf       	rjmp	.-304    	; 0x19e8 <vfscanf+0x60>
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	ef e0       	ldi	r30, 0x0F	; 15
    1b1e:	3e c0       	rjmp	.+124    	; 0x1b9c <__epilogue_restores__+0x6>
    1b20:	81 14       	cp	r8, r1
    1b22:	91 04       	cpc	r9, r1
    1b24:	29 f0       	breq	.+10     	; 0x1b30 <vfscanf+0x1a8>
    1b26:	f4 01       	movw	r30, r8
    1b28:	60 82       	st	Z, r6
    1b2a:	c4 01       	movw	r24, r8
    1b2c:	01 96       	adiw	r24, 0x01	; 1
    1b2e:	4c 01       	movw	r8, r24
    1b30:	ea 94       	dec	r14
    1b32:	ee 20       	and	r14, r14
    1b34:	59 f0       	breq	.+22     	; 0x1b4c <vfscanf+0x1c4>
    1b36:	c6 01       	movw	r24, r12
    1b38:	65 d0       	rcall	.+202    	; 0x1c04 <fgetc>
    1b3a:	3c 01       	movw	r6, r24
    1b3c:	97 fd       	sbrc	r25, 7
    1b3e:	06 c0       	rjmp	.+12     	; 0x1b4c <vfscanf+0x1c4>
    1b40:	45 d0       	rcall	.+138    	; 0x1bcc <isspace>
    1b42:	89 2b       	or	r24, r25
    1b44:	69 f3       	breq	.-38     	; 0x1b20 <vfscanf+0x198>
    1b46:	b6 01       	movw	r22, r12
    1b48:	c3 01       	movw	r24, r6
    1b4a:	c8 d0       	rcall	.+400    	; 0x1cdc <ungetc>
    1b4c:	81 14       	cp	r8, r1
    1b4e:	91 04       	cpc	r9, r1
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <vfscanf+0x1cc>
    1b52:	bb cf       	rjmp	.-138    	; 0x1aca <vfscanf+0x142>
    1b54:	f4 01       	movw	r30, r8
    1b56:	10 82       	st	Z, r1
    1b58:	b8 cf       	rjmp	.-144    	; 0x1aca <vfscanf+0x142>
    1b5a:	00 61       	ori	r16, 0x10	; 16
    1b5c:	cd cf       	rjmp	.-102    	; 0x1af8 <vfscanf+0x170>

00001b5e <__prologue_saves__>:
    1b5e:	2f 92       	push	r2
    1b60:	3f 92       	push	r3
    1b62:	4f 92       	push	r4
    1b64:	5f 92       	push	r5
    1b66:	6f 92       	push	r6
    1b68:	7f 92       	push	r7
    1b6a:	8f 92       	push	r8
    1b6c:	9f 92       	push	r9
    1b6e:	af 92       	push	r10
    1b70:	bf 92       	push	r11
    1b72:	cf 92       	push	r12
    1b74:	df 92       	push	r13
    1b76:	ef 92       	push	r14
    1b78:	ff 92       	push	r15
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	cf 93       	push	r28
    1b80:	df 93       	push	r29
    1b82:	cd b7       	in	r28, 0x3d	; 61
    1b84:	de b7       	in	r29, 0x3e	; 62
    1b86:	ca 1b       	sub	r28, r26
    1b88:	db 0b       	sbc	r29, r27
    1b8a:	0f b6       	in	r0, 0x3f	; 63
    1b8c:	f8 94       	cli
    1b8e:	de bf       	out	0x3e, r29	; 62
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	cd bf       	out	0x3d, r28	; 61
    1b94:	09 94       	ijmp

00001b96 <__epilogue_restores__>:
    1b96:	2a 88       	ldd	r2, Y+18	; 0x12
    1b98:	39 88       	ldd	r3, Y+17	; 0x11
    1b9a:	48 88       	ldd	r4, Y+16	; 0x10
    1b9c:	5f 84       	ldd	r5, Y+15	; 0x0f
    1b9e:	6e 84       	ldd	r6, Y+14	; 0x0e
    1ba0:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ba2:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ba4:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ba6:	aa 84       	ldd	r10, Y+10	; 0x0a
    1ba8:	b9 84       	ldd	r11, Y+9	; 0x09
    1baa:	c8 84       	ldd	r12, Y+8	; 0x08
    1bac:	df 80       	ldd	r13, Y+7	; 0x07
    1bae:	ee 80       	ldd	r14, Y+6	; 0x06
    1bb0:	fd 80       	ldd	r15, Y+5	; 0x05
    1bb2:	0c 81       	ldd	r16, Y+4	; 0x04
    1bb4:	1b 81       	ldd	r17, Y+3	; 0x03
    1bb6:	aa 81       	ldd	r26, Y+2	; 0x02
    1bb8:	b9 81       	ldd	r27, Y+1	; 0x01
    1bba:	ce 0f       	add	r28, r30
    1bbc:	d1 1d       	adc	r29, r1
    1bbe:	0f b6       	in	r0, 0x3f	; 63
    1bc0:	f8 94       	cli
    1bc2:	de bf       	out	0x3e, r29	; 62
    1bc4:	0f be       	out	0x3f, r0	; 63
    1bc6:	cd bf       	out	0x3d, r28	; 61
    1bc8:	ed 01       	movw	r28, r26
    1bca:	08 95       	ret

00001bcc <isspace>:
    1bcc:	91 11       	cpse	r25, r1
    1bce:	fc c0       	rjmp	.+504    	; 0x1dc8 <__ctype_isfalse>
    1bd0:	80 32       	cpi	r24, 0x20	; 32
    1bd2:	19 f0       	breq	.+6      	; 0x1bda <isspace+0xe>
    1bd4:	89 50       	subi	r24, 0x09	; 9
    1bd6:	85 50       	subi	r24, 0x05	; 5
    1bd8:	d0 f7       	brcc	.-12     	; 0x1bce <isspace+0x2>
    1bda:	08 95       	ret

00001bdc <strchr_P>:
    1bdc:	fc 01       	movw	r30, r24
    1bde:	05 90       	lpm	r0, Z+
    1be0:	06 16       	cp	r0, r22
    1be2:	21 f0       	breq	.+8      	; 0x1bec <strchr_P+0x10>
    1be4:	00 20       	and	r0, r0
    1be6:	d9 f7       	brne	.-10     	; 0x1bde <strchr_P+0x2>
    1be8:	c0 01       	movw	r24, r0
    1bea:	08 95       	ret
    1bec:	31 97       	sbiw	r30, 0x01	; 1
    1bee:	cf 01       	movw	r24, r30
    1bf0:	08 95       	ret

00001bf2 <memcpy>:
    1bf2:	fb 01       	movw	r30, r22
    1bf4:	dc 01       	movw	r26, r24
    1bf6:	02 c0       	rjmp	.+4      	; 0x1bfc <memcpy+0xa>
    1bf8:	01 90       	ld	r0, Z+
    1bfa:	0d 92       	st	X+, r0
    1bfc:	41 50       	subi	r20, 0x01	; 1
    1bfe:	50 40       	sbci	r21, 0x00	; 0
    1c00:	d8 f7       	brcc	.-10     	; 0x1bf8 <memcpy+0x6>
    1c02:	08 95       	ret

00001c04 <fgetc>:
    1c04:	cf 93       	push	r28
    1c06:	df 93       	push	r29
    1c08:	ec 01       	movw	r28, r24
    1c0a:	2b 81       	ldd	r18, Y+3	; 0x03
    1c0c:	20 ff       	sbrs	r18, 0
    1c0e:	1a c0       	rjmp	.+52     	; 0x1c44 <fgetc+0x40>
    1c10:	26 ff       	sbrs	r18, 6
    1c12:	0c c0       	rjmp	.+24     	; 0x1c2c <fgetc+0x28>
    1c14:	2f 7b       	andi	r18, 0xBF	; 191
    1c16:	2b 83       	std	Y+3, r18	; 0x03
    1c18:	8e 81       	ldd	r24, Y+6	; 0x06
    1c1a:	9f 81       	ldd	r25, Y+7	; 0x07
    1c1c:	01 96       	adiw	r24, 0x01	; 1
    1c1e:	9f 83       	std	Y+7, r25	; 0x07
    1c20:	8e 83       	std	Y+6, r24	; 0x06
    1c22:	8a 81       	ldd	r24, Y+2	; 0x02
    1c24:	90 e0       	ldi	r25, 0x00	; 0
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	08 95       	ret
    1c2c:	22 ff       	sbrs	r18, 2
    1c2e:	18 c0       	rjmp	.+48     	; 0x1c60 <fgetc+0x5c>
    1c30:	e8 81       	ld	r30, Y
    1c32:	f9 81       	ldd	r31, Y+1	; 0x01
    1c34:	80 81       	ld	r24, Z
    1c36:	08 2e       	mov	r0, r24
    1c38:	00 0c       	add	r0, r0
    1c3a:	99 0b       	sbc	r25, r25
    1c3c:	00 97       	sbiw	r24, 0x00	; 0
    1c3e:	29 f4       	brne	.+10     	; 0x1c4a <fgetc+0x46>
    1c40:	20 62       	ori	r18, 0x20	; 32
    1c42:	2b 83       	std	Y+3, r18	; 0x03
    1c44:	8f ef       	ldi	r24, 0xFF	; 255
    1c46:	9f ef       	ldi	r25, 0xFF	; 255
    1c48:	ee cf       	rjmp	.-36     	; 0x1c26 <fgetc+0x22>
    1c4a:	31 96       	adiw	r30, 0x01	; 1
    1c4c:	f9 83       	std	Y+1, r31	; 0x01
    1c4e:	e8 83       	st	Y, r30
    1c50:	2e 81       	ldd	r18, Y+6	; 0x06
    1c52:	3f 81       	ldd	r19, Y+7	; 0x07
    1c54:	2f 5f       	subi	r18, 0xFF	; 255
    1c56:	3f 4f       	sbci	r19, 0xFF	; 255
    1c58:	3f 83       	std	Y+7, r19	; 0x07
    1c5a:	2e 83       	std	Y+6, r18	; 0x06
    1c5c:	99 27       	eor	r25, r25
    1c5e:	e3 cf       	rjmp	.-58     	; 0x1c26 <fgetc+0x22>
    1c60:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c62:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c64:	09 95       	icall
    1c66:	97 ff       	sbrs	r25, 7
    1c68:	f3 cf       	rjmp	.-26     	; 0x1c50 <fgetc+0x4c>
    1c6a:	2b 81       	ldd	r18, Y+3	; 0x03
    1c6c:	01 96       	adiw	r24, 0x01	; 1
    1c6e:	21 f0       	breq	.+8      	; 0x1c78 <fgetc+0x74>
    1c70:	80 e2       	ldi	r24, 0x20	; 32
    1c72:	82 2b       	or	r24, r18
    1c74:	8b 83       	std	Y+3, r24	; 0x03
    1c76:	e6 cf       	rjmp	.-52     	; 0x1c44 <fgetc+0x40>
    1c78:	80 e1       	ldi	r24, 0x10	; 16
    1c7a:	fb cf       	rjmp	.-10     	; 0x1c72 <fgetc+0x6e>

00001c7c <fputc>:
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	18 2f       	mov	r17, r24
    1c86:	09 2f       	mov	r16, r25
    1c88:	eb 01       	movw	r28, r22
    1c8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c8c:	81 fd       	sbrc	r24, 1
    1c8e:	09 c0       	rjmp	.+18     	; 0x1ca2 <fputc+0x26>
    1c90:	1f ef       	ldi	r17, 0xFF	; 255
    1c92:	0f ef       	ldi	r16, 0xFF	; 255
    1c94:	81 2f       	mov	r24, r17
    1c96:	90 2f       	mov	r25, r16
    1c98:	df 91       	pop	r29
    1c9a:	cf 91       	pop	r28
    1c9c:	1f 91       	pop	r17
    1c9e:	0f 91       	pop	r16
    1ca0:	08 95       	ret
    1ca2:	82 ff       	sbrs	r24, 2
    1ca4:	14 c0       	rjmp	.+40     	; 0x1cce <fputc+0x52>
    1ca6:	2e 81       	ldd	r18, Y+6	; 0x06
    1ca8:	3f 81       	ldd	r19, Y+7	; 0x07
    1caa:	8c 81       	ldd	r24, Y+4	; 0x04
    1cac:	9d 81       	ldd	r25, Y+5	; 0x05
    1cae:	28 17       	cp	r18, r24
    1cb0:	39 07       	cpc	r19, r25
    1cb2:	3c f4       	brge	.+14     	; 0x1cc2 <fputc+0x46>
    1cb4:	e8 81       	ld	r30, Y
    1cb6:	f9 81       	ldd	r31, Y+1	; 0x01
    1cb8:	cf 01       	movw	r24, r30
    1cba:	01 96       	adiw	r24, 0x01	; 1
    1cbc:	99 83       	std	Y+1, r25	; 0x01
    1cbe:	88 83       	st	Y, r24
    1cc0:	10 83       	st	Z, r17
    1cc2:	8e 81       	ldd	r24, Y+6	; 0x06
    1cc4:	9f 81       	ldd	r25, Y+7	; 0x07
    1cc6:	01 96       	adiw	r24, 0x01	; 1
    1cc8:	9f 83       	std	Y+7, r25	; 0x07
    1cca:	8e 83       	std	Y+6, r24	; 0x06
    1ccc:	e3 cf       	rjmp	.-58     	; 0x1c94 <fputc+0x18>
    1cce:	e8 85       	ldd	r30, Y+8	; 0x08
    1cd0:	f9 85       	ldd	r31, Y+9	; 0x09
    1cd2:	81 2f       	mov	r24, r17
    1cd4:	09 95       	icall
    1cd6:	89 2b       	or	r24, r25
    1cd8:	a1 f3       	breq	.-24     	; 0x1cc2 <fputc+0x46>
    1cda:	da cf       	rjmp	.-76     	; 0x1c90 <fputc+0x14>

00001cdc <ungetc>:
    1cdc:	fb 01       	movw	r30, r22
    1cde:	23 81       	ldd	r18, Z+3	; 0x03
    1ce0:	20 ff       	sbrs	r18, 0
    1ce2:	11 c0       	rjmp	.+34     	; 0x1d06 <ungetc+0x2a>
    1ce4:	26 fd       	sbrc	r18, 6
    1ce6:	0f c0       	rjmp	.+30     	; 0x1d06 <ungetc+0x2a>
    1ce8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cea:	98 07       	cpc	r25, r24
    1cec:	71 f0       	breq	.+28     	; 0x1d0a <ungetc+0x2e>
    1cee:	82 83       	std	Z+2, r24	; 0x02
    1cf0:	2f 7d       	andi	r18, 0xDF	; 223
    1cf2:	20 64       	ori	r18, 0x40	; 64
    1cf4:	23 83       	std	Z+3, r18	; 0x03
    1cf6:	26 81       	ldd	r18, Z+6	; 0x06
    1cf8:	37 81       	ldd	r19, Z+7	; 0x07
    1cfa:	21 50       	subi	r18, 0x01	; 1
    1cfc:	31 09       	sbc	r19, r1
    1cfe:	37 83       	std	Z+7, r19	; 0x07
    1d00:	26 83       	std	Z+6, r18	; 0x06
    1d02:	99 27       	eor	r25, r25
    1d04:	08 95       	ret
    1d06:	8f ef       	ldi	r24, 0xFF	; 255
    1d08:	9f ef       	ldi	r25, 0xFF	; 255
    1d0a:	08 95       	ret

00001d0c <__ultoa_invert>:
    1d0c:	fa 01       	movw	r30, r20
    1d0e:	aa 27       	eor	r26, r26
    1d10:	28 30       	cpi	r18, 0x08	; 8
    1d12:	51 f1       	breq	.+84     	; 0x1d68 <__ultoa_invert+0x5c>
    1d14:	20 31       	cpi	r18, 0x10	; 16
    1d16:	81 f1       	breq	.+96     	; 0x1d78 <__ultoa_invert+0x6c>
    1d18:	e8 94       	clt
    1d1a:	6f 93       	push	r22
    1d1c:	6e 7f       	andi	r22, 0xFE	; 254
    1d1e:	6e 5f       	subi	r22, 0xFE	; 254
    1d20:	7f 4f       	sbci	r23, 0xFF	; 255
    1d22:	8f 4f       	sbci	r24, 0xFF	; 255
    1d24:	9f 4f       	sbci	r25, 0xFF	; 255
    1d26:	af 4f       	sbci	r26, 0xFF	; 255
    1d28:	b1 e0       	ldi	r27, 0x01	; 1
    1d2a:	3e d0       	rcall	.+124    	; 0x1da8 <__ultoa_invert+0x9c>
    1d2c:	b4 e0       	ldi	r27, 0x04	; 4
    1d2e:	3c d0       	rcall	.+120    	; 0x1da8 <__ultoa_invert+0x9c>
    1d30:	67 0f       	add	r22, r23
    1d32:	78 1f       	adc	r23, r24
    1d34:	89 1f       	adc	r24, r25
    1d36:	9a 1f       	adc	r25, r26
    1d38:	a1 1d       	adc	r26, r1
    1d3a:	68 0f       	add	r22, r24
    1d3c:	79 1f       	adc	r23, r25
    1d3e:	8a 1f       	adc	r24, r26
    1d40:	91 1d       	adc	r25, r1
    1d42:	a1 1d       	adc	r26, r1
    1d44:	6a 0f       	add	r22, r26
    1d46:	71 1d       	adc	r23, r1
    1d48:	81 1d       	adc	r24, r1
    1d4a:	91 1d       	adc	r25, r1
    1d4c:	a1 1d       	adc	r26, r1
    1d4e:	20 d0       	rcall	.+64     	; 0x1d90 <__ultoa_invert+0x84>
    1d50:	09 f4       	brne	.+2      	; 0x1d54 <__ultoa_invert+0x48>
    1d52:	68 94       	set
    1d54:	3f 91       	pop	r19
    1d56:	2a e0       	ldi	r18, 0x0A	; 10
    1d58:	26 9f       	mul	r18, r22
    1d5a:	11 24       	eor	r1, r1
    1d5c:	30 19       	sub	r19, r0
    1d5e:	30 5d       	subi	r19, 0xD0	; 208
    1d60:	31 93       	st	Z+, r19
    1d62:	de f6       	brtc	.-74     	; 0x1d1a <__ultoa_invert+0xe>
    1d64:	cf 01       	movw	r24, r30
    1d66:	08 95       	ret
    1d68:	46 2f       	mov	r20, r22
    1d6a:	47 70       	andi	r20, 0x07	; 7
    1d6c:	40 5d       	subi	r20, 0xD0	; 208
    1d6e:	41 93       	st	Z+, r20
    1d70:	b3 e0       	ldi	r27, 0x03	; 3
    1d72:	0f d0       	rcall	.+30     	; 0x1d92 <__ultoa_invert+0x86>
    1d74:	c9 f7       	brne	.-14     	; 0x1d68 <__ultoa_invert+0x5c>
    1d76:	f6 cf       	rjmp	.-20     	; 0x1d64 <__ultoa_invert+0x58>
    1d78:	46 2f       	mov	r20, r22
    1d7a:	4f 70       	andi	r20, 0x0F	; 15
    1d7c:	40 5d       	subi	r20, 0xD0	; 208
    1d7e:	4a 33       	cpi	r20, 0x3A	; 58
    1d80:	18 f0       	brcs	.+6      	; 0x1d88 <__ultoa_invert+0x7c>
    1d82:	49 5d       	subi	r20, 0xD9	; 217
    1d84:	31 fd       	sbrc	r19, 1
    1d86:	40 52       	subi	r20, 0x20	; 32
    1d88:	41 93       	st	Z+, r20
    1d8a:	02 d0       	rcall	.+4      	; 0x1d90 <__ultoa_invert+0x84>
    1d8c:	a9 f7       	brne	.-22     	; 0x1d78 <__ultoa_invert+0x6c>
    1d8e:	ea cf       	rjmp	.-44     	; 0x1d64 <__ultoa_invert+0x58>
    1d90:	b4 e0       	ldi	r27, 0x04	; 4
    1d92:	a6 95       	lsr	r26
    1d94:	97 95       	ror	r25
    1d96:	87 95       	ror	r24
    1d98:	77 95       	ror	r23
    1d9a:	67 95       	ror	r22
    1d9c:	ba 95       	dec	r27
    1d9e:	c9 f7       	brne	.-14     	; 0x1d92 <__ultoa_invert+0x86>
    1da0:	00 97       	sbiw	r24, 0x00	; 0
    1da2:	61 05       	cpc	r22, r1
    1da4:	71 05       	cpc	r23, r1
    1da6:	08 95       	ret
    1da8:	9b 01       	movw	r18, r22
    1daa:	ac 01       	movw	r20, r24
    1dac:	0a 2e       	mov	r0, r26
    1dae:	06 94       	lsr	r0
    1db0:	57 95       	ror	r21
    1db2:	47 95       	ror	r20
    1db4:	37 95       	ror	r19
    1db6:	27 95       	ror	r18
    1db8:	ba 95       	dec	r27
    1dba:	c9 f7       	brne	.-14     	; 0x1dae <__ultoa_invert+0xa2>
    1dbc:	62 0f       	add	r22, r18
    1dbe:	73 1f       	adc	r23, r19
    1dc0:	84 1f       	adc	r24, r20
    1dc2:	95 1f       	adc	r25, r21
    1dc4:	a0 1d       	adc	r26, r0
    1dc6:	08 95       	ret

00001dc8 <__ctype_isfalse>:
    1dc8:	99 27       	eor	r25, r25
    1dca:	88 27       	eor	r24, r24

00001dcc <__ctype_istrue>:
    1dcc:	08 95       	ret

00001dce <_exit>:
    1dce:	f8 94       	cli

00001dd0 <__stop_program>:
    1dd0:	ff cf       	rjmp	.-2      	; 0x1dd0 <__stop_program>
