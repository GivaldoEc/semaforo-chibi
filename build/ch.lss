
build/ch.elf: formato do arquivo elf32-avr

Seções:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005a  00800100  00002a68  00002afc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a68  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000328  0080015a  0080015a  00002b56  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002b56  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002b68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007a0  00000000  00000000  00002ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001c772  00000000  00000000  00003348  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004e84  00000000  00000000  0001faba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000066d4  00000000  00000000  0002493e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001710  00000000  00000000  0002b014  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000020b3  00000000  00000000  0002c724  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000074b6  00000000  00000000  0002e7d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b18  00000000  00000000  00035c8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Desmontagem da seção .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	c4 c3       	rjmp	.+1928   	; 0x7b6 <__vector_11>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	45 c0       	rjmp	.+138    	; 0xc4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	fe c3       	rjmp	.+2044   	; 0x846 <__vector_18>
      4a:	00 00       	nop
      4c:	3b c4       	rjmp	.+2166   	; 0x8c4 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2210>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2345>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e8 e6       	ldi	r30, 0x68	; 104
      9e:	fa e2       	ldi	r31, 0x2A	; 42
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	aa 35       	cpi	r26, 0x5A	; 90
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	24 e0       	ldi	r18, 0x04	; 4
      ae:	aa e5       	ldi	r26, 0x5A	; 90
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	a2 38       	cpi	r26, 0x82	; 130
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <main>
      c0:	0c 94 32 15 	jmp	0x2a64	; 0x2a64 <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	3c d3       	rcall	.+1656   	; 0x740 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	84 e1       	ldi	r24, 0x14	; 20
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	3a d3       	rcall	.+1652   	; 0x742 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	c7 d2       	rcall	.+1422   	; 0x65e <sdInit>
      d0:	33 d3       	rcall	.+1638   	; 0x738 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	9b c3       	rjmp	.+1846   	; 0x80c <st_lld_init>

000000d6 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t) TCNT1;
      d6:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
      da:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
      de:	08 95       	ret

000000e0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      e0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      e4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

  /* Reset pending. */
  TIFR_REG = _BV(OCF1A);
      e8:	82 e0       	ldi	r24, 0x02	; 2
      ea:	86 bb       	out	0x16, r24	; 22

  /* Enable interrupt. */
  TIMSK_REG = _BV(OCIE1A);
      ec:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
      f0:	08 95       	ret

000000f2 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  TIMSK_REG = 0;
      f2:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
      f6:	08 95       	ret

000000f8 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      f8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      fc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
     100:	08 95       	ret

00000102 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
     102:	af 92       	push	r10
     104:	bf 92       	push	r11
     106:	cf 92       	push	r12
     108:	df 92       	push	r13
     10a:	ef 92       	push	r14
     10c:	ff 92       	push	r15
     10e:	0f 93       	push	r16
     110:	1f 93       	push	r17
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	ec 01       	movw	r28, r24
     118:	6b 01       	movw	r12, r22
     11a:	8a 01       	movw	r16, r20
     11c:	8c 81       	ldd	r24, Y+4	; 0x04
     11e:	9d 81       	ldd	r25, Y+5	; 0x05
     120:	84 17       	cp	r24, r20
     122:	95 07       	cpc	r25, r21
     124:	10 f4       	brcc	.+4      	; 0x12a <iq_read+0x28>
     126:	0c 81       	ldd	r16, Y+4	; 0x04
     128:	1d 81       	ldd	r17, Y+5	; 0x05
     12a:	6c 85       	ldd	r22, Y+12	; 0x0c
     12c:	7d 85       	ldd	r23, Y+13	; 0x0d
     12e:	e8 84       	ldd	r14, Y+8	; 0x08
     130:	f9 84       	ldd	r15, Y+9	; 0x09
     132:	e6 1a       	sub	r14, r22
     134:	f7 0a       	sbc	r15, r23
     136:	0e 15       	cp	r16, r14
     138:	1f 05       	cpc	r17, r15
     13a:	98 f1       	brcs	.+102    	; 0x1a2 <iq_read+0xa0>
     13c:	e0 16       	cp	r14, r16
     13e:	f1 06       	cpc	r15, r17
     140:	d0 f0       	brcs	.+52     	; 0x176 <iq_read+0x74>
     142:	a8 01       	movw	r20, r16
     144:	c6 01       	movw	r24, r12
     146:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     14a:	8e 81       	ldd	r24, Y+6	; 0x06
     14c:	9f 81       	ldd	r25, Y+7	; 0x07
     14e:	9d 87       	std	Y+13, r25	; 0x0d
     150:	8c 87       	std	Y+12, r24	; 0x0c
     152:	8c 81       	ldd	r24, Y+4	; 0x04
     154:	9d 81       	ldd	r25, Y+5	; 0x05
     156:	80 1b       	sub	r24, r16
     158:	91 0b       	sbc	r25, r17
     15a:	9d 83       	std	Y+5, r25	; 0x05
     15c:	8c 83       	std	Y+4, r24	; 0x04
     15e:	c8 01       	movw	r24, r16
     160:	df 91       	pop	r29
     162:	cf 91       	pop	r28
     164:	1f 91       	pop	r17
     166:	0f 91       	pop	r16
     168:	ff 90       	pop	r15
     16a:	ef 90       	pop	r14
     16c:	df 90       	pop	r13
     16e:	cf 90       	pop	r12
     170:	bf 90       	pop	r11
     172:	af 90       	pop	r10
     174:	08 95       	ret
     176:	a7 01       	movw	r20, r14
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     17e:	58 01       	movw	r10, r16
     180:	ae 18       	sub	r10, r14
     182:	bf 08       	sbc	r11, r15
     184:	6e 81       	ldd	r22, Y+6	; 0x06
     186:	7f 81       	ldd	r23, Y+7	; 0x07
     188:	a5 01       	movw	r20, r10
     18a:	c6 01       	movw	r24, r12
     18c:	8e 0d       	add	r24, r14
     18e:	9f 1d       	adc	r25, r15
     190:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     194:	4e 81       	ldd	r20, Y+6	; 0x06
     196:	5f 81       	ldd	r21, Y+7	; 0x07
     198:	4a 0d       	add	r20, r10
     19a:	5b 1d       	adc	r21, r11
     19c:	5d 87       	std	Y+13, r21	; 0x0d
     19e:	4c 87       	std	Y+12, r20	; 0x0c
     1a0:	d8 cf       	rjmp	.-80     	; 0x152 <iq_read+0x50>
     1a2:	a8 01       	movw	r20, r16
     1a4:	c6 01       	movw	r24, r12
     1a6:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     1aa:	8c 85       	ldd	r24, Y+12	; 0x0c
     1ac:	9d 85       	ldd	r25, Y+13	; 0x0d
     1ae:	80 0f       	add	r24, r16
     1b0:	91 1f       	adc	r25, r17
     1b2:	9d 87       	std	Y+13, r25	; 0x0d
     1b4:	8c 87       	std	Y+12, r24	; 0x0c
     1b6:	cd cf       	rjmp	.-102    	; 0x152 <iq_read+0x50>

000001b8 <oq_write>:
     1b8:	af 92       	push	r10
     1ba:	bf 92       	push	r11
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
     1ce:	6b 01       	movw	r12, r22
     1d0:	8a 01       	movw	r16, r20
     1d2:	8c 81       	ldd	r24, Y+4	; 0x04
     1d4:	9d 81       	ldd	r25, Y+5	; 0x05
     1d6:	84 17       	cp	r24, r20
     1d8:	95 07       	cpc	r25, r21
     1da:	10 f4       	brcc	.+4      	; 0x1e0 <oq_write+0x28>
     1dc:	0c 81       	ldd	r16, Y+4	; 0x04
     1de:	1d 81       	ldd	r17, Y+5	; 0x05
     1e0:	8a 85       	ldd	r24, Y+10	; 0x0a
     1e2:	9b 85       	ldd	r25, Y+11	; 0x0b
     1e4:	e8 84       	ldd	r14, Y+8	; 0x08
     1e6:	f9 84       	ldd	r15, Y+9	; 0x09
     1e8:	e8 1a       	sub	r14, r24
     1ea:	f9 0a       	sbc	r15, r25
     1ec:	0e 15       	cp	r16, r14
     1ee:	1f 05       	cpc	r17, r15
     1f0:	98 f1       	brcs	.+102    	; 0x258 <oq_write+0xa0>
     1f2:	e0 16       	cp	r14, r16
     1f4:	f1 06       	cpc	r15, r17
     1f6:	d0 f0       	brcs	.+52     	; 0x22c <oq_write+0x74>
     1f8:	a8 01       	movw	r20, r16
     1fa:	b6 01       	movw	r22, r12
     1fc:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     200:	8e 81       	ldd	r24, Y+6	; 0x06
     202:	9f 81       	ldd	r25, Y+7	; 0x07
     204:	9b 87       	std	Y+11, r25	; 0x0b
     206:	8a 87       	std	Y+10, r24	; 0x0a
     208:	8c 81       	ldd	r24, Y+4	; 0x04
     20a:	9d 81       	ldd	r25, Y+5	; 0x05
     20c:	80 1b       	sub	r24, r16
     20e:	91 0b       	sbc	r25, r17
     210:	9d 83       	std	Y+5, r25	; 0x05
     212:	8c 83       	std	Y+4, r24	; 0x04
     214:	c8 01       	movw	r24, r16
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	ff 90       	pop	r15
     220:	ef 90       	pop	r14
     222:	df 90       	pop	r13
     224:	cf 90       	pop	r12
     226:	bf 90       	pop	r11
     228:	af 90       	pop	r10
     22a:	08 95       	ret
     22c:	a7 01       	movw	r20, r14
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     234:	58 01       	movw	r10, r16
     236:	ae 18       	sub	r10, r14
     238:	bf 08       	sbc	r11, r15
     23a:	b6 01       	movw	r22, r12
     23c:	6e 0d       	add	r22, r14
     23e:	7f 1d       	adc	r23, r15
     240:	a5 01       	movw	r20, r10
     242:	8e 81       	ldd	r24, Y+6	; 0x06
     244:	9f 81       	ldd	r25, Y+7	; 0x07
     246:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     24a:	4e 81       	ldd	r20, Y+6	; 0x06
     24c:	5f 81       	ldd	r21, Y+7	; 0x07
     24e:	4a 0d       	add	r20, r10
     250:	5b 1d       	adc	r21, r11
     252:	5b 87       	std	Y+11, r21	; 0x0b
     254:	4a 87       	std	Y+10, r20	; 0x0a
     256:	d8 cf       	rjmp	.-80     	; 0x208 <oq_write+0x50>
     258:	a8 01       	movw	r20, r16
     25a:	b6 01       	movw	r22, r12
     25c:	0e 94 44 14 	call	0x2888	; 0x2888 <memcpy>
     260:	8a 85       	ldd	r24, Y+10	; 0x0a
     262:	9b 85       	ldd	r25, Y+11	; 0x0b
     264:	80 0f       	add	r24, r16
     266:	91 1f       	adc	r25, r17
     268:	9b 87       	std	Y+11, r25	; 0x0b
     26a:	8a 87       	std	Y+10, r24	; 0x0a
     26c:	cd cf       	rjmp	.-102    	; 0x208 <oq_write+0x50>

0000026e <iqObjectInit>:
     26e:	0f 93       	push	r16
     270:	1f 93       	push	r17
     272:	fc 01       	movw	r30, r24
     274:	91 83       	std	Z+1, r25	; 0x01
     276:	80 83       	st	Z, r24
     278:	93 83       	std	Z+3, r25	; 0x03
     27a:	82 83       	std	Z+2, r24	; 0x02
     27c:	15 82       	std	Z+5, r1	; 0x05
     27e:	14 82       	std	Z+4, r1	; 0x04
     280:	77 83       	std	Z+7, r23	; 0x07
     282:	66 83       	std	Z+6, r22	; 0x06
     284:	75 87       	std	Z+13, r23	; 0x0d
     286:	64 87       	std	Z+12, r22	; 0x0c
     288:	73 87       	std	Z+11, r23	; 0x0b
     28a:	62 87       	std	Z+10, r22	; 0x0a
     28c:	64 0f       	add	r22, r20
     28e:	75 1f       	adc	r23, r21
     290:	71 87       	std	Z+9, r23	; 0x09
     292:	60 87       	std	Z+8, r22	; 0x08
     294:	37 87       	std	Z+15, r19	; 0x0f
     296:	26 87       	std	Z+14, r18	; 0x0e
     298:	11 8b       	std	Z+17, r17	; 0x11
     29a:	00 8b       	std	Z+16, r16	; 0x10
     29c:	1f 91       	pop	r17
     29e:	0f 91       	pop	r16
     2a0:	08 95       	ret

000002a2 <iqPutI>:
     2a2:	fc 01       	movw	r30, r24
     2a4:	a2 85       	ldd	r26, Z+10	; 0x0a
     2a6:	b3 85       	ldd	r27, Z+11	; 0x0b
     2a8:	84 85       	ldd	r24, Z+12	; 0x0c
     2aa:	95 85       	ldd	r25, Z+13	; 0x0d
     2ac:	a8 17       	cp	r26, r24
     2ae:	b9 07       	cpc	r27, r25
     2b0:	e9 f0       	breq	.+58     	; 0x2ec <iqPutI+0x4a>
     2b2:	84 81       	ldd	r24, Z+4	; 0x04
     2b4:	95 81       	ldd	r25, Z+5	; 0x05
     2b6:	01 96       	adiw	r24, 0x01	; 1
     2b8:	95 83       	std	Z+5, r25	; 0x05
     2ba:	84 83       	std	Z+4, r24	; 0x04
     2bc:	cd 01       	movw	r24, r26
     2be:	01 96       	adiw	r24, 0x01	; 1
     2c0:	93 87       	std	Z+11, r25	; 0x0b
     2c2:	82 87       	std	Z+10, r24	; 0x0a
     2c4:	6c 93       	st	X, r22
     2c6:	22 85       	ldd	r18, Z+10	; 0x0a
     2c8:	33 85       	ldd	r19, Z+11	; 0x0b
     2ca:	80 85       	ldd	r24, Z+8	; 0x08
     2cc:	91 85       	ldd	r25, Z+9	; 0x09
     2ce:	28 17       	cp	r18, r24
     2d0:	39 07       	cpc	r19, r25
     2d2:	20 f0       	brcs	.+8      	; 0x2dc <iqPutI+0x3a>
     2d4:	86 81       	ldd	r24, Z+6	; 0x06
     2d6:	97 81       	ldd	r25, Z+7	; 0x07
     2d8:	93 87       	std	Z+11, r25	; 0x0b
     2da:	82 87       	std	Z+10, r24	; 0x0a
     2dc:	cf 01       	movw	r24, r30
     2de:	70 e0       	ldi	r23, 0x00	; 0
     2e0:	60 e0       	ldi	r22, 0x00	; 0
     2e2:	0e 94 2f 0b 	call	0x165e	; 0x165e <chThdDequeueNextI>
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	80 e0       	ldi	r24, 0x00	; 0
     2ea:	08 95       	ret
     2ec:	84 81       	ldd	r24, Z+4	; 0x04
     2ee:	95 81       	ldd	r25, Z+5	; 0x05
     2f0:	89 2b       	or	r24, r25
     2f2:	f9 f2       	breq	.-66     	; 0x2b2 <iqPutI+0x10>
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	9f ef       	ldi	r25, 0xFF	; 255
     2f8:	08 95       	ret

000002fa <iqGetTimeout>:
     2fa:	cf 92       	push	r12
     2fc:	df 92       	push	r13
     2fe:	ef 92       	push	r14
     300:	ff 92       	push	r15
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	ec 01       	movw	r28, r24
     30a:	6a 01       	movw	r12, r20
     30c:	7b 01       	movw	r14, r22
     30e:	f8 94       	cli
     310:	07 c0       	rjmp	.+14     	; 0x320 <iqGetTimeout+0x26>
     312:	b7 01       	movw	r22, r14
     314:	a6 01       	movw	r20, r12
     316:	ce 01       	movw	r24, r28
     318:	0e 94 10 0b 	call	0x1620	; 0x1620 <chThdEnqueueTimeoutS>
     31c:	97 fd       	sbrc	r25, 7
     31e:	2a c0       	rjmp	.+84     	; 0x374 <iqGetTimeout+0x7a>
     320:	8c 81       	ldd	r24, Y+4	; 0x04
     322:	9d 81       	ldd	r25, Y+5	; 0x05
     324:	89 2b       	or	r24, r25
     326:	a9 f3       	breq	.-22     	; 0x312 <iqGetTimeout+0x18>
     328:	8c 81       	ldd	r24, Y+4	; 0x04
     32a:	9d 81       	ldd	r25, Y+5	; 0x05
     32c:	01 97       	sbiw	r24, 0x01	; 1
     32e:	9d 83       	std	Y+5, r25	; 0x05
     330:	8c 83       	std	Y+4, r24	; 0x04
     332:	ec 85       	ldd	r30, Y+12	; 0x0c
     334:	fd 85       	ldd	r31, Y+13	; 0x0d
     336:	cf 01       	movw	r24, r30
     338:	01 96       	adiw	r24, 0x01	; 1
     33a:	9d 87       	std	Y+13, r25	; 0x0d
     33c:	8c 87       	std	Y+12, r24	; 0x0c
     33e:	10 81       	ld	r17, Z
     340:	28 85       	ldd	r18, Y+8	; 0x08
     342:	39 85       	ldd	r19, Y+9	; 0x09
     344:	82 17       	cp	r24, r18
     346:	93 07       	cpc	r25, r19
     348:	20 f0       	brcs	.+8      	; 0x352 <iqGetTimeout+0x58>
     34a:	8e 81       	ldd	r24, Y+6	; 0x06
     34c:	9f 81       	ldd	r25, Y+7	; 0x07
     34e:	9d 87       	std	Y+13, r25	; 0x0d
     350:	8c 87       	std	Y+12, r24	; 0x0c
     352:	ee 85       	ldd	r30, Y+14	; 0x0e
     354:	ff 85       	ldd	r31, Y+15	; 0x0f
     356:	30 97       	sbiw	r30, 0x00	; 0
     358:	11 f0       	breq	.+4      	; 0x35e <iqGetTimeout+0x64>
     35a:	ce 01       	movw	r24, r28
     35c:	09 95       	icall
     35e:	78 94       	sei
     360:	81 2f       	mov	r24, r17
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	df 91       	pop	r29
     366:	cf 91       	pop	r28
     368:	1f 91       	pop	r17
     36a:	ff 90       	pop	r15
     36c:	ef 90       	pop	r14
     36e:	df 90       	pop	r13
     370:	cf 90       	pop	r12
     372:	08 95       	ret
     374:	78 94       	sei
     376:	df 91       	pop	r29
     378:	cf 91       	pop	r28
     37a:	1f 91       	pop	r17
     37c:	ff 90       	pop	r15
     37e:	ef 90       	pop	r14
     380:	df 90       	pop	r13
     382:	cf 90       	pop	r12
     384:	08 95       	ret

00000386 <iqReadTimeout>:
     386:	4f 92       	push	r4
     388:	5f 92       	push	r5
     38a:	6f 92       	push	r6
     38c:	7f 92       	push	r7
     38e:	8f 92       	push	r8
     390:	9f 92       	push	r9
     392:	af 92       	push	r10
     394:	bf 92       	push	r11
     396:	cf 92       	push	r12
     398:	df 92       	push	r13
     39a:	ef 92       	push	r14
     39c:	ff 92       	push	r15
     39e:	0f 93       	push	r16
     3a0:	1f 93       	push	r17
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	6c 01       	movw	r12, r24
     3a8:	7b 01       	movw	r14, r22
     3aa:	4a 01       	movw	r8, r20
     3ac:	28 01       	movw	r4, r16
     3ae:	39 01       	movw	r6, r18
     3b0:	fc 01       	movw	r30, r24
     3b2:	a6 84       	ldd	r10, Z+14	; 0x0e
     3b4:	b7 84       	ldd	r11, Z+15	; 0x0f
     3b6:	f8 94       	cli
     3b8:	41 15       	cp	r20, r1
     3ba:	51 05       	cpc	r21, r1
     3bc:	b9 f0       	breq	.+46     	; 0x3ec <iqReadTimeout+0x66>
     3be:	8a 01       	movw	r16, r20
     3c0:	a8 01       	movw	r20, r16
     3c2:	b7 01       	movw	r22, r14
     3c4:	c6 01       	movw	r24, r12
     3c6:	9d de       	rcall	.-710    	; 0x102 <iq_read>
     3c8:	ec 01       	movw	r28, r24
     3ca:	89 2b       	or	r24, r25
     3cc:	11 f1       	breq	.+68     	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
     3ce:	a1 14       	cp	r10, r1
     3d0:	b1 04       	cpc	r11, r1
     3d2:	19 f0       	breq	.+6      	; 0x3da <iqReadTimeout+0x54>
     3d4:	c6 01       	movw	r24, r12
     3d6:	f5 01       	movw	r30, r10
     3d8:	09 95       	icall
     3da:	78 94       	sei
     3dc:	0c 1b       	sub	r16, r28
     3de:	1d 0b       	sbc	r17, r29
     3e0:	ec 0e       	add	r14, r28
     3e2:	fd 1e       	adc	r15, r29
     3e4:	f8 94       	cli
     3e6:	01 15       	cp	r16, r1
     3e8:	11 05       	cpc	r17, r1
     3ea:	51 f7       	brne	.-44     	; 0x3c0 <iqReadTimeout+0x3a>
     3ec:	c4 01       	movw	r24, r8
     3ee:	78 94       	sei
     3f0:	df 91       	pop	r29
     3f2:	cf 91       	pop	r28
     3f4:	1f 91       	pop	r17
     3f6:	0f 91       	pop	r16
     3f8:	ff 90       	pop	r15
     3fa:	ef 90       	pop	r14
     3fc:	df 90       	pop	r13
     3fe:	cf 90       	pop	r12
     400:	bf 90       	pop	r11
     402:	af 90       	pop	r10
     404:	9f 90       	pop	r9
     406:	8f 90       	pop	r8
     408:	7f 90       	pop	r7
     40a:	6f 90       	pop	r6
     40c:	5f 90       	pop	r5
     40e:	4f 90       	pop	r4
     410:	08 95       	ret
     412:	b3 01       	movw	r22, r6
     414:	a2 01       	movw	r20, r4
     416:	c6 01       	movw	r24, r12
     418:	0e 94 10 0b 	call	0x1620	; 0x1620 <chThdEnqueueTimeoutS>
     41c:	89 2b       	or	r24, r25
     41e:	81 f2       	breq	.-96     	; 0x3c0 <iqReadTimeout+0x3a>
     420:	c4 01       	movw	r24, r8
     422:	80 1b       	sub	r24, r16
     424:	91 0b       	sbc	r25, r17
     426:	e3 cf       	rjmp	.-58     	; 0x3ee <iqReadTimeout+0x68>

00000428 <oqObjectInit>:
     428:	0f 93       	push	r16
     42a:	1f 93       	push	r17
     42c:	fc 01       	movw	r30, r24
     42e:	91 83       	std	Z+1, r25	; 0x01
     430:	80 83       	st	Z, r24
     432:	93 83       	std	Z+3, r25	; 0x03
     434:	82 83       	std	Z+2, r24	; 0x02
     436:	55 83       	std	Z+5, r21	; 0x05
     438:	44 83       	std	Z+4, r20	; 0x04
     43a:	77 83       	std	Z+7, r23	; 0x07
     43c:	66 83       	std	Z+6, r22	; 0x06
     43e:	75 87       	std	Z+13, r23	; 0x0d
     440:	64 87       	std	Z+12, r22	; 0x0c
     442:	73 87       	std	Z+11, r23	; 0x0b
     444:	62 87       	std	Z+10, r22	; 0x0a
     446:	64 0f       	add	r22, r20
     448:	75 1f       	adc	r23, r21
     44a:	71 87       	std	Z+9, r23	; 0x09
     44c:	60 87       	std	Z+8, r22	; 0x08
     44e:	37 87       	std	Z+15, r19	; 0x0f
     450:	26 87       	std	Z+14, r18	; 0x0e
     452:	11 8b       	std	Z+17, r17	; 0x11
     454:	00 8b       	std	Z+16, r16	; 0x10
     456:	1f 91       	pop	r17
     458:	0f 91       	pop	r16
     45a:	08 95       	ret

0000045c <oqPutTimeout>:
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	ef 92       	push	r14
     462:	ff 92       	push	r15
     464:	1f 93       	push	r17
     466:	cf 93       	push	r28
     468:	df 93       	push	r29
     46a:	ec 01       	movw	r28, r24
     46c:	16 2f       	mov	r17, r22
     46e:	69 01       	movw	r12, r18
     470:	7a 01       	movw	r14, r20
     472:	f8 94       	cli
     474:	07 c0       	rjmp	.+14     	; 0x484 <oqPutTimeout+0x28>
     476:	b7 01       	movw	r22, r14
     478:	a6 01       	movw	r20, r12
     47a:	ce 01       	movw	r24, r28
     47c:	0e 94 10 0b 	call	0x1620	; 0x1620 <chThdEnqueueTimeoutS>
     480:	97 fd       	sbrc	r25, 7
     482:	2c c0       	rjmp	.+88     	; 0x4dc <oqPutTimeout+0x80>
     484:	8c 81       	ldd	r24, Y+4	; 0x04
     486:	9d 81       	ldd	r25, Y+5	; 0x05
     488:	89 2b       	or	r24, r25
     48a:	a9 f3       	breq	.-22     	; 0x476 <oqPutTimeout+0x1a>
     48c:	8c 81       	ldd	r24, Y+4	; 0x04
     48e:	9d 81       	ldd	r25, Y+5	; 0x05
     490:	01 97       	sbiw	r24, 0x01	; 1
     492:	9d 83       	std	Y+5, r25	; 0x05
     494:	8c 83       	std	Y+4, r24	; 0x04
     496:	ea 85       	ldd	r30, Y+10	; 0x0a
     498:	fb 85       	ldd	r31, Y+11	; 0x0b
     49a:	cf 01       	movw	r24, r30
     49c:	01 96       	adiw	r24, 0x01	; 1
     49e:	9b 87       	std	Y+11, r25	; 0x0b
     4a0:	8a 87       	std	Y+10, r24	; 0x0a
     4a2:	10 83       	st	Z, r17
     4a4:	2a 85       	ldd	r18, Y+10	; 0x0a
     4a6:	3b 85       	ldd	r19, Y+11	; 0x0b
     4a8:	88 85       	ldd	r24, Y+8	; 0x08
     4aa:	99 85       	ldd	r25, Y+9	; 0x09
     4ac:	28 17       	cp	r18, r24
     4ae:	39 07       	cpc	r19, r25
     4b0:	20 f0       	brcs	.+8      	; 0x4ba <oqPutTimeout+0x5e>
     4b2:	8e 81       	ldd	r24, Y+6	; 0x06
     4b4:	9f 81       	ldd	r25, Y+7	; 0x07
     4b6:	9b 87       	std	Y+11, r25	; 0x0b
     4b8:	8a 87       	std	Y+10, r24	; 0x0a
     4ba:	ee 85       	ldd	r30, Y+14	; 0x0e
     4bc:	ff 85       	ldd	r31, Y+15	; 0x0f
     4be:	30 97       	sbiw	r30, 0x00	; 0
     4c0:	11 f0       	breq	.+4      	; 0x4c6 <oqPutTimeout+0x6a>
     4c2:	ce 01       	movw	r24, r28
     4c4:	09 95       	icall
     4c6:	78 94       	sei
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	80 e0       	ldi	r24, 0x00	; 0
     4cc:	df 91       	pop	r29
     4ce:	cf 91       	pop	r28
     4d0:	1f 91       	pop	r17
     4d2:	ff 90       	pop	r15
     4d4:	ef 90       	pop	r14
     4d6:	df 90       	pop	r13
     4d8:	cf 90       	pop	r12
     4da:	08 95       	ret
     4dc:	78 94       	sei
     4de:	df 91       	pop	r29
     4e0:	cf 91       	pop	r28
     4e2:	1f 91       	pop	r17
     4e4:	ff 90       	pop	r15
     4e6:	ef 90       	pop	r14
     4e8:	df 90       	pop	r13
     4ea:	cf 90       	pop	r12
     4ec:	08 95       	ret

000004ee <oqGetI>:
     4ee:	cf 93       	push	r28
     4f0:	fc 01       	movw	r30, r24
     4f2:	a4 85       	ldd	r26, Z+12	; 0x0c
     4f4:	b5 85       	ldd	r27, Z+13	; 0x0d
     4f6:	82 85       	ldd	r24, Z+10	; 0x0a
     4f8:	93 85       	ldd	r25, Z+11	; 0x0b
     4fa:	8a 17       	cp	r24, r26
     4fc:	9b 07       	cpc	r25, r27
     4fe:	e9 f0       	breq	.+58     	; 0x53a <oqGetI+0x4c>
     500:	84 81       	ldd	r24, Z+4	; 0x04
     502:	95 81       	ldd	r25, Z+5	; 0x05
     504:	01 96       	adiw	r24, 0x01	; 1
     506:	95 83       	std	Z+5, r25	; 0x05
     508:	84 83       	std	Z+4, r24	; 0x04
     50a:	cd 01       	movw	r24, r26
     50c:	01 96       	adiw	r24, 0x01	; 1
     50e:	95 87       	std	Z+13, r25	; 0x0d
     510:	84 87       	std	Z+12, r24	; 0x0c
     512:	cc 91       	ld	r28, X
     514:	20 85       	ldd	r18, Z+8	; 0x08
     516:	31 85       	ldd	r19, Z+9	; 0x09
     518:	82 17       	cp	r24, r18
     51a:	93 07       	cpc	r25, r19
     51c:	48 f4       	brcc	.+18     	; 0x530 <oqGetI+0x42>
     51e:	cf 01       	movw	r24, r30
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	60 e0       	ldi	r22, 0x00	; 0
     524:	0e 94 2f 0b 	call	0x165e	; 0x165e <chThdDequeueNextI>
     528:	8c 2f       	mov	r24, r28
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	cf 91       	pop	r28
     52e:	08 95       	ret
     530:	86 81       	ldd	r24, Z+6	; 0x06
     532:	97 81       	ldd	r25, Z+7	; 0x07
     534:	95 87       	std	Z+13, r25	; 0x0d
     536:	84 87       	std	Z+12, r24	; 0x0c
     538:	f2 cf       	rjmp	.-28     	; 0x51e <oqGetI+0x30>
     53a:	84 81       	ldd	r24, Z+4	; 0x04
     53c:	95 81       	ldd	r25, Z+5	; 0x05
     53e:	89 2b       	or	r24, r25
     540:	f9 f2       	breq	.-66     	; 0x500 <oqGetI+0x12>
     542:	8f ef       	ldi	r24, 0xFF	; 255
     544:	9f ef       	ldi	r25, 0xFF	; 255
     546:	cf 91       	pop	r28
     548:	08 95       	ret

0000054a <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     54a:	4f 92       	push	r4
     54c:	5f 92       	push	r5
     54e:	6f 92       	push	r6
     550:	7f 92       	push	r7
     552:	8f 92       	push	r8
     554:	9f 92       	push	r9
     556:	af 92       	push	r10
     558:	bf 92       	push	r11
     55a:	cf 92       	push	r12
     55c:	df 92       	push	r13
     55e:	ef 92       	push	r14
     560:	ff 92       	push	r15
     562:	0f 93       	push	r16
     564:	1f 93       	push	r17
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	6c 01       	movw	r12, r24
     56c:	7b 01       	movw	r14, r22
     56e:	4a 01       	movw	r8, r20
     570:	28 01       	movw	r4, r16
     572:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     574:	fc 01       	movw	r30, r24
     576:	a6 84       	ldd	r10, Z+14	; 0x0e
     578:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     57a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     57c:	41 15       	cp	r20, r1
     57e:	51 05       	cpc	r21, r1
     580:	b9 f0       	breq	.+46     	; 0x5b0 <oqWriteTimeout+0x66>
     582:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     584:	a8 01       	movw	r20, r16
     586:	b7 01       	movw	r22, r14
     588:	c6 01       	movw	r24, r12
     58a:	16 de       	rcall	.-980    	; 0x1b8 <oq_write>
     58c:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     58e:	89 2b       	or	r24, r25
     590:	11 f1       	breq	.+68     	; 0x5d6 <oqWriteTimeout+0x8c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     592:	a1 14       	cp	r10, r1
     594:	b1 04       	cpc	r11, r1
     596:	19 f0       	breq	.+6      	; 0x59e <oqWriteTimeout+0x54>
        nfy(oqp);
     598:	c6 01       	movw	r24, r12
     59a:	f5 01       	movw	r30, r10
     59c:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     59e:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     5a0:	0c 1b       	sub	r16, r28
     5a2:	1d 0b       	sbc	r17, r29
      bp += done;
     5a4:	ec 0e       	add	r14, r28
     5a6:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     5a8:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     5aa:	01 15       	cp	r16, r1
     5ac:	11 05       	cpc	r17, r1
     5ae:	51 f7       	brne	.-44     	; 0x584 <oqWriteTimeout+0x3a>
     5b0:	c4 01       	movw	r24, r8
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     5b2:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
     5b8:	1f 91       	pop	r17
     5ba:	0f 91       	pop	r16
     5bc:	ff 90       	pop	r15
     5be:	ef 90       	pop	r14
     5c0:	df 90       	pop	r13
     5c2:	cf 90       	pop	r12
     5c4:	bf 90       	pop	r11
     5c6:	af 90       	pop	r10
     5c8:	9f 90       	pop	r9
     5ca:	8f 90       	pop	r8
     5cc:	7f 90       	pop	r7
     5ce:	6f 90       	pop	r6
     5d0:	5f 90       	pop	r5
     5d2:	4f 90       	pop	r4
     5d4:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     5d6:	b3 01       	movw	r22, r6
     5d8:	a2 01       	movw	r20, r4
     5da:	c6 01       	movw	r24, r12
     5dc:	0e 94 10 0b 	call	0x1620	; 0x1620 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     5e0:	89 2b       	or	r24, r25
     5e2:	81 f2       	breq	.-96     	; 0x584 <oqWriteTimeout+0x3a>
     5e4:	c4 01       	movw	r24, r8
     5e6:	80 1b       	sub	r24, r16
     5e8:	91 0b       	sbc	r25, r17
     5ea:	e3 cf       	rjmp	.-58     	; 0x5b2 <oqWriteTimeout+0x68>

000005ec <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     5ec:	0f 93       	push	r16
     5ee:	1f 93       	push	r17
     5f0:	05 96       	adiw	r24, 0x05	; 5
     5f2:	c9 de       	rcall	.-622    	; 0x386 <iqReadTimeout>
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	08 95       	ret

000005fa <_read>:
     5fa:	0f 93       	push	r16
     5fc:	1f 93       	push	r17
     5fe:	0f ef       	ldi	r16, 0xFF	; 255
     600:	1f ef       	ldi	r17, 0xFF	; 255
     602:	98 01       	movw	r18, r16
     604:	05 96       	adiw	r24, 0x05	; 5
     606:	bf de       	rcall	.-642    	; 0x386 <iqReadTimeout>
     608:	1f 91       	pop	r17
     60a:	0f 91       	pop	r16
     60c:	08 95       	ret

0000060e <_writet>:
     60e:	0f 93       	push	r16
     610:	1f 93       	push	r17
     612:	47 96       	adiw	r24, 0x17	; 23
     614:	9a df       	rcall	.-204    	; 0x54a <oqWriteTimeout>
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	08 95       	ret

0000061c <_write>:
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	0f ef       	ldi	r16, 0xFF	; 255
     622:	1f ef       	ldi	r17, 0xFF	; 255
     624:	98 01       	movw	r18, r16
     626:	47 96       	adiw	r24, 0x17	; 23
     628:	90 df       	rcall	.-224    	; 0x54a <oqWriteTimeout>
     62a:	1f 91       	pop	r17
     62c:	0f 91       	pop	r16
     62e:	08 95       	ret

00000630 <_gett>:
     630:	05 96       	adiw	r24, 0x05	; 5
     632:	63 ce       	rjmp	.-826    	; 0x2fa <iqGetTimeout>

00000634 <_get>:
     634:	4f ef       	ldi	r20, 0xFF	; 255
     636:	5f ef       	ldi	r21, 0xFF	; 255
     638:	ba 01       	movw	r22, r20
     63a:	05 96       	adiw	r24, 0x05	; 5
     63c:	5e ce       	rjmp	.-836    	; 0x2fa <iqGetTimeout>

0000063e <_putt>:
     63e:	47 96       	adiw	r24, 0x17	; 23
     640:	0d cf       	rjmp	.-486    	; 0x45c <oqPutTimeout>

00000642 <_put>:
     642:	2f ef       	ldi	r18, 0xFF	; 255
     644:	3f ef       	ldi	r19, 0xFF	; 255
     646:	a9 01       	movw	r20, r18
     648:	47 96       	adiw	r24, 0x17	; 23
     64a:	08 cf       	rjmp	.-496    	; 0x45c <oqPutTimeout>

0000064c <_ctl>:
     64c:	61 30       	cpi	r22, 0x01	; 1
     64e:	71 05       	cpc	r23, r1
     650:	19 f0       	breq	.+6      	; 0x658 <_ctl+0xc>
     652:	8c ee       	ldi	r24, 0xEC	; 236
     654:	9f ef       	ldi	r25, 0xFF	; 255
     656:	08 95       	ret
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	80 e0       	ldi	r24, 0x00	; 0
     65c:	08 95       	ret

0000065e <sdInit>:
     65e:	69 c1       	rjmp	.+722    	; 0x932 <sd_lld_init>

00000660 <sdObjectInit>:
     660:	ef 92       	push	r14
     662:	ff 92       	push	r15
     664:	0f 93       	push	r16
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	ec 01       	movw	r28, r24
     66e:	9b 01       	movw	r18, r22
     670:	7a 01       	movw	r14, r20
     672:	fc 01       	movw	r30, r24
     674:	80 e0       	ldi	r24, 0x00	; 0
     676:	91 e0       	ldi	r25, 0x01	; 1
     678:	81 93       	st	Z+, r24
     67a:	91 93       	st	Z+, r25
     67c:	fb 83       	std	Y+3, r31	; 0x03
     67e:	ea 83       	std	Y+2, r30	; 0x02
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	8c 83       	std	Y+4, r24	; 0x04
     684:	be 01       	movw	r22, r28
     686:	67 5d       	subi	r22, 0xD7	; 215
     688:	7f 4f       	sbci	r23, 0xFF	; 255
     68a:	8e 01       	movw	r16, r28
     68c:	40 e1       	ldi	r20, 0x10	; 16
     68e:	50 e0       	ldi	r21, 0x00	; 0
     690:	ce 01       	movw	r24, r28
     692:	05 96       	adiw	r24, 0x05	; 5
     694:	ec dd       	rcall	.-1064   	; 0x26e <iqObjectInit>
     696:	be 01       	movw	r22, r28
     698:	67 5c       	subi	r22, 0xC7	; 199
     69a:	7f 4f       	sbci	r23, 0xFF	; 255
     69c:	97 01       	movw	r18, r14
     69e:	40 e1       	ldi	r20, 0x10	; 16
     6a0:	50 e0       	ldi	r21, 0x00	; 0
     6a2:	ce 01       	movw	r24, r28
     6a4:	47 96       	adiw	r24, 0x17	; 23
     6a6:	c0 de       	rcall	.-640    	; 0x428 <oqObjectInit>
     6a8:	df 91       	pop	r29
     6aa:	cf 91       	pop	r28
     6ac:	1f 91       	pop	r17
     6ae:	0f 91       	pop	r16
     6b0:	ff 90       	pop	r15
     6b2:	ef 90       	pop	r14
     6b4:	08 95       	ret

000006b6 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     6b6:	1f 93       	push	r17
     6b8:	cf 93       	push	r28
     6ba:	df 93       	push	r29
     6bc:	ec 01       	movw	r28, r24
     6be:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     6c0:	89 85       	ldd	r24, Y+9	; 0x09
     6c2:	9a 85       	ldd	r25, Y+10	; 0x0a
     6c4:	89 2b       	or	r24, r25
     6c6:	51 f0       	breq	.+20     	; 0x6dc <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     6c8:	61 2f       	mov	r22, r17
     6ca:	ce 01       	movw	r24, r28
     6cc:	05 96       	adiw	r24, 0x05	; 5
     6ce:	e9 dd       	rcall	.-1070   	; 0x2a2 <iqPutI>
     6d0:	97 fd       	sbrc	r25, 7
     6d2:	0f c0       	rjmp	.+30     	; 0x6f2 <sdIncomingDataI+0x3c>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	1f 91       	pop	r17
     6da:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     6dc:	64 e0       	ldi	r22, 0x04	; 4
     6de:	ce 01       	movw	r24, r28
     6e0:	02 96       	adiw	r24, 0x02	; 2
     6e2:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     6e6:	61 2f       	mov	r22, r17
     6e8:	ce 01       	movw	r24, r28
     6ea:	05 96       	adiw	r24, 0x05	; 5
     6ec:	da dd       	rcall	.-1100   	; 0x2a2 <iqPutI>
     6ee:	97 ff       	sbrs	r25, 7
     6f0:	f1 cf       	rjmp	.-30     	; 0x6d4 <sdIncomingDataI+0x1e>
     6f2:	60 e0       	ldi	r22, 0x00	; 0
     6f4:	ce 01       	movw	r24, r28
     6f6:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	1f 91       	pop	r17
     6fe:	0c 94 38 0d 	jmp	0x1a70	; 0x1a70 <chEvtBroadcastFlagsI>

00000702 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     702:	0f 93       	push	r16
     704:	1f 93       	push	r17
     706:	cf 93       	push	r28
     708:	df 93       	push	r29
     70a:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     70c:	47 96       	adiw	r24, 0x17	; 23
     70e:	ef de       	rcall	.-546    	; 0x4ee <oqGetI>
     710:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     712:	97 fd       	sbrc	r25, 7
     714:	06 c0       	rjmp	.+12     	; 0x722 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     716:	ce 01       	movw	r24, r28
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	1f 91       	pop	r17
     71e:	0f 91       	pop	r16
     720:	08 95       	ret
     722:	68 e0       	ldi	r22, 0x08	; 8
     724:	c8 01       	movw	r24, r16
     726:	02 96       	adiw	r24, 0x02	; 2
     728:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <chEvtBroadcastFlagsI>
     72c:	ce 01       	movw	r24, r28
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	1f 91       	pop	r17
     734:	0f 91       	pop	r16
     736:	08 95       	ret

00000738 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     738:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     73c:	1d ba       	out	0x1d, r1	; 29

}
     73e:	08 95       	ret

00000740 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
     740:	08 95       	ret

00000742 <_pal_lld_init>:
  (void)mode;
  (void)callback;
  (void)arg;

  /* TODO: Implement the interruption here. */
}
     742:	fc 01       	movw	r30, r24
     744:	80 81       	ld	r24, Z
     746:	85 b9       	out	0x05, r24	; 5
     748:	81 81       	ldd	r24, Z+1	; 0x01
     74a:	84 b9       	out	0x04, r24	; 4
     74c:	82 81       	ldd	r24, Z+2	; 0x02
     74e:	88 b9       	out	0x08, r24	; 8
     750:	83 81       	ldd	r24, Z+3	; 0x03
     752:	87 b9       	out	0x07, r24	; 7
     754:	84 81       	ldd	r24, Z+4	; 0x04
     756:	8b b9       	out	0x0b, r24	; 11
     758:	85 81       	ldd	r24, Z+5	; 0x05
     75a:	8a b9       	out	0x0a, r24	; 10
     75c:	08 95       	ret

0000075e <_pal_lld_setgroupmode>:
     75e:	fc 01       	movw	r30, r24
     760:	42 30       	cpi	r20, 0x02	; 2
     762:	c9 f0       	breq	.+50     	; 0x796 <_pal_lld_setgroupmode+0x38>
     764:	98 f0       	brcs	.+38     	; 0x78c <_pal_lld_setgroupmode+0x2e>
     766:	45 30       	cpi	r20, 0x05	; 5
     768:	b1 f0       	breq	.+44     	; 0x796 <_pal_lld_setgroupmode+0x38>
     76a:	46 30       	cpi	r20, 0x06	; 6
     76c:	21 f4       	brne	.+8      	; 0x776 <_pal_lld_setgroupmode+0x18>
     76e:	81 81       	ldd	r24, Z+1	; 0x01
     770:	68 2b       	or	r22, r24
     772:	61 83       	std	Z+1, r22	; 0x01
     774:	08 95       	ret
     776:	43 30       	cpi	r20, 0x03	; 3
     778:	e9 f7       	brne	.-6      	; 0x774 <_pal_lld_setgroupmode+0x16>
     77a:	91 81       	ldd	r25, Z+1	; 0x01
     77c:	86 2f       	mov	r24, r22
     77e:	80 95       	com	r24
     780:	89 23       	and	r24, r25
     782:	81 83       	std	Z+1, r24	; 0x01
     784:	82 81       	ldd	r24, Z+2	; 0x02
     786:	68 2b       	or	r22, r24
     788:	62 83       	std	Z+2, r22	; 0x02
     78a:	08 95       	ret
     78c:	44 23       	and	r20, r20
     78e:	19 f0       	breq	.+6      	; 0x796 <_pal_lld_setgroupmode+0x38>
     790:	41 30       	cpi	r20, 0x01	; 1
     792:	99 f3       	breq	.-26     	; 0x77a <_pal_lld_setgroupmode+0x1c>
     794:	08 95       	ret
     796:	81 81       	ldd	r24, Z+1	; 0x01
     798:	60 95       	com	r22
     79a:	86 23       	and	r24, r22
     79c:	81 83       	std	Z+1, r24	; 0x01
     79e:	82 81       	ldd	r24, Z+2	; 0x02
     7a0:	68 23       	and	r22, r24
     7a2:	62 83       	std	Z+2, r22	; 0x02
     7a4:	08 95       	ret

000007a6 <_pal_lld_setlineid>:
 *
 * @return    line  the builded line
 *
 * @notapi
 */
ioline_t _pal_lld_setlineid(ioportid_t port, uint8_t pad) {
     7a6:	28 2f       	mov	r18, r24
     7a8:	86 2f       	mov	r24, r22

  line.port = port;
  line.pad  = pad;

  return line;
}
     7aa:	62 2f       	mov	r22, r18
     7ac:	79 2f       	mov	r23, r25
     7ae:	08 95       	ret

000007b0 <_pal_lld_getportfromline>:
 *
 * @return    port  the port of the corresponding line
 *
 * @notapi
 */
ioportid_t _pal_lld_getportfromline(ioline_t line) {
     7b0:	cb 01       	movw	r24, r22

  return line.port;
}
     7b2:	08 95       	ret

000007b4 <_pal_lld_getpadfromline>:
 * @notapi
 */
uint8_t _pal_lld_getpadfromline(ioline_t line) {

  return line.pad;
}
     7b4:	08 95       	ret

000007b6 <__vector_11>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for free running mode.
 */
OSAL_IRQ_HANDLER(TIMER1_COMPA_vect) {
     7b6:	1f 92       	push	r1
     7b8:	0f 92       	push	r0
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	0f 92       	push	r0
     7be:	11 24       	eor	r1, r1
     7c0:	2f 93       	push	r18
     7c2:	3f 93       	push	r19
     7c4:	4f 93       	push	r20
     7c6:	5f 93       	push	r21
     7c8:	6f 93       	push	r22
     7ca:	7f 93       	push	r23
     7cc:	8f 93       	push	r24
     7ce:	9f 93       	push	r25
     7d0:	af 93       	push	r26
     7d2:	bf 93       	push	r27
     7d4:	ef 93       	push	r30
     7d6:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     7de:	c7 d0       	rcall	.+398    	; 0x96e <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     7e0:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <__avr_in_isr>
     7e4:	2c d5       	rcall	.+2648   	; 0x123e <chSchIsPreemptionRequired>
     7e6:	81 11       	cpse	r24, r1
     7e8:	3a d5       	rcall	.+2676   	; 0x125e <chSchDoPreemption>
}
     7ea:	ff 91       	pop	r31
     7ec:	ef 91       	pop	r30
     7ee:	bf 91       	pop	r27
     7f0:	af 91       	pop	r26
     7f2:	9f 91       	pop	r25
     7f4:	8f 91       	pop	r24
     7f6:	7f 91       	pop	r23
     7f8:	6f 91       	pop	r22
     7fa:	5f 91       	pop	r21
     7fc:	4f 91       	pop	r20
     7fe:	3f 91       	pop	r19
     800:	2f 91       	pop	r18
     802:	0f 90       	pop	r0
     804:	0f be       	out	0x3f, r0	; 63
     806:	0f 90       	pop	r0
     808:	1f 90       	pop	r1
     80a:	18 95       	reti

0000080c <st_lld_init>:
  /*
   * Periodic mode uses Timer 1 (16 bit).
   */

  /* CTC mode, no clock source. */
  TCCR1A     = 0;
     80c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
  TCCR1B     = _BV(WGM12);
     810:	e1 e8       	ldi	r30, 0x81	; 129
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	88 e0       	ldi	r24, 0x08	; 8
     816:	80 83       	st	Z, r24

  /* Start disabled. */
  TCCR1C     = 0;
     818:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x7f8082>
  OCR1A      = 0;
     81c:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     820:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
  TCNT1      = 0;
     824:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     828:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
  TIFR_REG   = _BV(OCF1A);                              /* Reset pending.   */
     82c:	82 e0       	ldi	r24, 0x02	; 2
     82e:	86 bb       	out	0x16, r24	; 22
  TIMSK_REG  = 0;
     830:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
  TCCR1B     = PRESCALER;
     834:	85 e0       	ldi	r24, 0x05	; 5
     836:	80 83       	st	Z, r24
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
     838:	08 95       	ret

0000083a <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     83a:	e1 ec       	ldi	r30, 0xC1	; 193
     83c:	f0 e0       	ldi	r31, 0x00	; 0
     83e:	80 81       	ld	r24, Z
     840:	80 62       	ori	r24, 0x20	; 32
     842:	80 83       	st	Z, r24
}
     844:	08 95       	ret

00000846 <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     846:	1f 92       	push	r1
     848:	0f 92       	push	r0
     84a:	0f b6       	in	r0, 0x3f	; 63
     84c:	0f 92       	push	r0
     84e:	11 24       	eor	r1, r1
     850:	2f 93       	push	r18
     852:	3f 93       	push	r19
     854:	4f 93       	push	r20
     856:	5f 93       	push	r21
     858:	6f 93       	push	r22
     85a:	7f 93       	push	r23
     85c:	8f 93       	push	r24
     85e:	9f 93       	push	r25
     860:	af 93       	push	r26
     862:	bf 93       	push	r27
     864:	ef 93       	push	r30
     866:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__avr_in_isr>

  sra = UCSR0A;
     86e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     872:	98 2f       	mov	r25, r24
     874:	9c 71       	andi	r25, 0x1C	; 28
     876:	49 f0       	breq	.+18     	; 0x88a <__vector_18+0x44>
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     878:	60 e2       	ldi	r22, 0x20	; 32
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     87a:	82 ff       	sbrs	r24, 2
     87c:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     87e:	84 fd       	sbrc	r24, 4
     880:	1f c0       	rjmp	.+62     	; 0x8c0 <__vector_18+0x7a>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     882:	8e ee       	ldi	r24, 0xEE	; 238
     884:	93 e0       	ldi	r25, 0x03	; 3
     886:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     88a:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     88e:	8c ee       	ldi	r24, 0xEC	; 236
     890:	93 e0       	ldi	r25, 0x03	; 3
     892:	11 df       	rcall	.-478    	; 0x6b6 <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     894:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <__avr_in_isr>
     898:	d2 d4       	rcall	.+2468   	; 0x123e <chSchIsPreemptionRequired>
     89a:	81 11       	cpse	r24, r1
     89c:	e0 d4       	rcall	.+2496   	; 0x125e <chSchDoPreemption>
}
     89e:	ff 91       	pop	r31
     8a0:	ef 91       	pop	r30
     8a2:	bf 91       	pop	r27
     8a4:	af 91       	pop	r26
     8a6:	9f 91       	pop	r25
     8a8:	8f 91       	pop	r24
     8aa:	7f 91       	pop	r23
     8ac:	6f 91       	pop	r22
     8ae:	5f 91       	pop	r21
     8b0:	4f 91       	pop	r20
     8b2:	3f 91       	pop	r19
     8b4:	2f 91       	pop	r18
     8b6:	0f 90       	pop	r0
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	0f 90       	pop	r0
     8bc:	1f 90       	pop	r1
     8be:	18 95       	reti
  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
    sts |= SD_FRAMING_ERROR;
     8c0:	60 64       	ori	r22, 0x40	; 64
     8c2:	df cf       	rjmp	.-66     	; 0x882 <__vector_18+0x3c>

000008c4 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     8c4:	1f 92       	push	r1
     8c6:	0f 92       	push	r0
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	0f 92       	push	r0
     8cc:	11 24       	eor	r1, r1
     8ce:	2f 93       	push	r18
     8d0:	3f 93       	push	r19
     8d2:	4f 93       	push	r20
     8d4:	5f 93       	push	r21
     8d6:	6f 93       	push	r22
     8d8:	7f 93       	push	r23
     8da:	8f 93       	push	r24
     8dc:	9f 93       	push	r25
     8de:	af 93       	push	r26
     8e0:	bf 93       	push	r27
     8e2:	ef 93       	push	r30
     8e4:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     8ec:	8c ee       	ldi	r24, 0xEC	; 236
     8ee:	93 e0       	ldi	r25, 0x03	; 3
     8f0:	08 df       	rcall	.-496    	; 0x702 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     8f2:	97 fd       	sbrc	r25, 7
     8f4:	18 c0       	rjmp	.+48     	; 0x926 <__stack+0x27>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     8f6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     8fa:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <__avr_in_isr>
     8fe:	9f d4       	rcall	.+2366   	; 0x123e <chSchIsPreemptionRequired>
     900:	81 11       	cpse	r24, r1
     902:	ad d4       	rcall	.+2394   	; 0x125e <chSchDoPreemption>
}
     904:	ff 91       	pop	r31
     906:	ef 91       	pop	r30
     908:	bf 91       	pop	r27
     90a:	af 91       	pop	r26
     90c:	9f 91       	pop	r25
     90e:	8f 91       	pop	r24
     910:	7f 91       	pop	r23
     912:	6f 91       	pop	r22
     914:	5f 91       	pop	r21
     916:	4f 91       	pop	r20
     918:	3f 91       	pop	r19
     91a:	2f 91       	pop	r18
     91c:	0f 90       	pop	r0
     91e:	0f be       	out	0x3f, r0	; 63
     920:	0f 90       	pop	r0
     922:	1f 90       	pop	r1
     924:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     926:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     92a:	8f 7d       	andi	r24, 0xDF	; 223
     92c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     930:	e4 cf       	rjmp	.-56     	; 0x8fa <__vector_19+0x36>

00000932 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     932:	4d e1       	ldi	r20, 0x1D	; 29
     934:	54 e0       	ldi	r21, 0x04	; 4
     936:	70 e0       	ldi	r23, 0x00	; 0
     938:	60 e0       	ldi	r22, 0x00	; 0
     93a:	8c ee       	ldi	r24, 0xEC	; 236
     93c:	93 e0       	ldi	r25, 0x03	; 3
     93e:	90 ce       	rjmp	.-736    	; 0x660 <sdObjectInit>

00000940 <chSysInit>:
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	c5 e3       	ldi	r28, 0x35	; 53
     946:	d4 e0       	ldi	r29, 0x04	; 4
     948:	81 e0       	ldi	r24, 0x01	; 1
     94a:	88 83       	st	Y, r24
     94c:	1a 82       	std	Y+2, r1	; 0x02
     94e:	19 82       	std	Y+1, r1	; 0x01
     950:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <__core_init>
     954:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <__heap_init>
     958:	6d e1       	ldi	r22, 0x1D	; 29
     95a:	71 e0       	ldi	r23, 0x01	; 1
     95c:	88 e3       	ldi	r24, 0x38	; 56
     95e:	94 e0       	ldi	r25, 0x04	; 4
     960:	cd d4       	rcall	.+2458   	; 0x12fc <chInstanceObjectInit>
     962:	82 e0       	ldi	r24, 0x02	; 2
     964:	88 83       	st	Y, r24
     966:	78 94       	sei
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	08 95       	ret

0000096e <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     96e:	30 c2       	rjmp	.+1120   	; 0xdd0 <chVTDoTickI>

00000970 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
     970:	0f 93       	push	r16
     972:	1f 93       	push	r17

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
     974:	e8 e3       	ldi	r30, 0x38	; 56
     976:	f4 e0       	ldi	r31, 0x04	; 4
     978:	07 8d       	ldd	r16, Z+31	; 0x1f
     97a:	10 a1       	ldd	r17, Z+32	; 0x20
     97c:	21 a1       	ldd	r18, Z+33	; 0x21
     97e:	32 a1       	ldd	r19, Z+34	; 0x22
     980:	dc 01       	movw	r26, r24
     982:	cb 01       	movw	r24, r22
     984:	80 2b       	or	r24, r16
     986:	91 2b       	or	r25, r17
     988:	a2 2b       	or	r26, r18
     98a:	b3 2b       	or	r27, r19
     98c:	87 8f       	std	Z+31, r24	; 0x1f
     98e:	90 a3       	std	Z+32, r25	; 0x20
     990:	a1 a3       	std	Z+33, r26	; 0x21
     992:	b2 a3       	std	Z+34, r27	; 0x22
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	08 95       	ret

0000099a <vt_insert_first.constprop.5>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     99a:	8f 92       	push	r8
     99c:	9f 92       	push	r9
     99e:	af 92       	push	r10
     9a0:	bf 92       	push	r11
     9a2:	cf 92       	push	r12
     9a4:	df 92       	push	r13
     9a6:	ef 92       	push	r14
     9a8:	ff 92       	push	r15
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	fc 01       	movw	r30, r24
     9b4:	eb 01       	movw	r28, r22
     9b6:	70 93 48 04 	sts	0x0448, r23	; 0x800448 <ch0+0x10>
     9ba:	60 93 47 04 	sts	0x0447, r22	; 0x800447 <ch0+0xf>
     9be:	24 83       	std	Z+4, r18	; 0x04
     9c0:	35 83       	std	Z+5, r19	; 0x05
     9c2:	46 83       	std	Z+6, r20	; 0x06
     9c4:	57 83       	std	Z+7, r21	; 0x07
     9c6:	8f e3       	ldi	r24, 0x3F	; 63
     9c8:	94 e0       	ldi	r25, 0x04	; 4
     9ca:	93 83       	std	Z+3, r25	; 0x03
     9cc:	82 83       	std	Z+2, r24	; 0x02
     9ce:	a0 91 3f 04 	lds	r26, 0x043F	; 0x80043f <ch0+0x7>
     9d2:	b0 91 40 04 	lds	r27, 0x0440	; 0x800440 <ch0+0x8>
     9d6:	b1 83       	std	Z+1, r27	; 0x01
     9d8:	a0 83       	st	Z, r26
     9da:	13 96       	adiw	r26, 0x03	; 3
     9dc:	fc 93       	st	X, r31
     9de:	ee 93       	st	-X, r30
     9e0:	12 97       	sbiw	r26, 0x02	; 2
     9e2:	f0 93 40 04 	sts	0x0440, r31	; 0x800440 <ch0+0x8>
     9e6:	e0 93 3f 04 	sts	0x043F, r30	; 0x80043f <ch0+0x7>
     9ea:	69 01       	movw	r12, r18
     9ec:	7a 01       	movw	r14, r20
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	c8 16       	cp	r12, r24
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	d8 06       	cpc	r13, r24
     9f6:	e1 04       	cpc	r14, r1
     9f8:	f1 04       	cpc	r15, r1
     9fa:	20 f0       	brcs	.+8      	; 0xa04 <vt_insert_first.constprop.5+0x6a>
     9fc:	c1 2c       	mov	r12, r1
     9fe:	d1 2c       	mov	r13, r1
     a00:	76 01       	movw	r14, r12
     a02:	da 94       	dec	r13
     a04:	82 e0       	ldi	r24, 0x02	; 2
     a06:	c8 16       	cp	r12, r24
     a08:	d1 04       	cpc	r13, r1
     a0a:	e1 04       	cpc	r14, r1
     a0c:	f1 04       	cpc	r15, r1
     a0e:	28 f4       	brcc	.+10     	; 0xa1a <vt_insert_first.constprop.5+0x80>
     a10:	92 e0       	ldi	r25, 0x02	; 2
     a12:	c9 2e       	mov	r12, r25
     a14:	d1 2c       	mov	r13, r1
     a16:	e1 2c       	mov	r14, r1
     a18:	f1 2c       	mov	r15, r1
     a1a:	ce 01       	movw	r24, r28
     a1c:	8c 0d       	add	r24, r12
     a1e:	9d 1d       	adc	r25, r13
     a20:	5f db       	rcall	.-2370   	; 0xe0 <stStartAlarm>
     a22:	82 e0       	ldi	r24, 0x02	; 2
     a24:	88 2e       	mov	r8, r24
     a26:	91 2c       	mov	r9, r1
     a28:	a1 2c       	mov	r10, r1
     a2a:	b1 2c       	mov	r11, r1
     a2c:	0e c0       	rjmp	.+28     	; 0xa4a <vt_insert_first.constprop.5+0xb0>
     a2e:	75 01       	movw	r14, r10
     a30:	64 01       	movw	r12, r8
     a32:	8f ef       	ldi	r24, 0xFF	; 255
     a34:	c8 1a       	sub	r12, r24
     a36:	d8 0a       	sbc	r13, r24
     a38:	e8 0a       	sbc	r14, r24
     a3a:	f8 0a       	sbc	r15, r24
     a3c:	ce 01       	movw	r24, r28
     a3e:	8c 0d       	add	r24, r12
     a40:	9d 1d       	adc	r25, r13
     a42:	5a db       	rcall	.-2380   	; 0xf8 <stSetAlarm>
     a44:	e8 01       	movw	r28, r16
     a46:	46 01       	movw	r8, r12
     a48:	57 01       	movw	r10, r14
     a4a:	45 db       	rcall	.-2422   	; 0xd6 <stGetCounter>
     a4c:	8c 01       	movw	r16, r24
     a4e:	8c 1b       	sub	r24, r28
     a50:	9d 0b       	sbc	r25, r29
     a52:	b0 e0       	ldi	r27, 0x00	; 0
     a54:	a0 e0       	ldi	r26, 0x00	; 0
     a56:	8c 15       	cp	r24, r12
     a58:	9d 05       	cpc	r25, r13
     a5a:	ae 05       	cpc	r26, r14
     a5c:	bf 05       	cpc	r27, r15
     a5e:	38 f7       	brcc	.-50     	; 0xa2e <vt_insert_first.constprop.5+0x94>
     a60:	83 e0       	ldi	r24, 0x03	; 3
     a62:	88 16       	cp	r8, r24
     a64:	91 04       	cpc	r9, r1
     a66:	a1 04       	cpc	r10, r1
     a68:	b1 04       	cpc	r11, r1
     a6a:	68 f4       	brcc	.+26     	; 0xa86 <vt_insert_first.constprop.5+0xec>
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	ff 90       	pop	r15
     a76:	ef 90       	pop	r14
     a78:	df 90       	pop	r13
     a7a:	cf 90       	pop	r12
     a7c:	bf 90       	pop	r11
     a7e:	af 90       	pop	r10
     a80:	9f 90       	pop	r9
     a82:	8f 90       	pop	r8
     a84:	08 95       	ret
     a86:	61 e0       	ldi	r22, 0x01	; 1
     a88:	70 e0       	ldi	r23, 0x00	; 0
     a8a:	80 e0       	ldi	r24, 0x00	; 0
     a8c:	90 e0       	ldi	r25, 0x00	; 0
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	1f 91       	pop	r17
     a94:	0f 91       	pop	r16
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	df 90       	pop	r13
     a9c:	cf 90       	pop	r12
     a9e:	bf 90       	pop	r11
     aa0:	af 90       	pop	r10
     aa2:	9f 90       	pop	r9
     aa4:	8f 90       	pop	r8
     aa6:	64 cf       	rjmp	.-312    	; 0x970 <chRFCUCollectFaultsI>

00000aa8 <vt_set_alarm>:
     aa8:	8f 92       	push	r8
     aaa:	9f 92       	push	r9
     aac:	af 92       	push	r10
     aae:	bf 92       	push	r11
     ab0:	cf 92       	push	r12
     ab2:	df 92       	push	r13
     ab4:	ef 92       	push	r14
     ab6:	ff 92       	push	r15
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	ec 01       	movw	r28, r24
     abe:	6a 01       	movw	r12, r20
     ac0:	7b 01       	movw	r14, r22
     ac2:	21 e0       	ldi	r18, 0x01	; 1
     ac4:	c2 16       	cp	r12, r18
     ac6:	2f ef       	ldi	r18, 0xFF	; 255
     ac8:	d2 06       	cpc	r13, r18
     aca:	e1 04       	cpc	r14, r1
     acc:	f1 04       	cpc	r15, r1
     ace:	20 f0       	brcs	.+8      	; 0xad8 <vt_set_alarm+0x30>
     ad0:	c1 2c       	mov	r12, r1
     ad2:	d1 2c       	mov	r13, r1
     ad4:	76 01       	movw	r14, r12
     ad6:	da 94       	dec	r13
     ad8:	82 e0       	ldi	r24, 0x02	; 2
     ada:	c8 16       	cp	r12, r24
     adc:	d1 04       	cpc	r13, r1
     ade:	e1 04       	cpc	r14, r1
     ae0:	f1 04       	cpc	r15, r1
     ae2:	28 f4       	brcc	.+10     	; 0xaee <vt_set_alarm+0x46>
     ae4:	92 e0       	ldi	r25, 0x02	; 2
     ae6:	c9 2e       	mov	r12, r25
     ae8:	d1 2c       	mov	r13, r1
     aea:	e1 2c       	mov	r14, r1
     aec:	f1 2c       	mov	r15, r1
     aee:	82 e0       	ldi	r24, 0x02	; 2
     af0:	88 2e       	mov	r8, r24
     af2:	91 2c       	mov	r9, r1
     af4:	a1 2c       	mov	r10, r1
     af6:	b1 2c       	mov	r11, r1
     af8:	0a c0       	rjmp	.+20     	; 0xb0e <vt_set_alarm+0x66>
     afa:	75 01       	movw	r14, r10
     afc:	64 01       	movw	r12, r8
     afe:	2f ef       	ldi	r18, 0xFF	; 255
     b00:	c2 1a       	sub	r12, r18
     b02:	d2 0a       	sbc	r13, r18
     b04:	e2 0a       	sbc	r14, r18
     b06:	f2 0a       	sbc	r15, r18
     b08:	ec 01       	movw	r28, r24
     b0a:	46 01       	movw	r8, r12
     b0c:	57 01       	movw	r10, r14
     b0e:	ce 01       	movw	r24, r28
     b10:	8c 0d       	add	r24, r12
     b12:	9d 1d       	adc	r25, r13
     b14:	f1 da       	rcall	.-2590   	; 0xf8 <stSetAlarm>
     b16:	df da       	rcall	.-2626   	; 0xd6 <stGetCounter>
     b18:	ac 01       	movw	r20, r24
     b1a:	4c 1b       	sub	r20, r28
     b1c:	5d 0b       	sbc	r21, r29
     b1e:	70 e0       	ldi	r23, 0x00	; 0
     b20:	60 e0       	ldi	r22, 0x00	; 0
     b22:	4c 15       	cp	r20, r12
     b24:	5d 05       	cpc	r21, r13
     b26:	6e 05       	cpc	r22, r14
     b28:	7f 05       	cpc	r23, r15
     b2a:	38 f7       	brcc	.-50     	; 0xafa <vt_set_alarm+0x52>
     b2c:	83 e0       	ldi	r24, 0x03	; 3
     b2e:	88 16       	cp	r8, r24
     b30:	91 04       	cpc	r9, r1
     b32:	a1 04       	cpc	r10, r1
     b34:	b1 04       	cpc	r11, r1
     b36:	58 f4       	brcc	.+22     	; 0xb4e <vt_set_alarm+0xa6>
     b38:	df 91       	pop	r29
     b3a:	cf 91       	pop	r28
     b3c:	ff 90       	pop	r15
     b3e:	ef 90       	pop	r14
     b40:	df 90       	pop	r13
     b42:	cf 90       	pop	r12
     b44:	bf 90       	pop	r11
     b46:	af 90       	pop	r10
     b48:	9f 90       	pop	r9
     b4a:	8f 90       	pop	r8
     b4c:	08 95       	ret
     b4e:	61 e0       	ldi	r22, 0x01	; 1
     b50:	70 e0       	ldi	r23, 0x00	; 0
     b52:	80 e0       	ldi	r24, 0x00	; 0
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	df 91       	pop	r29
     b58:	cf 91       	pop	r28
     b5a:	ff 90       	pop	r15
     b5c:	ef 90       	pop	r14
     b5e:	df 90       	pop	r13
     b60:	cf 90       	pop	r12
     b62:	bf 90       	pop	r11
     b64:	af 90       	pop	r10
     b66:	9f 90       	pop	r9
     b68:	8f 90       	pop	r8
     b6a:	02 cf       	rjmp	.-508    	; 0x970 <chRFCUCollectFaultsI>

00000b6c <vt_enqueue.constprop.4>:
     b6c:	8f 92       	push	r8
     b6e:	9f 92       	push	r9
     b70:	af 92       	push	r10
     b72:	bf 92       	push	r11
     b74:	cf 92       	push	r12
     b76:	df 92       	push	r13
     b78:	ef 92       	push	r14
     b7a:	ff 92       	push	r15
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	ec 01       	movw	r28, r24
     b82:	4a 01       	movw	r8, r20
     b84:	5b 01       	movw	r10, r22
     b86:	a7 da       	rcall	.-2738   	; 0xd6 <stGetCounter>
     b88:	e0 91 3f 04 	lds	r30, 0x043F	; 0x80043f <ch0+0x7>
     b8c:	f0 91 40 04 	lds	r31, 0x0440	; 0x800440 <ch0+0x8>
     b90:	24 e0       	ldi	r18, 0x04	; 4
     b92:	ef 33       	cpi	r30, 0x3F	; 63
     b94:	f2 07       	cpc	r31, r18
     b96:	09 f4       	brne	.+2      	; 0xb9a <vt_enqueue.constprop.4+0x2e>
     b98:	73 c0       	rjmp	.+230    	; 0xc80 <vt_enqueue.constprop.4+0x114>
     b9a:	20 91 47 04 	lds	r18, 0x0447	; 0x800447 <ch0+0xf>
     b9e:	30 91 48 04 	lds	r19, 0x0448	; 0x800448 <ch0+0x10>
     ba2:	ac 01       	movw	r20, r24
     ba4:	42 1b       	sub	r20, r18
     ba6:	53 0b       	sbc	r21, r19
     ba8:	70 e0       	ldi	r23, 0x00	; 0
     baa:	60 e0       	ldi	r22, 0x00	; 0
     bac:	75 01       	movw	r14, r10
     bae:	64 01       	movw	r12, r8
     bb0:	c4 0e       	add	r12, r20
     bb2:	d5 1e       	adc	r13, r21
     bb4:	e6 1e       	adc	r14, r22
     bb6:	f7 1e       	adc	r15, r23
     bb8:	c4 16       	cp	r12, r20
     bba:	d5 06       	cpc	r13, r21
     bbc:	e6 06       	cpc	r14, r22
     bbe:	f7 06       	cpc	r15, r23
     bc0:	08 f4       	brcc	.+2      	; 0xbc4 <vt_enqueue.constprop.4+0x58>
     bc2:	4f c0       	rjmp	.+158    	; 0xc62 <vt_enqueue.constprop.4+0xf6>
     bc4:	44 81       	ldd	r20, Z+4	; 0x04
     bc6:	55 81       	ldd	r21, Z+5	; 0x05
     bc8:	66 81       	ldd	r22, Z+6	; 0x06
     bca:	77 81       	ldd	r23, Z+7	; 0x07
     bcc:	c4 16       	cp	r12, r20
     bce:	d5 06       	cpc	r13, r21
     bd0:	e6 06       	cpc	r14, r22
     bd2:	f7 06       	cpc	r15, r23
     bd4:	08 f4       	brcc	.+2      	; 0xbd8 <vt_enqueue.constprop.4+0x6c>
     bd6:	48 c0       	rjmp	.+144    	; 0xc68 <vt_enqueue.constprop.4+0xfc>
     bd8:	4c 15       	cp	r20, r12
     bda:	5d 05       	cpc	r21, r13
     bdc:	6e 05       	cpc	r22, r14
     bde:	7f 05       	cpc	r23, r15
     be0:	80 f4       	brcc	.+32     	; 0xc02 <vt_enqueue.constprop.4+0x96>
     be2:	c4 1a       	sub	r12, r20
     be4:	d5 0a       	sbc	r13, r21
     be6:	e6 0a       	sbc	r14, r22
     be8:	f7 0a       	sbc	r15, r23
     bea:	01 90       	ld	r0, Z+
     bec:	f0 81       	ld	r31, Z
     bee:	e0 2d       	mov	r30, r0
     bf0:	44 81       	ldd	r20, Z+4	; 0x04
     bf2:	55 81       	ldd	r21, Z+5	; 0x05
     bf4:	66 81       	ldd	r22, Z+6	; 0x06
     bf6:	77 81       	ldd	r23, Z+7	; 0x07
     bf8:	4c 15       	cp	r20, r12
     bfa:	5d 05       	cpc	r21, r13
     bfc:	6e 05       	cpc	r22, r14
     bfe:	7f 05       	cpc	r23, r15
     c00:	80 f3       	brcs	.-32     	; 0xbe2 <vt_enqueue.constprop.4+0x76>
     c02:	cc 82       	std	Y+4, r12	; 0x04
     c04:	dd 82       	std	Y+5, r13	; 0x05
     c06:	ee 82       	std	Y+6, r14	; 0x06
     c08:	ff 82       	std	Y+7, r15	; 0x07
     c0a:	f9 83       	std	Y+1, r31	; 0x01
     c0c:	e8 83       	st	Y, r30
     c0e:	a2 81       	ldd	r26, Z+2	; 0x02
     c10:	b3 81       	ldd	r27, Z+3	; 0x03
     c12:	bb 83       	std	Y+3, r27	; 0x03
     c14:	aa 83       	std	Y+2, r26	; 0x02
     c16:	cd 93       	st	X+, r28
     c18:	dc 93       	st	X, r29
     c1a:	d3 83       	std	Z+3, r29	; 0x03
     c1c:	c2 83       	std	Z+2, r28	; 0x02
     c1e:	84 81       	ldd	r24, Z+4	; 0x04
     c20:	95 81       	ldd	r25, Z+5	; 0x05
     c22:	a6 81       	ldd	r26, Z+6	; 0x06
     c24:	b7 81       	ldd	r27, Z+7	; 0x07
     c26:	8c 19       	sub	r24, r12
     c28:	9d 09       	sbc	r25, r13
     c2a:	ae 09       	sbc	r26, r14
     c2c:	bf 09       	sbc	r27, r15
     c2e:	84 83       	std	Z+4, r24	; 0x04
     c30:	95 83       	std	Z+5, r25	; 0x05
     c32:	a6 83       	std	Z+6, r26	; 0x06
     c34:	b7 83       	std	Z+7, r27	; 0x07
     c36:	8f ef       	ldi	r24, 0xFF	; 255
     c38:	9f ef       	ldi	r25, 0xFF	; 255
     c3a:	dc 01       	movw	r26, r24
     c3c:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <ch0+0xb>
     c40:	90 93 44 04 	sts	0x0444, r25	; 0x800444 <ch0+0xc>
     c44:	a0 93 45 04 	sts	0x0445, r26	; 0x800445 <ch0+0xd>
     c48:	b0 93 46 04 	sts	0x0446, r27	; 0x800446 <ch0+0xe>
     c4c:	df 91       	pop	r29
     c4e:	cf 91       	pop	r28
     c50:	ff 90       	pop	r15
     c52:	ef 90       	pop	r14
     c54:	df 90       	pop	r13
     c56:	cf 90       	pop	r12
     c58:	bf 90       	pop	r11
     c5a:	af 90       	pop	r10
     c5c:	9f 90       	pop	r9
     c5e:	8f 90       	pop	r8
     c60:	08 95       	ret
     c62:	75 01       	movw	r14, r10
     c64:	64 01       	movw	r12, r8
     c66:	ae cf       	rjmp	.-164    	; 0xbc4 <vt_enqueue.constprop.4+0x58>
     c68:	b5 01       	movw	r22, r10
     c6a:	a4 01       	movw	r20, r8
     c6c:	1d df       	rcall	.-454    	; 0xaa8 <vt_set_alarm>
     c6e:	e0 91 3f 04 	lds	r30, 0x043F	; 0x80043f <ch0+0x7>
     c72:	f0 91 40 04 	lds	r31, 0x0440	; 0x800440 <ch0+0x8>
     c76:	44 81       	ldd	r20, Z+4	; 0x04
     c78:	55 81       	ldd	r21, Z+5	; 0x05
     c7a:	66 81       	ldd	r22, Z+6	; 0x06
     c7c:	77 81       	ldd	r23, Z+7	; 0x07
     c7e:	ac cf       	rjmp	.-168    	; 0xbd8 <vt_enqueue.constprop.4+0x6c>
     c80:	a5 01       	movw	r20, r10
     c82:	94 01       	movw	r18, r8
     c84:	bc 01       	movw	r22, r24
     c86:	ce 01       	movw	r24, r28
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	ff 90       	pop	r15
     c8e:	ef 90       	pop	r14
     c90:	df 90       	pop	r13
     c92:	cf 90       	pop	r12
     c94:	bf 90       	pop	r11
     c96:	af 90       	pop	r10
     c98:	9f 90       	pop	r9
     c9a:	8f 90       	pop	r8
     c9c:	7e ce       	rjmp	.-772    	; 0x99a <vt_insert_first.constprop.5>

00000c9e <chVTDoSetI>:
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	fc 01       	movw	r30, r24
     ca4:	13 87       	std	Z+11, r17	; 0x0b
     ca6:	02 87       	std	Z+10, r16	; 0x0a
     ca8:	31 87       	std	Z+9, r19	; 0x09
     caa:	20 87       	std	Z+8, r18	; 0x08
     cac:	14 86       	std	Z+12, r1	; 0x0c
     cae:	15 86       	std	Z+13, r1	; 0x0d
     cb0:	16 86       	std	Z+14, r1	; 0x0e
     cb2:	17 86       	std	Z+15, r1	; 0x0f
     cb4:	1f 91       	pop	r17
     cb6:	0f 91       	pop	r16
     cb8:	59 cf       	rjmp	.-334    	; 0xb6c <vt_enqueue.constprop.4>

00000cba <chVTDoResetI>:
     cba:	0f 93       	push	r16
     cbc:	1f 93       	push	r17
     cbe:	cf 93       	push	r28
     cc0:	df 93       	push	r29
     cc2:	fc 01       	movw	r30, r24
     cc4:	a0 81       	ld	r26, Z
     cc6:	b1 81       	ldd	r27, Z+1	; 0x01
     cc8:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <ch0+0x7>
     ccc:	90 91 40 04 	lds	r25, 0x0440	; 0x800440 <ch0+0x8>
     cd0:	e8 17       	cp	r30, r24
     cd2:	f9 07       	cpc	r31, r25
     cd4:	81 f1       	breq	.+96     	; 0xd36 <chVTDoResetI+0x7c>
     cd6:	c2 81       	ldd	r28, Z+2	; 0x02
     cd8:	d3 81       	ldd	r29, Z+3	; 0x03
     cda:	b9 83       	std	Y+1, r27	; 0x01
     cdc:	a8 83       	st	Y, r26
     cde:	a0 81       	ld	r26, Z
     ce0:	b1 81       	ldd	r27, Z+1	; 0x01
     ce2:	13 96       	adiw	r26, 0x03	; 3
     ce4:	dc 93       	st	X, r29
     ce6:	ce 93       	st	-X, r28
     ce8:	12 97       	sbiw	r26, 0x02	; 2
     cea:	14 96       	adiw	r26, 0x04	; 4
     cec:	4d 91       	ld	r20, X+
     cee:	5d 91       	ld	r21, X+
     cf0:	6d 91       	ld	r22, X+
     cf2:	7c 91       	ld	r23, X
     cf4:	17 97       	sbiw	r26, 0x07	; 7
     cf6:	04 81       	ldd	r16, Z+4	; 0x04
     cf8:	15 81       	ldd	r17, Z+5	; 0x05
     cfa:	26 81       	ldd	r18, Z+6	; 0x06
     cfc:	37 81       	ldd	r19, Z+7	; 0x07
     cfe:	40 0f       	add	r20, r16
     d00:	51 1f       	adc	r21, r17
     d02:	62 1f       	adc	r22, r18
     d04:	73 1f       	adc	r23, r19
     d06:	14 96       	adiw	r26, 0x04	; 4
     d08:	4d 93       	st	X+, r20
     d0a:	5d 93       	st	X+, r21
     d0c:	6d 93       	st	X+, r22
     d0e:	7c 93       	st	X, r23
     d10:	17 97       	sbiw	r26, 0x07	; 7
     d12:	11 82       	std	Z+1, r1	; 0x01
     d14:	10 82       	st	Z, r1
     d16:	8f ef       	ldi	r24, 0xFF	; 255
     d18:	9f ef       	ldi	r25, 0xFF	; 255
     d1a:	dc 01       	movw	r26, r24
     d1c:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <ch0+0xb>
     d20:	90 93 44 04 	sts	0x0444, r25	; 0x800444 <ch0+0xc>
     d24:	a0 93 45 04 	sts	0x0445, r26	; 0x800445 <ch0+0xd>
     d28:	b0 93 46 04 	sts	0x0446, r27	; 0x800446 <ch0+0xe>
     d2c:	df 91       	pop	r29
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	08 95       	ret
     d36:	b0 93 40 04 	sts	0x0440, r27	; 0x800440 <ch0+0x8>
     d3a:	a0 93 3f 04 	sts	0x043F, r26	; 0x80043f <ch0+0x7>
     d3e:	8f e3       	ldi	r24, 0x3F	; 63
     d40:	94 e0       	ldi	r25, 0x04	; 4
     d42:	13 96       	adiw	r26, 0x03	; 3
     d44:	9c 93       	st	X, r25
     d46:	8e 93       	st	-X, r24
     d48:	12 97       	sbiw	r26, 0x02	; 2
     d4a:	11 82       	std	Z+1, r1	; 0x01
     d4c:	10 82       	st	Z, r1
     d4e:	a0 91 3f 04 	lds	r26, 0x043F	; 0x80043f <ch0+0x7>
     d52:	b0 91 40 04 	lds	r27, 0x0440	; 0x800440 <ch0+0x8>
     d56:	a8 17       	cp	r26, r24
     d58:	b9 07       	cpc	r27, r25
     d5a:	a9 f1       	breq	.+106    	; 0xdc6 <chVTDoResetI+0x10c>
     d5c:	14 96       	adiw	r26, 0x04	; 4
     d5e:	4d 91       	ld	r20, X+
     d60:	5d 91       	ld	r21, X+
     d62:	6d 91       	ld	r22, X+
     d64:	7c 91       	ld	r23, X
     d66:	17 97       	sbiw	r26, 0x07	; 7
     d68:	04 81       	ldd	r16, Z+4	; 0x04
     d6a:	15 81       	ldd	r17, Z+5	; 0x05
     d6c:	26 81       	ldd	r18, Z+6	; 0x06
     d6e:	37 81       	ldd	r19, Z+7	; 0x07
     d70:	40 0f       	add	r20, r16
     d72:	51 1f       	adc	r21, r17
     d74:	62 1f       	adc	r22, r18
     d76:	73 1f       	adc	r23, r19
     d78:	14 96       	adiw	r26, 0x04	; 4
     d7a:	4d 93       	st	X+, r20
     d7c:	5d 93       	st	X+, r21
     d7e:	6d 93       	st	X+, r22
     d80:	7c 93       	st	X, r23
     d82:	17 97       	sbiw	r26, 0x07	; 7
     d84:	a8 d9       	rcall	.-3248   	; 0xd6 <stGetCounter>
     d86:	20 91 47 04 	lds	r18, 0x0447	; 0x800447 <ch0+0xf>
     d8a:	30 91 48 04 	lds	r19, 0x0448	; 0x800448 <ch0+0x10>
     d8e:	8c 01       	movw	r16, r24
     d90:	02 1b       	sub	r16, r18
     d92:	13 0b       	sbc	r17, r19
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	e0 91 3f 04 	lds	r30, 0x043F	; 0x80043f <ch0+0x7>
     d9c:	f0 91 40 04 	lds	r31, 0x0440	; 0x800440 <ch0+0x8>
     da0:	44 81       	ldd	r20, Z+4	; 0x04
     da2:	55 81       	ldd	r21, Z+5	; 0x05
     da4:	66 81       	ldd	r22, Z+6	; 0x06
     da6:	77 81       	ldd	r23, Z+7	; 0x07
     da8:	04 17       	cp	r16, r20
     daa:	15 07       	cpc	r17, r21
     dac:	26 07       	cpc	r18, r22
     dae:	37 07       	cpc	r19, r23
     db0:	08 f0       	brcs	.+2      	; 0xdb4 <chVTDoResetI+0xfa>
     db2:	bc cf       	rjmp	.-136    	; 0xd2c <chVTDoResetI+0x72>
     db4:	40 1b       	sub	r20, r16
     db6:	51 0b       	sbc	r21, r17
     db8:	62 0b       	sbc	r22, r18
     dba:	73 0b       	sbc	r23, r19
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	1f 91       	pop	r17
     dc2:	0f 91       	pop	r16
     dc4:	71 ce       	rjmp	.-798    	; 0xaa8 <vt_set_alarm>
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	1f 91       	pop	r17
     dcc:	0f 91       	pop	r16
     dce:	91 c9       	rjmp	.-3294   	; 0xf2 <stStopAlarm>

00000dd0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     dd0:	4f 92       	push	r4
     dd2:	5f 92       	push	r5
     dd4:	6f 92       	push	r6
     dd6:	7f 92       	push	r7
     dd8:	8f 92       	push	r8
     dda:	9f 92       	push	r9
     ddc:	af 92       	push	r10
     dde:	bf 92       	push	r11
     de0:	cf 92       	push	r12
     de2:	df 92       	push	r13
     de4:	ef 92       	push	r14
     de6:	ff 92       	push	r15
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     df0:	cc 24       	eor	r12, r12
     df2:	ca 94       	dec	r12
     df4:	dc 2c       	mov	r13, r12
     df6:	76 01       	movw	r14, r12
     df8:	0f c0       	rjmp	.+30     	; 0xe18 <chVTDoTickI+0x48>
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
     dfa:	6a 85       	ldd	r22, Y+10	; 0x0a
     dfc:	7b 85       	ldd	r23, Y+11	; 0x0b
     dfe:	e8 85       	ldd	r30, Y+8	; 0x08
     e00:	f9 85       	ldd	r31, Y+9	; 0x09
     e02:	ce 01       	movw	r24, r28
     e04:	09 95       	icall

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
     e06:	8c 85       	ldd	r24, Y+12	; 0x0c
     e08:	9d 85       	ldd	r25, Y+13	; 0x0d
     e0a:	ae 85       	ldd	r26, Y+14	; 0x0e
     e0c:	bf 85       	ldd	r27, Y+15	; 0x0f
     e0e:	89 2b       	or	r24, r25
     e10:	8a 2b       	or	r24, r26
     e12:	8b 2b       	or	r24, r27
     e14:	09 f0       	breq	.+2      	; 0xe18 <chVTDoTickI+0x48>
     e16:	5a c0       	rjmp	.+180    	; 0xecc <chVTDoTickI+0xfc>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
     e18:	c0 91 3f 04 	lds	r28, 0x043F	; 0x80043f <ch0+0x7>
     e1c:	d0 91 40 04 	lds	r29, 0x0440	; 0x800440 <ch0+0x8>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     e20:	5a d9       	rcall	.-3404   	; 0xd6 <stGetCounter>

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
     e22:	00 91 47 04 	lds	r16, 0x0447	; 0x800447 <ch0+0xf>
     e26:	10 91 48 04 	lds	r17, 0x0448	; 0x800448 <ch0+0x10>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     e2a:	4c 01       	movw	r8, r24
     e2c:	80 1a       	sub	r8, r16
     e2e:	91 0a       	sbc	r9, r17
     e30:	b1 2c       	mov	r11, r1
     e32:	a1 2c       	mov	r10, r1

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
     e34:	4c 81       	ldd	r20, Y+4	; 0x04
     e36:	5d 81       	ldd	r21, Y+5	; 0x05
     e38:	6e 81       	ldd	r22, Y+6	; 0x06
     e3a:	7f 81       	ldd	r23, Y+7	; 0x07
     e3c:	84 16       	cp	r8, r20
     e3e:	95 06       	cpc	r9, r21
     e40:	a6 06       	cpc	r10, r22
     e42:	b7 06       	cpc	r11, r23
     e44:	f0 f0       	brcs	.+60     	; 0xe82 <chVTDoTickI+0xb2>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
     e46:	04 0f       	add	r16, r20
     e48:	15 1f       	adc	r17, r21
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;
     e4a:	10 93 48 04 	sts	0x0448, r17	; 0x800448 <ch0+0x10>
     e4e:	00 93 47 04 	sts	0x0447, r16	; 0x800447 <ch0+0xf>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     e52:	ea 81       	ldd	r30, Y+2	; 0x02
     e54:	fb 81       	ldd	r31, Y+3	; 0x03
     e56:	88 81       	ld	r24, Y
     e58:	99 81       	ldd	r25, Y+1	; 0x01
     e5a:	91 83       	std	Z+1, r25	; 0x01
     e5c:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     e5e:	a8 81       	ld	r26, Y
     e60:	b9 81       	ldd	r27, Y+1	; 0x01
     e62:	13 96       	adiw	r26, 0x03	; 3
     e64:	fc 93       	st	X, r31
     e66:	ee 93       	st	-X, r30
     e68:	12 97       	sbiw	r26, 0x02	; 2

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
     e6a:	19 82       	std	Y+1, r1	; 0x01
     e6c:	18 82       	st	Y, r1

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
     e6e:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <ch0+0x7>
     e72:	90 91 40 04 	lds	r25, 0x0440	; 0x800440 <ch0+0x8>
     e76:	8f 53       	subi	r24, 0x3F	; 63
     e78:	94 40       	sbci	r25, 0x04	; 4
     e7a:	09 f0       	breq	.+2      	; 0xe7e <chVTDoTickI+0xae>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
     e7c:	be cf       	rjmp	.-132    	; 0xdfa <chVTDoTickI+0x2a>
     e7e:	39 d9       	rcall	.-3470   	; 0xf2 <stStopAlarm>
     e80:	bc cf       	rjmp	.-136    	; 0xdfa <chVTDoTickI+0x2a>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
     e82:	20 91 3f 04 	lds	r18, 0x043F	; 0x80043f <ch0+0x7>
     e86:	30 91 40 04 	lds	r19, 0x0440	; 0x800440 <ch0+0x8>
     e8a:	2f 53       	subi	r18, 0x3F	; 63
     e8c:	34 40       	sbci	r19, 0x04	; 4
     e8e:	09 f4       	brne	.+2      	; 0xe92 <chVTDoTickI+0xc2>
     e90:	78 c0       	rjmp	.+240    	; 0xf82 <chVTDoTickI+0x1b2>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
     e92:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <ch0+0x10>
     e96:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <ch0+0xf>
  vtp->dlist.delta -= nowdelta;
     e9a:	48 19       	sub	r20, r8
     e9c:	59 09       	sbc	r21, r9
     e9e:	6a 09       	sbc	r22, r10
     ea0:	7b 09       	sbc	r23, r11
     ea2:	4c 83       	std	Y+4, r20	; 0x04
     ea4:	5d 83       	std	Y+5, r21	; 0x05
     ea6:	6e 83       	std	Y+6, r22	; 0x06
     ea8:	7f 83       	std	Y+7, r23	; 0x07

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	1f 91       	pop	r17
     eb0:	0f 91       	pop	r16
     eb2:	ff 90       	pop	r15
     eb4:	ef 90       	pop	r14
     eb6:	df 90       	pop	r13
     eb8:	cf 90       	pop	r12
     eba:	bf 90       	pop	r11
     ebc:	af 90       	pop	r10
     ebe:	9f 90       	pop	r9
     ec0:	8f 90       	pop	r8
     ec2:	7f 90       	pop	r7
     ec4:	6f 90       	pop	r6
     ec6:	5f 90       	pop	r5
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
     ec8:	4f 90       	pop	r4
     eca:	ee cd       	rjmp	.-1060   	; 0xaa8 <vt_set_alarm>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     ecc:	04 d9       	rcall	.-3576   	; 0xd6 <stGetCounter>
     ece:	5c 01       	movw	r10, r24
     ed0:	2c 01       	movw	r4, r24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     ed2:	40 1a       	sub	r4, r16
     ed4:	51 0a       	sbc	r5, r17
     ed6:	71 2c       	mov	r7, r1
     ed8:	61 2c       	mov	r6, r1
     eda:	8c 85       	ldd	r24, Y+12	; 0x0c
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
     edc:	9d 85       	ldd	r25, Y+13	; 0x0d
     ede:	ae 85       	ldd	r26, Y+14	; 0x0e
     ee0:	bf 85       	ldd	r27, Y+15	; 0x0f
     ee2:	84 15       	cp	r24, r4
     ee4:	95 05       	cpc	r25, r5
     ee6:	a6 05       	cpc	r26, r6
     ee8:	b7 05       	cpc	r27, r7
     eea:	08 f4       	brcc	.+2      	; 0xeee <chVTDoTickI+0x11e>
     eec:	5b c0       	rjmp	.+182    	; 0xfa4 <chVTDoTickI+0x1d4>
     eee:	00 91 3f 04 	lds	r16, 0x043F	; 0x80043f <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     ef2:	10 91 40 04 	lds	r17, 0x0440	; 0x800440 <ch0+0x8>
     ef6:	e4 e0       	ldi	r30, 0x04	; 4
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     ef8:	0f 33       	cpi	r16, 0x3F	; 63
     efa:	1e 07       	cpc	r17, r30
     efc:	09 f4       	brne	.+2      	; 0xf00 <chVTDoTickI+0x130>
     efe:	62 c0       	rjmp	.+196    	; 0xfc4 <chVTDoTickI+0x1f4>
     f00:	f8 01       	movw	r30, r16
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     f02:	44 81       	ldd	r20, Z+4	; 0x04
     f04:	55 81       	ldd	r21, Z+5	; 0x05
     f06:	66 81       	ldd	r22, Z+6	; 0x06
     f08:	77 81       	ldd	r23, Z+7	; 0x07
     f0a:	48 17       	cp	r20, r24
     f0c:	59 07       	cpc	r21, r25
     f0e:	6a 07       	cpc	r22, r26
     f10:	7b 07       	cpc	r23, r27
     f12:	88 f4       	brcc	.+34     	; 0xf36 <chVTDoTickI+0x166>
     f14:	84 1b       	sub	r24, r20
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     f16:	95 0b       	sbc	r25, r21
     f18:	a6 0b       	sbc	r26, r22
     f1a:	b7 0b       	sbc	r27, r23
     f1c:	f8 01       	movw	r30, r16
    dlp = dlp->next;
     f1e:	00 81       	ld	r16, Z
     f20:	11 81       	ldd	r17, Z+1	; 0x01
     f22:	f8 01       	movw	r30, r16
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     f24:	44 81       	ldd	r20, Z+4	; 0x04
     f26:	55 81       	ldd	r21, Z+5	; 0x05
     f28:	66 81       	ldd	r22, Z+6	; 0x06
     f2a:	77 81       	ldd	r23, Z+7	; 0x07
     f2c:	48 17       	cp	r20, r24
     f2e:	59 07       	cpc	r21, r25
     f30:	6a 07       	cpc	r22, r26
     f32:	7b 07       	cpc	r23, r27
     f34:	78 f3       	brcs	.-34     	; 0xf14 <chVTDoTickI+0x144>
     f36:	8c 83       	std	Y+4, r24	; 0x04
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     f38:	9d 83       	std	Y+5, r25	; 0x05
     f3a:	ae 83       	std	Y+6, r26	; 0x06
     f3c:	bf 83       	std	Y+7, r27	; 0x07
     f3e:	19 83       	std	Y+1, r17	; 0x01
  dlp->next       = dlhp;
     f40:	08 83       	st	Y, r16
     f42:	f8 01       	movw	r30, r16
  dlp->prev       = dlp->next->prev;
     f44:	22 81       	ldd	r18, Z+2	; 0x02
     f46:	33 81       	ldd	r19, Z+3	; 0x03
     f48:	3b 83       	std	Y+3, r19	; 0x03
     f4a:	2a 83       	std	Y+2, r18	; 0x02
     f4c:	f9 01       	movw	r30, r18
  dlp->prev->next = dlp;
     f4e:	d1 83       	std	Z+1, r29	; 0x01
     f50:	c0 83       	st	Z, r28
     f52:	f8 01       	movw	r30, r16
  dlhp->prev      = dlp;
     f54:	d3 83       	std	Z+3, r29	; 0x03
     f56:	c2 83       	std	Z+2, r28	; 0x02
     f58:	44 81       	ldd	r20, Z+4	; 0x04

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     f5a:	55 81       	ldd	r21, Z+5	; 0x05
     f5c:	66 81       	ldd	r22, Z+6	; 0x06
     f5e:	77 81       	ldd	r23, Z+7	; 0x07
     f60:	48 1b       	sub	r20, r24
     f62:	59 0b       	sbc	r21, r25
     f64:	6a 0b       	sbc	r22, r26
     f66:	7b 0b       	sbc	r23, r27
     f68:	44 83       	std	Z+4, r20	; 0x04
     f6a:	55 83       	std	Z+5, r21	; 0x05
     f6c:	66 83       	std	Z+6, r22	; 0x06
     f6e:	77 83       	std	Z+7, r23	; 0x07
     f70:	c0 92 43 04 	sts	0x0443, r12	; 0x800443 <ch0+0xb>

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     f74:	d0 92 44 04 	sts	0x0444, r13	; 0x800444 <ch0+0xc>
     f78:	e0 92 45 04 	sts	0x0445, r14	; 0x800445 <ch0+0xd>
     f7c:	f0 92 46 04 	sts	0x0446, r15	; 0x800446 <ch0+0xe>
     f80:	4b cf       	rjmp	.-362    	; 0xe18 <chVTDoTickI+0x48>
     f82:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     f84:	cf 91       	pop	r28
     f86:	1f 91       	pop	r17
     f88:	0f 91       	pop	r16
     f8a:	ff 90       	pop	r15
     f8c:	ef 90       	pop	r14
     f8e:	df 90       	pop	r13
     f90:	cf 90       	pop	r12
     f92:	bf 90       	pop	r11
     f94:	af 90       	pop	r10
     f96:	9f 90       	pop	r9
     f98:	8f 90       	pop	r8
     f9a:	7f 90       	pop	r7
     f9c:	6f 90       	pop	r6
     f9e:	5f 90       	pop	r5
     fa0:	4f 90       	pop	r4
     fa2:	08 95       	ret
     fa4:	62 e0       	ldi	r22, 0x02	; 2
      if (nowdelta > vtp->reload) {
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
     fa6:	70 e0       	ldi	r23, 0x00	; 0
     fa8:	80 e0       	ldi	r24, 0x00	; 0
     faa:	90 e0       	ldi	r25, 0x00	; 0
     fac:	e1 dc       	rcall	.-1598   	; 0x970 <chRFCUCollectFaultsI>
     fae:	00 91 3f 04 	lds	r16, 0x043F	; 0x80043f <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     fb2:	10 91 40 04 	lds	r17, 0x0440	; 0x800440 <ch0+0x8>
     fb6:	84 e0       	ldi	r24, 0x04	; 4
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     fb8:	0f 33       	cpi	r16, 0x3F	; 63
     fba:	18 07       	cpc	r17, r24
     fbc:	e1 f0       	breq	.+56     	; 0xff6 <chVTDoTickI+0x226>
     fbe:	d3 01       	movw	r26, r6
     fc0:	c2 01       	movw	r24, r4
     fc2:	9e cf       	rjmp	.-196    	; 0xf00 <chVTDoTickI+0x130>
     fc4:	9c 01       	movw	r18, r24

        delay = (sysinterval_t)0;
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
     fc6:	ad 01       	movw	r20, r26
     fc8:	24 19       	sub	r18, r4
     fca:	35 09       	sbc	r19, r5
     fcc:	46 09       	sbc	r20, r6
     fce:	57 09       	sbc	r21, r7
     fd0:	b5 01       	movw	r22, r10
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     fd2:	ce 01       	movw	r24, r28
     fd4:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     fd6:	cf 91       	pop	r28
     fd8:	1f 91       	pop	r17
     fda:	0f 91       	pop	r16
     fdc:	ff 90       	pop	r15
     fde:	ef 90       	pop	r14
     fe0:	df 90       	pop	r13
     fe2:	cf 90       	pop	r12
     fe4:	bf 90       	pop	r11
     fe6:	af 90       	pop	r10
     fe8:	9f 90       	pop	r9
     fea:	8f 90       	pop	r8
     fec:	7f 90       	pop	r7
     fee:	6f 90       	pop	r6
     ff0:	5f 90       	pop	r5
     ff2:	4f 90       	pop	r4
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     ff4:	d2 cc       	rjmp	.-1628   	; 0x99a <vt_insert_first.constprop.5>
     ff6:	20 e0       	ldi	r18, 0x00	; 0
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);

        delay = (sysinterval_t)0;
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	a9 01       	movw	r20, r18
     ffc:	e9 cf       	rjmp	.-46     	; 0xfd0 <chVTDoTickI+0x200>

00000ffe <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
    1004:	1f 96       	adiw	r26, 0x0f	; 15
    1006:	8c 91       	ld	r24, X
    1008:	1f 97       	sbiw	r26, 0x0f	; 15
    100a:	84 30       	cpi	r24, 0x04	; 4
    100c:	f1 f1       	breq	.+124    	; 0x108a <__sch_wakeup+0x8c>
    100e:	80 f5       	brcc	.+96     	; 0x1070 <__sch_wakeup+0x72>
    1010:	88 23       	and	r24, r24
    1012:	59 f1       	breq	.+86     	; 0x106a <__sch_wakeup+0x6c>
    1014:	83 30       	cpi	r24, 0x03	; 3
    1016:	31 f4       	brne	.+12     	; 0x1024 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    1018:	52 96       	adiw	r26, 0x12	; 18
    101a:	ed 91       	ld	r30, X+
    101c:	fc 91       	ld	r31, X
    101e:	53 97       	sbiw	r26, 0x13	; 19
    1020:	11 82       	std	Z+1, r1	; 0x01
    1022:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
    1024:	8f ef       	ldi	r24, 0xFF	; 255
    1026:	9f ef       	ldi	r25, 0xFF	; 255
    1028:	53 96       	adiw	r26, 0x13	; 19
    102a:	9c 93       	st	X, r25
    102c:	8e 93       	st	-X, r24
    102e:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    1030:	1f 96       	adiw	r26, 0x0f	; 15
    1032:	1c 92       	st	X, r1
    1034:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
    1036:	1b 96       	adiw	r26, 0x0b	; 11
    1038:	ed 91       	ld	r30, X+
    103a:	fc 91       	ld	r31, X
    103c:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
    103e:	14 96       	adiw	r26, 0x04	; 4
    1040:	9c 91       	ld	r25, X
    1042:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    1044:	01 90       	ld	r0, Z+
    1046:	f0 81       	ld	r31, Z
    1048:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
    104a:	84 81       	ldd	r24, Z+4	; 0x04
    104c:	89 17       	cp	r24, r25
    104e:	d0 f7       	brcc	.-12     	; 0x1044 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
    1050:	11 96       	adiw	r26, 0x01	; 1
    1052:	fc 93       	st	X, r31
    1054:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    1056:	c2 81       	ldd	r28, Z+2	; 0x02
    1058:	d3 81       	ldd	r29, Z+3	; 0x03
    105a:	13 96       	adiw	r26, 0x03	; 3
    105c:	dc 93       	st	X, r29
    105e:	ce 93       	st	-X, r28
    1060:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    1062:	b9 83       	std	Y+1, r27	; 0x01
    1064:	a8 83       	st	Y, r26
  pqp->prev     = p;
    1066:	b3 83       	std	Z+3, r27	; 0x03
    1068:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
    106a:	df 91       	pop	r29
    106c:	cf 91       	pop	r28
    106e:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
    1070:	87 30       	cpi	r24, 0x07	; 7
    1072:	59 f0       	breq	.+22     	; 0x108a <__sch_wakeup+0x8c>
    1074:	8c 30       	cpi	r24, 0x0C	; 12
    1076:	49 f0       	breq	.+18     	; 0x108a <__sch_wakeup+0x8c>
    1078:	85 30       	cpi	r24, 0x05	; 5
    107a:	a1 f6       	brne	.-88     	; 0x1024 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
    107c:	52 96       	adiw	r26, 0x12	; 18
    107e:	ed 91       	ld	r30, X+
    1080:	fc 91       	ld	r31, X
    1082:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
    1084:	84 81       	ldd	r24, Z+4	; 0x04
    1086:	8f 5f       	subi	r24, 0xFF	; 255
    1088:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
    108a:	12 96       	adiw	r26, 0x02	; 2
    108c:	ed 91       	ld	r30, X+
    108e:	fc 91       	ld	r31, X
    1090:	13 97       	sbiw	r26, 0x03	; 3
    1092:	8d 91       	ld	r24, X+
    1094:	9c 91       	ld	r25, X
    1096:	11 97       	sbiw	r26, 0x01	; 1
    1098:	91 83       	std	Z+1, r25	; 0x01
    109a:	80 83       	st	Z, r24
  p->next->prev = p->prev;
    109c:	cd 91       	ld	r28, X+
    109e:	dc 91       	ld	r29, X
    10a0:	11 97       	sbiw	r26, 0x01	; 1
    10a2:	fb 83       	std	Y+3, r31	; 0x03
    10a4:	ea 83       	std	Y+2, r30	; 0x02
    10a6:	be cf       	rjmp	.-132    	; 0x1024 <__sch_wakeup+0x26>

000010a8 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
    10a8:	cf 93       	push	r28
    10aa:	df 93       	push	r29
    10ac:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    10ae:	1f 96       	adiw	r26, 0x0f	; 15
    10b0:	1c 92       	st	X, r1
    10b2:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
    10b4:	1b 96       	adiw	r26, 0x0b	; 11
    10b6:	ed 91       	ld	r30, X+
    10b8:	fc 91       	ld	r31, X
    10ba:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
    10bc:	14 96       	adiw	r26, 0x04	; 4
    10be:	8c 91       	ld	r24, X
    10c0:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    10c2:	01 90       	ld	r0, Z+
    10c4:	f0 81       	ld	r31, Z
    10c6:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
    10c8:	94 81       	ldd	r25, Z+4	; 0x04
    10ca:	98 17       	cp	r25, r24
    10cc:	d0 f7       	brcc	.-12     	; 0x10c2 <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
    10ce:	11 96       	adiw	r26, 0x01	; 1
    10d0:	fc 93       	st	X, r31
    10d2:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    10d4:	c2 81       	ldd	r28, Z+2	; 0x02
    10d6:	d3 81       	ldd	r29, Z+3	; 0x03
    10d8:	13 96       	adiw	r26, 0x03	; 3
    10da:	dc 93       	st	X, r29
    10dc:	ce 93       	st	-X, r28
    10de:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    10e0:	b9 83       	std	Y+1, r27	; 0x01
    10e2:	a8 83       	st	Y, r26
  pqp->prev     = p;
    10e4:	b3 83       	std	Z+3, r27	; 0x03
    10e6:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
    10e8:	cd 01       	movw	r24, r26
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	08 95       	ret

000010f0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
    10f0:	cf 93       	push	r28
    10f2:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
    10f4:	e8 e3       	ldi	r30, 0x38	; 56
    10f6:	f4 e0       	ldi	r31, 0x04	; 4
    10f8:	65 81       	ldd	r22, Z+5	; 0x05
    10fa:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
    10fc:	db 01       	movw	r26, r22
    10fe:	1f 96       	adiw	r26, 0x0f	; 15
    1100:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
    1102:	80 81       	ld	r24, Z
    1104:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
    1106:	ec 01       	movw	r28, r24
    1108:	a8 81       	ld	r26, Y
    110a:	b9 81       	ldd	r27, Y+1	; 0x01
    110c:	b1 83       	std	Z+1, r27	; 0x01
    110e:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
    1110:	13 96       	adiw	r26, 0x03	; 3
    1112:	fc 93       	st	X, r31
    1114:	ee 93       	st	-X, r30
    1116:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
    1118:	21 e0       	ldi	r18, 0x01	; 1
    111a:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
    111c:	96 83       	std	Z+6, r25	; 0x06
    111e:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
    1120:	09 d5       	rcall	.+2578   	; 0x1b34 <_port_switch>
}
    1122:	df 91       	pop	r29
    1124:	cf 91       	pop	r28
    1126:	08 95       	ret

00001128 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
    1128:	df 92       	push	r13
    112a:	ef 92       	push	r14
    112c:	ff 92       	push	r15
    112e:	0f 93       	push	r16
    1130:	1f 93       	push	r17
    1132:	cf 93       	push	r28
    1134:	df 93       	push	r29
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	60 97       	sbiw	r28, 0x10	; 16
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	de bf       	out	0x3e, r29	; 62
    1142:	0f be       	out	0x3f, r0	; 63
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	d8 2e       	mov	r13, r24
  thread_t *tp = __instance_get_currthread(currcore);
    1148:	e0 90 3d 04 	lds	r14, 0x043D	; 0x80043d <ch0+0x5>
    114c:	f0 90 3e 04 	lds	r15, 0x043E	; 0x80043e <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
    1150:	4f 3f       	cpi	r20, 0xFF	; 255
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	58 07       	cpc	r21, r24
    1156:	68 07       	cpc	r22, r24
    1158:	78 07       	cpc	r23, r24
    115a:	01 f1       	breq	.+64     	; 0x119c <chSchGoSleepTimeoutS+0x74>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
    115c:	87 01       	movw	r16, r14
    115e:	2f ef       	ldi	r18, 0xFF	; 255
    1160:	37 e0       	ldi	r19, 0x07	; 7
    1162:	ce 01       	movw	r24, r28
    1164:	01 96       	adiw	r24, 0x01	; 1
    1166:	9b dd       	rcall	.-1226   	; 0xc9e <chVTDoSetI>
    chSchGoSleepS(newstate);
    1168:	8d 2d       	mov	r24, r13
    116a:	c2 df       	rcall	.-124    	; 0x10f0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
    116c:	89 81       	ldd	r24, Y+1	; 0x01
    116e:	9a 81       	ldd	r25, Y+2	; 0x02
    1170:	89 2b       	or	r24, r25
    1172:	19 f0       	breq	.+6      	; 0x117a <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
    1174:	ce 01       	movw	r24, r28
    1176:	01 96       	adiw	r24, 0x01	; 1
    1178:	a0 dd       	rcall	.-1216   	; 0xcba <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
    117a:	f7 01       	movw	r30, r14
    117c:	82 89       	ldd	r24, Z+18	; 0x12
    117e:	93 89       	ldd	r25, Z+19	; 0x13
    1180:	60 96       	adiw	r28, 0x10	; 16
    1182:	0f b6       	in	r0, 0x3f	; 63
    1184:	f8 94       	cli
    1186:	de bf       	out	0x3e, r29	; 62
    1188:	0f be       	out	0x3f, r0	; 63
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	df 90       	pop	r13
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
    119a:	08 95       	ret
    119c:	8d 2d       	mov	r24, r13
    119e:	a8 df       	rcall	.-176    	; 0x10f0 <chSchGoSleepS>
    11a0:	ec cf       	rjmp	.-40     	; 0x117a <chSchGoSleepTimeoutS+0x52>

000011a2 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
    11a8:	c0 91 3d 04 	lds	r28, 0x043D	; 0x80043d <ch0+0x5>
    11ac:	d0 91 3e 04 	lds	r29, 0x043E	; 0x80043e <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
    11b0:	53 96       	adiw	r26, 0x13	; 19
    11b2:	7c 93       	st	X, r23
    11b4:	6e 93       	st	-X, r22
    11b6:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
    11b8:	14 96       	adiw	r26, 0x04	; 4
    11ba:	2c 91       	ld	r18, X
    11bc:	14 97       	sbiw	r26, 0x04	; 4
    11be:	9c 81       	ldd	r25, Y+4	; 0x04
    11c0:	92 17       	cp	r25, r18
    11c2:	e8 f0       	brcs	.+58     	; 0x11fe <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    11c4:	1f 96       	adiw	r26, 0x0f	; 15
    11c6:	1c 92       	st	X, r1
    11c8:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
    11ca:	1b 96       	adiw	r26, 0x0b	; 11
    11cc:	ed 91       	ld	r30, X+
    11ce:	fc 91       	ld	r31, X
    11d0:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    11d2:	01 90       	ld	r0, Z+
    11d4:	f0 81       	ld	r31, Z
    11d6:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
    11d8:	84 81       	ldd	r24, Z+4	; 0x04
    11da:	82 17       	cp	r24, r18
    11dc:	d0 f7       	brcc	.-12     	; 0x11d2 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
    11de:	11 96       	adiw	r26, 0x01	; 1
    11e0:	fc 93       	st	X, r31
    11e2:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    11e4:	c2 81       	ldd	r28, Z+2	; 0x02
    11e6:	d3 81       	ldd	r29, Z+3	; 0x03
    11e8:	13 96       	adiw	r26, 0x03	; 3
    11ea:	dc 93       	st	X, r29
    11ec:	ce 93       	st	-X, r28
    11ee:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    11f0:	b9 83       	std	Y+1, r27	; 0x01
    11f2:	a8 83       	st	Y, r26
  pqp->prev     = p;
    11f4:	b3 83       	std	Z+3, r27	; 0x03
    11f6:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    11fe:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
    1200:	eb 85       	ldd	r30, Y+11	; 0x0b
    1202:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    1204:	01 90       	ld	r0, Z+
    1206:	f0 81       	ld	r31, Z
    1208:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
    120a:	84 81       	ldd	r24, Z+4	; 0x04
    120c:	98 17       	cp	r25, r24
    120e:	d0 f3       	brcs	.-12     	; 0x1204 <chSchWakeupS+0x62>
    1210:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
    1212:	f9 83       	std	Y+1, r31	; 0x01
    1214:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
    1216:	a2 81       	ldd	r26, Z+2	; 0x02
    1218:	b3 81       	ldd	r27, Z+3	; 0x03
    121a:	bb 83       	std	Y+3, r27	; 0x03
    121c:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
    121e:	cd 93       	st	X+, r28
    1220:	dc 93       	st	X, r29
  pqp->prev     = p;
    1222:	d3 83       	std	Z+3, r29	; 0x03
    1224:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
    1226:	21 e0       	ldi	r18, 0x01	; 1
    1228:	fc 01       	movw	r30, r24
    122a:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
    122c:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <ch0+0x6>
    1230:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    1234:	be 01       	movw	r22, r28
    1236:	7e d4       	rcall	.+2300   	; 0x1b34 <_port_switch>
  }
}
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	08 95       	ret

0000123e <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
    123e:	a0 91 38 04 	lds	r26, 0x0438	; 0x800438 <ch0>
    1242:	b0 91 39 04 	lds	r27, 0x0439	; 0x800439 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
    1246:	e0 91 3d 04 	lds	r30, 0x043D	; 0x80043d <ch0+0x5>
    124a:	f0 91 3e 04 	lds	r31, 0x043E	; 0x80043e <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	14 96       	adiw	r26, 0x04	; 4
    1252:	2c 91       	ld	r18, X
    1254:	94 81       	ldd	r25, Z+4	; 0x04
    1256:	92 17       	cp	r25, r18
    1258:	08 f0       	brcs	.+2      	; 0x125c <chSchIsPreemptionRequired+0x1e>
    125a:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
    125c:	08 95       	ret

0000125e <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
    1262:	a0 91 3d 04 	lds	r26, 0x043D	; 0x80043d <ch0+0x5>
    1266:	b0 91 3e 04 	lds	r27, 0x043E	; 0x80043e <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
    126a:	40 91 38 04 	lds	r20, 0x0438	; 0x800438 <ch0>
    126e:	50 91 39 04 	lds	r21, 0x0439	; 0x800439 <ch0+0x1>

  pqp->next       = p->next;
    1272:	ea 01       	movw	r28, r20
    1274:	e8 81       	ld	r30, Y
    1276:	f9 81       	ldd	r31, Y+1	; 0x01
    1278:	f0 93 39 04 	sts	0x0439, r31	; 0x800439 <ch0+0x1>
    127c:	e0 93 38 04 	sts	0x0438, r30	; 0x800438 <ch0>
  pqp->next->prev = pqp;
    1280:	88 e3       	ldi	r24, 0x38	; 56
    1282:	94 e0       	ldi	r25, 0x04	; 4
    1284:	93 83       	std	Z+3, r25	; 0x03
    1286:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
    128c:	50 93 3e 04 	sts	0x043E, r21	; 0x80043e <ch0+0x6>
    1290:	40 93 3d 04 	sts	0x043D, r20	; 0x80043d <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    1294:	1f 96       	adiw	r26, 0x0f	; 15
    1296:	1c 92       	st	X, r1
    1298:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
    129a:	1b 96       	adiw	r26, 0x0b	; 11
    129c:	ed 91       	ld	r30, X+
    129e:	fc 91       	ld	r31, X
    12a0:	1c 97       	sbiw	r26, 0x0c	; 12
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
    12a2:	14 96       	adiw	r26, 0x04	; 4
    12a4:	2c 91       	ld	r18, X
    12a6:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    12a8:	01 90       	ld	r0, Z+
    12aa:	f0 81       	ld	r31, Z
    12ac:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
    12ae:	94 81       	ldd	r25, Z+4	; 0x04
    12b0:	29 17       	cp	r18, r25
    12b2:	d0 f3       	brcs	.-12     	; 0x12a8 <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
    12b4:	11 96       	adiw	r26, 0x01	; 1
    12b6:	fc 93       	st	X, r31
    12b8:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    12ba:	82 81       	ldd	r24, Z+2	; 0x02
    12bc:	93 81       	ldd	r25, Z+3	; 0x03
    12be:	13 96       	adiw	r26, 0x03	; 3
    12c0:	9c 93       	st	X, r25
    12c2:	8e 93       	st	-X, r24
    12c4:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    12c6:	ec 01       	movw	r28, r24
    12c8:	b9 83       	std	Y+1, r27	; 0x01
    12ca:	a8 83       	st	Y, r26
  pqp->prev     = p;
    12cc:	b3 83       	std	Z+3, r27	; 0x03
    12ce:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
    12d0:	bd 01       	movw	r22, r26
    12d2:	ca 01       	movw	r24, r20
    12d4:	2f d4       	rcall	.+2142   	; 0x1b34 <_port_switch>
}
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	08 95       	ret

000012dc <chSchRescheduleS>:

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
    12dc:	a0 91 38 04 	lds	r26, 0x0438	; 0x800438 <ch0>
    12e0:	b0 91 39 04 	lds	r27, 0x0439	; 0x800439 <ch0+0x1>
    12e4:	e0 91 3d 04 	lds	r30, 0x043D	; 0x80043d <ch0+0x5>
    12e8:	f0 91 3e 04 	lds	r31, 0x043E	; 0x80043e <ch0+0x6>
    12ec:	14 96       	adiw	r26, 0x04	; 4
    12ee:	9c 91       	ld	r25, X
    12f0:	84 81       	ldd	r24, Z+4	; 0x04
    12f2:	89 17       	cp	r24, r25
    12f4:	08 f0       	brcs	.+2      	; 0x12f8 <chSchRescheduleS+0x1c>
    __sch_reschedule_ahead();
  }
}
    12f6:	08 95       	ret
  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
    __sch_reschedule_ahead();
    12f8:	b2 cf       	rjmp	.-156    	; 0x125e <chSchDoPreemption>

000012fa <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
    12fa:	ff cf       	rjmp	.-2      	; 0x12fa <__idle_thread>

000012fc <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
    12fc:	cf 92       	push	r12
    12fe:	df 92       	push	r13
    1300:	ff 92       	push	r15
    1302:	0f 93       	push	r16
    1304:	1f 93       	push	r17
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	cd b7       	in	r28, 0x3d	; 61
    130c:	de b7       	in	r29, 0x3e	; 62
    130e:	2b 97       	sbiw	r28, 0x0b	; 11
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	de bf       	out	0x3e, r29	; 62
    1316:	0f be       	out	0x3f, r0	; 63
    1318:	cd bf       	out	0x3d, r28	; 61
    131a:	8c 01       	movw	r16, r24
    131c:	6b 01       	movw	r12, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
    131e:	90 93 37 04 	sts	0x0437, r25	; 0x800437 <ch_system+0x2>
    1322:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
    1326:	fc 01       	movw	r30, r24
    1328:	16 8e       	std	Z+30, r1	; 0x1e
    132a:	15 8e       	std	Z+29, r1	; 0x1d

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
    132c:	74 a3       	std	Z+36, r23	; 0x24
    132e:	63 a3       	std	Z+35, r22	; 0x23

  /* Port initialization for the current instance.*/
  port_init(oip);
    1330:	ff 24       	eor	r15, r15
    1332:	f3 94       	inc	r15
    1334:	f0 92 81 04 	sts	0x0481, r15	; 0x800481 <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
    1338:	91 83       	std	Z+1, r25	; 0x01
    133a:	80 83       	st	Z, r24
  pqp->prev = pqp;
    133c:	93 83       	std	Z+3, r25	; 0x03
    133e:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
    1340:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
    1342:	49 96       	adiw	r24, 0x19	; 25
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
    1344:	92 8f       	std	Z+26, r25	; 0x1a
    1346:	81 8f       	std	Z+25, r24	; 0x19
  qp->prev = qp;
    1348:	94 8f       	std	Z+28, r25	; 0x1c
    134a:	83 8f       	std	Z+27, r24	; 0x1b
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
    134c:	17 8e       	std	Z+31, r1	; 0x1f
    134e:	10 a2       	std	Z+32, r1	; 0x20
    1350:	11 a2       	std	Z+33, r1	; 0x21
    1352:	12 a2       	std	Z+34, r1	; 0x22
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
    1354:	42 97       	sbiw	r24, 0x12	; 18
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
    1356:	90 87       	std	Z+8, r25	; 0x08
    1358:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
    135a:	92 87       	std	Z+10, r25	; 0x0a
    135c:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
    135e:	8f ef       	ldi	r24, 0xFF	; 255
    1360:	9f ef       	ldi	r25, 0xFF	; 255
    1362:	dc 01       	movw	r26, r24
    1364:	83 87       	std	Z+11, r24	; 0x0b
    1366:	94 87       	std	Z+12, r25	; 0x0c
    1368:	a5 87       	std	Z+13, r26	; 0x0d
    136a:	b6 87       	std	Z+14, r27	; 0x0e
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
    136c:	10 8a       	std	Z+16, r1	; 0x10
    136e:	17 86       	std	Z+15, r1	; 0x0f
    1370:	0e 94 6b 00 	call	0xd6	; 0xd6 <stGetCounter>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
    1374:	9c 01       	movw	r18, r24
    1376:	f8 01       	movw	r30, r16
    1378:	21 8b       	std	Z+17, r18	; 0x11
    137a:	32 8b       	std	Z+18, r19	; 0x12
    137c:	13 8a       	std	Z+19, r1	; 0x13
    137e:	14 8a       	std	Z+20, r1	; 0x14
    1380:	15 8a       	std	Z+21, r1	; 0x15
    1382:	16 8a       	std	Z+22, r1	; 0x16
    1384:	17 8a       	std	Z+23, r1	; 0x17
    1386:	10 8e       	std	Z+24, r1	; 0x18
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
    1388:	ed 5b       	subi	r30, 0xBD	; 189
    138a:	ff 4f       	sbci	r31, 0xFF	; 255
    138c:	11 82       	std	Z+1, r1	; 0x01
    138e:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
    1390:	b8 01       	movw	r22, r16
    1392:	6b 5d       	subi	r22, 0xDB	; 219
    1394:	7f 4f       	sbci	r23, 0xFF	; 255
    1396:	20 e8       	ldi	r18, 0x80	; 128
    1398:	4f e2       	ldi	r20, 0x2F	; 47
    139a:	51 e0       	ldi	r21, 0x01	; 1
    139c:	c8 01       	movw	r24, r16
    139e:	2a d0       	rcall	.+84     	; 0x13f4 <__thd_object_init>
    13a0:	f8 01       	movw	r30, r16
    13a2:	96 83       	std	Z+6, r25	; 0x06
    13a4:	85 83       	std	Z+5, r24	; 0x05
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
    13a6:	fc 01       	movw	r30, r24
    13a8:	f7 86       	std	Z+15, r15	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
    13aa:	83 e2       	ldi	r24, 0x23	; 35
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	9a 83       	std	Y+2, r25	; 0x02
    13b0:	89 83       	std	Y+1, r24	; 0x01
    13b2:	f6 01       	movw	r30, r12
    13b4:	82 81       	ldd	r24, Z+2	; 0x02
    13b6:	93 81       	ldd	r25, Z+3	; 0x03
    13b8:	9c 83       	std	Y+4, r25	; 0x04
    13ba:	8b 83       	std	Y+3, r24	; 0x03
    13bc:	84 81       	ldd	r24, Z+4	; 0x04
    13be:	95 81       	ldd	r25, Z+5	; 0x05
    13c0:	9e 83       	std	Y+6, r25	; 0x06
    13c2:	8d 83       	std	Y+5, r24	; 0x05
    13c4:	ff 82       	std	Y+7, r15	; 0x07
    13c6:	8d e7       	ldi	r24, 0x7D	; 125
    13c8:	99 e0       	ldi	r25, 0x09	; 9
    13ca:	99 87       	std	Y+9, r25	; 0x09
    13cc:	88 87       	std	Y+8, r24	; 0x08
    13ce:	1b 86       	std	Y+11, r1	; 0x0b
    13d0:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
    13d2:	ce 01       	movw	r24, r28
    13d4:	01 96       	adiw	r24, 0x01	; 1
    13d6:	9e d0       	rcall	.+316    	; 0x1514 <chThdCreateI>
  }
#endif
}
    13d8:	2b 96       	adiw	r28, 0x0b	; 11
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	de bf       	out	0x3e, r29	; 62
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	cd bf       	out	0x3d, r28	; 61
    13e4:	df 91       	pop	r29
    13e6:	cf 91       	pop	r28
    13e8:	1f 91       	pop	r17
    13ea:	0f 91       	pop	r16
    13ec:	ff 90       	pop	r15
    13ee:	df 90       	pop	r13
    13f0:	cf 90       	pop	r12
    13f2:	08 95       	ret

000013f4 <__thd_object_init>:
void chThdResume(thread_reference_t *trp, msg_t msg) {

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
    13f8:	fb 01       	movw	r30, r22
    13fa:	24 83       	std	Z+4, r18	; 0x04
    13fc:	32 e0       	ldi	r19, 0x02	; 2
    13fe:	37 87       	std	Z+15, r19	; 0x0f
    1400:	10 8a       	std	Z+16, r1	; 0x10
    1402:	94 87       	std	Z+12, r25	; 0x0c
    1404:	83 87       	std	Z+11, r24	; 0x0b
    1406:	25 8f       	std	Z+29, r18	; 0x1d
    1408:	14 8e       	std	Z+28, r1	; 0x1c
    140a:	13 8e       	std	Z+27, r1	; 0x1b
    140c:	12 8e       	std	Z+26, r1	; 0x1a
    140e:	21 e0       	ldi	r18, 0x01	; 1
    1410:	21 8b       	std	Z+17, r18	; 0x11
    1412:	56 87       	std	Z+14, r21	; 0x0e
    1414:	45 87       	std	Z+13, r20	; 0x0d
    1416:	9b 01       	movw	r18, r22
    1418:	29 5f       	subi	r18, 0xF9	; 249
    141a:	3f 4f       	sbci	r19, 0xFF	; 255
    141c:	ac 01       	movw	r20, r24
    141e:	47 5e       	subi	r20, 0xE7	; 231
    1420:	5f 4f       	sbci	r21, 0xFF	; 255
    1422:	50 87       	std	Z+8, r21	; 0x08
    1424:	47 83       	std	Z+7, r20	; 0x07
    1426:	ec 01       	movw	r28, r24
    1428:	ab 8d       	ldd	r26, Y+27	; 0x1b
    142a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    142c:	b2 87       	std	Z+10, r27	; 0x0a
    142e:	a1 87       	std	Z+9, r26	; 0x09
    1430:	2d 93       	st	X+, r18
    1432:	3c 93       	st	X, r19
    1434:	3c 8f       	std	Y+28, r19	; 0x1c
    1436:	2b 8f       	std	Y+27, r18	; 0x1b
    1438:	cb 01       	movw	r24, r22
    143a:	44 96       	adiw	r24, 0x14	; 20
    143c:	95 8b       	std	Z+21, r25	; 0x15
    143e:	84 8b       	std	Z+20, r24	; 0x14
    1440:	02 96       	adiw	r24, 0x02	; 2
    1442:	97 8b       	std	Z+23, r25	; 0x17
    1444:	86 8b       	std	Z+22, r24	; 0x16
    1446:	91 8f       	std	Z+25, r25	; 0x19
    1448:	80 8f       	std	Z+24, r24	; 0x18
    144a:	cb 01       	movw	r24, r22
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	08 95       	ret

00001452 <chThdCreateSuspendedI>:
    1452:	cf 93       	push	r28
    1454:	df 93       	push	r29
    1456:	dc 01       	movw	r26, r24
    1458:	14 96       	adiw	r26, 0x04	; 4
    145a:	2d 91       	ld	r18, X+
    145c:	3c 91       	ld	r19, X
    145e:	15 97       	sbiw	r26, 0x05	; 5
    1460:	f9 01       	movw	r30, r18
    1462:	7e 97       	sbiw	r30, 0x1e	; 30
    1464:	e9 01       	movw	r28, r18
    1466:	e3 97       	sbiw	r28, 0x33	; 51
    1468:	d6 83       	std	Z+6, r29	; 0x06
    146a:	c5 83       	std	Z+5, r28	; 0x05
    146c:	17 96       	adiw	r26, 0x07	; 7
    146e:	9c 91       	ld	r25, X
    1470:	17 97       	sbiw	r26, 0x07	; 7
    1472:	18 96       	adiw	r26, 0x08	; 8
    1474:	8c 91       	ld	r24, X
    1476:	18 97       	sbiw	r26, 0x08	; 8
    1478:	9a 8b       	std	Y+18, r25	; 0x12
    147a:	89 8b       	std	Y+17, r24	; 0x11
    147c:	19 96       	adiw	r26, 0x09	; 9
    147e:	9c 91       	ld	r25, X
    1480:	19 97       	sbiw	r26, 0x09	; 9
    1482:	1a 96       	adiw	r26, 0x0a	; 10
    1484:	8c 91       	ld	r24, X
    1486:	1a 97       	sbiw	r26, 0x0a	; 10
    1488:	98 8b       	std	Y+16, r25	; 0x10
    148a:	8f 87       	std	Y+15, r24	; 0x0f
    148c:	89 ec       	ldi	r24, 0xC9	; 201
    148e:	9d e0       	ldi	r25, 0x0D	; 13
    1490:	9b 8b       	std	Y+19, r25	; 0x13
    1492:	8c 8b       	std	Y+20, r24	; 0x14
    1494:	16 96       	adiw	r26, 0x06	; 6
    1496:	8c 91       	ld	r24, X
    1498:	16 97       	sbiw	r26, 0x06	; 6
    149a:	4d 91       	ld	r20, X+
    149c:	5c 91       	ld	r21, X
    149e:	84 83       	std	Z+4, r24	; 0x04
    14a0:	92 e0       	ldi	r25, 0x02	; 2
    14a2:	97 87       	std	Z+15, r25	; 0x0f
    14a4:	10 8a       	std	Z+16, r1	; 0x10
    14a6:	68 e3       	ldi	r22, 0x38	; 56
    14a8:	74 e0       	ldi	r23, 0x04	; 4
    14aa:	74 87       	std	Z+12, r23	; 0x0c
    14ac:	63 87       	std	Z+11, r22	; 0x0b
    14ae:	85 8f       	std	Z+29, r24	; 0x1d
    14b0:	14 8e       	std	Z+28, r1	; 0x1c
    14b2:	13 8e       	std	Z+27, r1	; 0x1b
    14b4:	12 8e       	std	Z+26, r1	; 0x1a
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	81 8b       	std	Z+17, r24	; 0x11
    14ba:	56 87       	std	Z+14, r21	; 0x0e
    14bc:	45 87       	std	Z+13, r20	; 0x0d
    14be:	d9 01       	movw	r26, r18
    14c0:	57 97       	sbiw	r26, 0x17	; 23
    14c2:	81 e5       	ldi	r24, 0x51	; 81
    14c4:	94 e0       	ldi	r25, 0x04	; 4
    14c6:	11 96       	adiw	r26, 0x01	; 1
    14c8:	9c 93       	st	X, r25
    14ca:	8e 93       	st	-X, r24
    14cc:	eb 01       	movw	r28, r22
    14ce:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14d0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14d2:	13 96       	adiw	r26, 0x03	; 3
    14d4:	9c 93       	st	X, r25
    14d6:	8e 93       	st	-X, r24
    14d8:	12 97       	sbiw	r26, 0x02	; 2
    14da:	ec 01       	movw	r28, r24
    14dc:	b9 83       	std	Y+1, r27	; 0x01
    14de:	a8 83       	st	Y, r26
    14e0:	eb 01       	movw	r28, r22
    14e2:	bc 8f       	std	Y+28, r27	; 0x1c
    14e4:	ab 8f       	std	Y+27, r26	; 0x1b
    14e6:	1d 96       	adiw	r26, 0x0d	; 13
    14e8:	0b 2e       	mov	r0, r27
    14ea:	11 96       	adiw	r26, 0x01	; 1
    14ec:	0c 92       	st	X, r0
    14ee:	11 97       	sbiw	r26, 0x01	; 1
    14f0:	ac 93       	st	X, r26
    14f2:	12 96       	adiw	r26, 0x02	; 2
    14f4:	0b 2e       	mov	r0, r27
    14f6:	11 96       	adiw	r26, 0x01	; 1
    14f8:	0c 92       	st	X, r0
    14fa:	11 97       	sbiw	r26, 0x01	; 1
    14fc:	ac 93       	st	X, r26
    14fe:	0a 2e       	mov	r0, r26
    1500:	1b 2e       	mov	r1, r27
    1502:	13 96       	adiw	r26, 0x03	; 3
    1504:	1c 92       	st	X, r1
    1506:	0e 92       	st	-X, r0
    1508:	11 24       	eor	r1, r1
    150a:	12 97       	sbiw	r26, 0x02	; 2
    150c:	cf 01       	movw	r24, r30
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	08 95       	ret

00001514 <chThdCreateI>:
    1514:	9e df       	rcall	.-196    	; 0x1452 <chThdCreateSuspendedI>
    1516:	c8 cd       	rjmp	.-1136   	; 0x10a8 <chSchReadyI>

00001518 <chThdCreateStatic>:
    1518:	0f 93       	push	r16
    151a:	1f 93       	push	r17
    151c:	cf 93       	push	r28
    151e:	df 93       	push	r29
    1520:	f8 94       	cli
    1522:	6e 51       	subi	r22, 0x1E	; 30
    1524:	71 09       	sbc	r23, r1
    1526:	ec 01       	movw	r28, r24
    1528:	c6 0f       	add	r28, r22
    152a:	d7 1f       	adc	r29, r23
    152c:	fe 01       	movw	r30, r28
    152e:	75 97       	sbiw	r30, 0x15	; 21
    1530:	fe 83       	std	Y+6, r31	; 0x06
    1532:	ed 83       	std	Y+5, r30	; 0x05
    1534:	22 8b       	std	Z+18, r18	; 0x12
    1536:	31 8b       	std	Z+17, r19	; 0x11
    1538:	00 8b       	std	Z+16, r16	; 0x10
    153a:	17 87       	std	Z+15, r17	; 0x0f
    153c:	89 ec       	ldi	r24, 0xC9	; 201
    153e:	9d e0       	ldi	r25, 0x0D	; 13
    1540:	93 8b       	std	Z+19, r25	; 0x13
    1542:	84 8b       	std	Z+20, r24	; 0x14
    1544:	4c 83       	std	Y+4, r20	; 0x04
    1546:	82 e0       	ldi	r24, 0x02	; 2
    1548:	8f 87       	std	Y+15, r24	; 0x0f
    154a:	18 8a       	std	Y+16, r1	; 0x10
    154c:	e8 e3       	ldi	r30, 0x38	; 56
    154e:	f4 e0       	ldi	r31, 0x04	; 4
    1550:	fc 87       	std	Y+12, r31	; 0x0c
    1552:	eb 87       	std	Y+11, r30	; 0x0b
    1554:	4d 8f       	std	Y+29, r20	; 0x1d
    1556:	1c 8e       	std	Y+28, r1	; 0x1c
    1558:	1b 8e       	std	Y+27, r1	; 0x1b
    155a:	1a 8e       	std	Y+26, r1	; 0x1a
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	89 8b       	std	Y+17, r24	; 0x11
    1560:	88 e2       	ldi	r24, 0x28	; 40
    1562:	91 e0       	ldi	r25, 0x01	; 1
    1564:	9e 87       	std	Y+14, r25	; 0x0e
    1566:	8d 87       	std	Y+13, r24	; 0x0d
    1568:	ce 01       	movw	r24, r28
    156a:	07 96       	adiw	r24, 0x07	; 7
    156c:	21 e5       	ldi	r18, 0x51	; 81
    156e:	34 e0       	ldi	r19, 0x04	; 4
    1570:	38 87       	std	Y+8, r19	; 0x08
    1572:	2f 83       	std	Y+7, r18	; 0x07
    1574:	a3 8d       	ldd	r26, Z+27	; 0x1b
    1576:	b4 8d       	ldd	r27, Z+28	; 0x1c
    1578:	ba 87       	std	Y+10, r27	; 0x0a
    157a:	a9 87       	std	Y+9, r26	; 0x09
    157c:	8d 93       	st	X+, r24
    157e:	9c 93       	st	X, r25
    1580:	94 8f       	std	Z+28, r25	; 0x1c
    1582:	83 8f       	std	Z+27, r24	; 0x1b
    1584:	0d 96       	adiw	r24, 0x0d	; 13
    1586:	9d 8b       	std	Y+21, r25	; 0x15
    1588:	8c 8b       	std	Y+20, r24	; 0x14
    158a:	02 96       	adiw	r24, 0x02	; 2
    158c:	9f 8b       	std	Y+23, r25	; 0x17
    158e:	8e 8b       	std	Y+22, r24	; 0x16
    1590:	99 8f       	std	Y+25, r25	; 0x19
    1592:	88 8f       	std	Y+24, r24	; 0x18
    1594:	70 e0       	ldi	r23, 0x00	; 0
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	ce 01       	movw	r24, r28
    159a:	03 de       	rcall	.-1018   	; 0x11a2 <chSchWakeupS>
    159c:	78 94       	sei
    159e:	ce 01       	movw	r24, r28
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	08 95       	ret

000015aa <chThdExitS>:
    15aa:	0f 93       	push	r16
    15ac:	1f 93       	push	r17
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
    15b2:	c0 91 3d 04 	lds	r28, 0x043D	; 0x80043d <ch0+0x5>
    15b6:	d0 91 3e 04 	lds	r29, 0x043E	; 0x80043e <ch0+0x6>
    15ba:	9b 8b       	std	Y+19, r25	; 0x13
    15bc:	8a 8b       	std	Y+18, r24	; 0x12
    15be:	8e 01       	movw	r16, r28
    15c0:	0c 5e       	subi	r16, 0xEC	; 236
    15c2:	1f 4f       	sbci	r17, 0xFF	; 255
    15c4:	8c 89       	ldd	r24, Y+20	; 0x14
    15c6:	9d 89       	ldd	r25, Y+21	; 0x15
    15c8:	08 17       	cp	r16, r24
    15ca:	19 07       	cpc	r17, r25
    15cc:	59 f0       	breq	.+22     	; 0x15e4 <chThdExitS+0x3a>
    15ce:	fc 01       	movw	r30, r24
    15d0:	20 81       	ld	r18, Z
    15d2:	31 81       	ldd	r19, Z+1	; 0x01
    15d4:	3d 8b       	std	Y+21, r19	; 0x15
    15d6:	2c 8b       	std	Y+20, r18	; 0x14
    15d8:	67 dd       	rcall	.-1330   	; 0x10a8 <chSchReadyI>
    15da:	8c 89       	ldd	r24, Y+20	; 0x14
    15dc:	9d 89       	ldd	r25, Y+21	; 0x15
    15de:	80 17       	cp	r24, r16
    15e0:	91 07       	cpc	r25, r17
    15e2:	a9 f7       	brne	.-22     	; 0x15ce <chThdExitS+0x24>
    15e4:	89 89       	ldd	r24, Y+17	; 0x11
    15e6:	81 11       	cpse	r24, r1
    15e8:	0c c0       	rjmp	.+24     	; 0x1602 <chThdExitS+0x58>
    15ea:	e9 85       	ldd	r30, Y+9	; 0x09
    15ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    15ee:	8f 81       	ldd	r24, Y+7	; 0x07
    15f0:	98 85       	ldd	r25, Y+8	; 0x08
    15f2:	91 83       	std	Z+1, r25	; 0x01
    15f4:	80 83       	st	Z, r24
    15f6:	af 81       	ldd	r26, Y+7	; 0x07
    15f8:	b8 85       	ldd	r27, Y+8	; 0x08
    15fa:	13 96       	adiw	r26, 0x03	; 3
    15fc:	fc 93       	st	X, r31
    15fe:	ee 93       	st	-X, r30
    1600:	12 97       	sbiw	r26, 0x02	; 2
    1602:	8f e0       	ldi	r24, 0x0F	; 15
    1604:	df 91       	pop	r29
    1606:	cf 91       	pop	r28
    1608:	1f 91       	pop	r17
    160a:	0f 91       	pop	r16
    160c:	71 cd       	rjmp	.-1310   	; 0x10f0 <chSchGoSleepS>

0000160e <chThdExit>:
    160e:	f8 94       	cli
    1610:	cc cf       	rjmp	.-104    	; 0x15aa <chThdExitS>

00001612 <chThdSleep>:
    1612:	ab 01       	movw	r20, r22
    1614:	bc 01       	movw	r22, r24
    1616:	f8 94       	cli
    1618:	88 e0       	ldi	r24, 0x08	; 8
    161a:	86 dd       	rcall	.-1268   	; 0x1128 <chSchGoSleepTimeoutS>
    161c:	78 94       	sei
    161e:	08 95       	ret

00001620 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    1624:	e0 91 3d 04 	lds	r30, 0x043D	; 0x80043d <ch0+0x5>
    1628:	f0 91 3e 04 	lds	r31, 0x043E	; 0x80043e <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    162c:	41 15       	cp	r20, r1
    162e:	51 05       	cpc	r21, r1
    1630:	61 05       	cpc	r22, r1
    1632:	71 05       	cpc	r23, r1
    1634:	79 f0       	breq	.+30     	; 0x1654 <chThdEnqueueTimeoutS+0x34>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    1636:	91 83       	std	Z+1, r25	; 0x01
    1638:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    163a:	ec 01       	movw	r28, r24
    163c:	aa 81       	ldd	r26, Y+2	; 0x02
    163e:	bb 81       	ldd	r27, Y+3	; 0x03
    1640:	b3 83       	std	Z+3, r27	; 0x03
    1642:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    1644:	ed 93       	st	X+, r30
    1646:	fc 93       	st	X, r31
  qp->prev      = p;
    1648:	fb 83       	std	Y+3, r31	; 0x03
    164a:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    164c:	84 e0       	ldi	r24, 0x04	; 4
}
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1652:	6a cd       	rjmp	.-1324   	; 0x1128 <chSchGoSleepTimeoutS>
}
    1654:	8f ef       	ldi	r24, 0xFF	; 255
    1656:	9f ef       	ldi	r25, 0xFF	; 255
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	08 95       	ret

0000165e <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    165e:	cf 93       	push	r28
    1660:	df 93       	push	r29
    1662:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1664:	80 81       	ld	r24, Z
    1666:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    1668:	e8 17       	cp	r30, r24
    166a:	f9 07       	cpc	r31, r25
    166c:	71 f0       	breq	.+28     	; 0x168a <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    166e:	ec 01       	movw	r28, r24
    1670:	a8 81       	ld	r26, Y
    1672:	b9 81       	ldd	r27, Y+1	; 0x01
    1674:	b1 83       	std	Z+1, r27	; 0x01
    1676:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    1678:	13 96       	adiw	r26, 0x03	; 3
    167a:	fc 93       	st	X, r31
    167c:	ee 93       	st	-X, r30
    167e:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1680:	7b 8b       	std	Y+19, r23	; 0x13
    1682:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    1688:	0f cd       	rjmp	.-1506   	; 0x10a8 <chSchReadyI>
    168a:	df 91       	pop	r29
    168c:	cf 91       	pop	r28
    168e:	08 95       	ret

00001690 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1690:	fc 01       	movw	r30, r24
    1692:	91 83       	std	Z+1, r25	; 0x01
    1694:	80 83       	st	Z, r24
    1696:	93 83       	std	Z+3, r25	; 0x03
    1698:	82 83       	std	Z+2, r24	; 0x02
    169a:	15 82       	std	Z+5, r1	; 0x05
    169c:	14 82       	std	Z+4, r1	; 0x04
    169e:	08 95       	ret

000016a0 <chMtxLockS>:
    16a0:	0f 93       	push	r16
    16a2:	1f 93       	push	r17
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	ec 01       	movw	r28, r24
    16aa:	00 91 3d 04 	lds	r16, 0x043D	; 0x80043d <ch0+0x5>
    16ae:	10 91 3e 04 	lds	r17, 0x043E	; 0x80043e <ch0+0x6>
    16b2:	ec 81       	ldd	r30, Y+4	; 0x04
    16b4:	fd 81       	ldd	r31, Y+5	; 0x05
    16b6:	30 97       	sbiw	r30, 0x00	; 0
    16b8:	09 f4       	brne	.+2      	; 0x16bc <chMtxLockS+0x1c>
    16ba:	7e c0       	rjmp	.+252    	; 0x17b8 <chMtxLockS+0x118>
    16bc:	d8 01       	movw	r26, r16
    16be:	14 96       	adiw	r26, 0x04	; 4
    16c0:	8c 91       	ld	r24, X
    16c2:	94 81       	ldd	r25, Z+4	; 0x04
    16c4:	98 17       	cp	r25, r24
    16c6:	50 f4       	brcc	.+20     	; 0x16dc <chMtxLockS+0x3c>
    16c8:	84 83       	std	Z+4, r24	; 0x04
    16ca:	87 85       	ldd	r24, Z+15	; 0x0f
    16cc:	86 30       	cpi	r24, 0x06	; 6
    16ce:	09 f4       	brne	.+2      	; 0x16d2 <chMtxLockS+0x32>
    16d0:	85 c0       	rjmp	.+266    	; 0x17dc <chMtxLockS+0x13c>
    16d2:	87 30       	cpi	r24, 0x07	; 7
    16d4:	71 f1       	breq	.+92     	; 0x1732 <chMtxLockS+0x92>
    16d6:	88 23       	and	r24, r24
    16d8:	09 f4       	brne	.+2      	; 0x16dc <chMtxLockS+0x3c>
    16da:	5b c0       	rjmp	.+182    	; 0x1792 <chMtxLockS+0xf2>
    16dc:	9e 01       	movw	r18, r28
    16de:	fe 01       	movw	r30, r28
    16e0:	07 c0       	rjmp	.+14     	; 0x16f0 <chMtxLockS+0x50>
    16e2:	94 81       	ldd	r25, Z+4	; 0x04
    16e4:	d8 01       	movw	r26, r16
    16e6:	14 96       	adiw	r26, 0x04	; 4
    16e8:	8c 91       	ld	r24, X
    16ea:	98 17       	cp	r25, r24
    16ec:	08 f4       	brcc	.+2      	; 0x16f0 <chMtxLockS+0x50>
    16ee:	62 c0       	rjmp	.+196    	; 0x17b4 <chMtxLockS+0x114>
    16f0:	01 90       	ld	r0, Z+
    16f2:	f0 81       	ld	r31, Z
    16f4:	e0 2d       	mov	r30, r0
    16f6:	ce 17       	cp	r28, r30
    16f8:	df 07       	cpc	r29, r31
    16fa:	99 f7       	brne	.-26     	; 0x16e2 <chMtxLockS+0x42>
    16fc:	f8 01       	movw	r30, r16
    16fe:	31 83       	std	Z+1, r19	; 0x01
    1700:	20 83       	st	Z, r18
    1702:	d9 01       	movw	r26, r18
    1704:	12 96       	adiw	r26, 0x02	; 2
    1706:	ed 91       	ld	r30, X+
    1708:	fc 91       	ld	r31, X
    170a:	d8 01       	movw	r26, r16
    170c:	13 96       	adiw	r26, 0x03	; 3
    170e:	fc 93       	st	X, r31
    1710:	ee 93       	st	-X, r30
    1712:	12 97       	sbiw	r26, 0x02	; 2
    1714:	11 83       	std	Z+1, r17	; 0x01
    1716:	00 83       	st	Z, r16
    1718:	f9 01       	movw	r30, r18
    171a:	13 83       	std	Z+3, r17	; 0x03
    171c:	02 83       	std	Z+2, r16	; 0x02
    171e:	53 96       	adiw	r26, 0x13	; 19
    1720:	dc 93       	st	X, r29
    1722:	ce 93       	st	-X, r28
    1724:	52 97       	sbiw	r26, 0x12	; 18
    1726:	86 e0       	ldi	r24, 0x06	; 6
    1728:	df 91       	pop	r29
    172a:	cf 91       	pop	r28
    172c:	1f 91       	pop	r17
    172e:	0f 91       	pop	r16
    1730:	df cc       	rjmp	.-1602   	; 0x10f0 <chSchGoSleepS>
    1732:	22 81       	ldd	r18, Z+2	; 0x02
    1734:	33 81       	ldd	r19, Z+3	; 0x03
    1736:	80 81       	ld	r24, Z
    1738:	91 81       	ldd	r25, Z+1	; 0x01
    173a:	d9 01       	movw	r26, r18
    173c:	8d 93       	st	X+, r24
    173e:	9c 93       	st	X, r25
    1740:	80 81       	ld	r24, Z
    1742:	91 81       	ldd	r25, Z+1	; 0x01
    1744:	dc 01       	movw	r26, r24
    1746:	13 96       	adiw	r26, 0x03	; 3
    1748:	3c 93       	st	X, r19
    174a:	2e 93       	st	-X, r18
    174c:	12 97       	sbiw	r26, 0x02	; 2
    174e:	22 89       	ldd	r18, Z+18	; 0x12
    1750:	33 89       	ldd	r19, Z+19	; 0x13
    1752:	d9 01       	movw	r26, r18
    1754:	07 c0       	rjmp	.+14     	; 0x1764 <chMtxLockS+0xc4>
    1756:	14 96       	adiw	r26, 0x04	; 4
    1758:	9c 91       	ld	r25, X
    175a:	14 97       	sbiw	r26, 0x04	; 4
    175c:	84 81       	ldd	r24, Z+4	; 0x04
    175e:	98 17       	cp	r25, r24
    1760:	08 f4       	brcc	.+2      	; 0x1764 <chMtxLockS+0xc4>
    1762:	78 c0       	rjmp	.+240    	; 0x1854 <chMtxLockS+0x1b4>
    1764:	0d 90       	ld	r0, X+
    1766:	bc 91       	ld	r27, X
    1768:	a0 2d       	mov	r26, r0
    176a:	2a 17       	cp	r18, r26
    176c:	3b 07       	cpc	r19, r27
    176e:	99 f7       	brne	.-26     	; 0x1756 <chMtxLockS+0xb6>
    1770:	31 83       	std	Z+1, r19	; 0x01
    1772:	20 83       	st	Z, r18
    1774:	d9 01       	movw	r26, r18
    1776:	12 96       	adiw	r26, 0x02	; 2
    1778:	8d 91       	ld	r24, X+
    177a:	9c 91       	ld	r25, X
    177c:	93 83       	std	Z+3, r25	; 0x03
    177e:	82 83       	std	Z+2, r24	; 0x02
    1780:	dc 01       	movw	r26, r24
    1782:	ed 93       	st	X+, r30
    1784:	fc 93       	st	X, r31
    1786:	d9 01       	movw	r26, r18
    1788:	13 96       	adiw	r26, 0x03	; 3
    178a:	fc 93       	st	X, r31
    178c:	ee 93       	st	-X, r30
    178e:	12 97       	sbiw	r26, 0x02	; 2
    1790:	a5 cf       	rjmp	.-182    	; 0x16dc <chMtxLockS+0x3c>
    1792:	22 81       	ldd	r18, Z+2	; 0x02
    1794:	33 81       	ldd	r19, Z+3	; 0x03
    1796:	80 81       	ld	r24, Z
    1798:	91 81       	ldd	r25, Z+1	; 0x01
    179a:	d9 01       	movw	r26, r18
    179c:	8d 93       	st	X+, r24
    179e:	9c 93       	st	X, r25
    17a0:	80 81       	ld	r24, Z
    17a2:	91 81       	ldd	r25, Z+1	; 0x01
    17a4:	dc 01       	movw	r26, r24
    17a6:	13 96       	adiw	r26, 0x03	; 3
    17a8:	3c 93       	st	X, r19
    17aa:	2e 93       	st	-X, r18
    17ac:	12 97       	sbiw	r26, 0x02	; 2
    17ae:	cf 01       	movw	r24, r30
    17b0:	7b dc       	rcall	.-1802   	; 0x10a8 <chSchReadyI>
    17b2:	94 cf       	rjmp	.-216    	; 0x16dc <chMtxLockS+0x3c>
    17b4:	9f 01       	movw	r18, r30
    17b6:	a2 cf       	rjmp	.-188    	; 0x16fc <chMtxLockS+0x5c>
    17b8:	1d 83       	std	Y+5, r17	; 0x05
    17ba:	0c 83       	std	Y+4, r16	; 0x04
    17bc:	d8 01       	movw	r26, r16
    17be:	5b 96       	adiw	r26, 0x1b	; 27
    17c0:	8d 91       	ld	r24, X+
    17c2:	9c 91       	ld	r25, X
    17c4:	5c 97       	sbiw	r26, 0x1c	; 28
    17c6:	9f 83       	std	Y+7, r25	; 0x07
    17c8:	8e 83       	std	Y+6, r24	; 0x06
    17ca:	5c 96       	adiw	r26, 0x1c	; 28
    17cc:	dc 93       	st	X, r29
    17ce:	ce 93       	st	-X, r28
    17d0:	5b 97       	sbiw	r26, 0x1b	; 27
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	1f 91       	pop	r17
    17d8:	0f 91       	pop	r16
    17da:	08 95       	ret
    17dc:	22 81       	ldd	r18, Z+2	; 0x02
    17de:	33 81       	ldd	r19, Z+3	; 0x03
    17e0:	80 81       	ld	r24, Z
    17e2:	91 81       	ldd	r25, Z+1	; 0x01
    17e4:	d9 01       	movw	r26, r18
    17e6:	8d 93       	st	X+, r24
    17e8:	9c 93       	st	X, r25
    17ea:	80 81       	ld	r24, Z
    17ec:	91 81       	ldd	r25, Z+1	; 0x01
    17ee:	dc 01       	movw	r26, r24
    17f0:	13 96       	adiw	r26, 0x03	; 3
    17f2:	3c 93       	st	X, r19
    17f4:	2e 93       	st	-X, r18
    17f6:	12 97       	sbiw	r26, 0x02	; 2
    17f8:	22 89       	ldd	r18, Z+18	; 0x12
    17fa:	33 89       	ldd	r19, Z+19	; 0x13
    17fc:	d9 01       	movw	r26, r18
    17fe:	06 c0       	rjmp	.+12     	; 0x180c <chMtxLockS+0x16c>
    1800:	14 96       	adiw	r26, 0x04	; 4
    1802:	9c 91       	ld	r25, X
    1804:	14 97       	sbiw	r26, 0x04	; 4
    1806:	84 81       	ldd	r24, Z+4	; 0x04
    1808:	98 17       	cp	r25, r24
    180a:	30 f1       	brcs	.+76     	; 0x1858 <chMtxLockS+0x1b8>
    180c:	0d 90       	ld	r0, X+
    180e:	bc 91       	ld	r27, X
    1810:	a0 2d       	mov	r26, r0
    1812:	2a 17       	cp	r18, r26
    1814:	3b 07       	cpc	r19, r27
    1816:	a1 f7       	brne	.-24     	; 0x1800 <chMtxLockS+0x160>
    1818:	31 83       	std	Z+1, r19	; 0x01
    181a:	20 83       	st	Z, r18
    181c:	d9 01       	movw	r26, r18
    181e:	12 96       	adiw	r26, 0x02	; 2
    1820:	8d 91       	ld	r24, X+
    1822:	9c 91       	ld	r25, X
    1824:	93 83       	std	Z+3, r25	; 0x03
    1826:	82 83       	std	Z+2, r24	; 0x02
    1828:	dc 01       	movw	r26, r24
    182a:	ed 93       	st	X+, r30
    182c:	fc 93       	st	X, r31
    182e:	d9 01       	movw	r26, r18
    1830:	13 96       	adiw	r26, 0x03	; 3
    1832:	fc 93       	st	X, r31
    1834:	ee 93       	st	-X, r30
    1836:	12 97       	sbiw	r26, 0x02	; 2
    1838:	02 88       	ldd	r0, Z+18	; 0x12
    183a:	f3 89       	ldd	r31, Z+19	; 0x13
    183c:	e0 2d       	mov	r30, r0
    183e:	04 80       	ldd	r0, Z+4	; 0x04
    1840:	f5 81       	ldd	r31, Z+5	; 0x05
    1842:	e0 2d       	mov	r30, r0
    1844:	d8 01       	movw	r26, r16
    1846:	14 96       	adiw	r26, 0x04	; 4
    1848:	8c 91       	ld	r24, X
    184a:	94 81       	ldd	r25, Z+4	; 0x04
    184c:	98 17       	cp	r25, r24
    184e:	08 f4       	brcc	.+2      	; 0x1852 <chMtxLockS+0x1b2>
    1850:	3b cf       	rjmp	.-394    	; 0x16c8 <chMtxLockS+0x28>
    1852:	44 cf       	rjmp	.-376    	; 0x16dc <chMtxLockS+0x3c>
    1854:	9d 01       	movw	r18, r26
    1856:	8c cf       	rjmp	.-232    	; 0x1770 <chMtxLockS+0xd0>
    1858:	9d 01       	movw	r18, r26
    185a:	de cf       	rjmp	.-68     	; 0x1818 <chMtxLockS+0x178>

0000185c <chMtxLock>:
    185c:	f8 94       	cli
    185e:	20 df       	rcall	.-448    	; 0x16a0 <chMtxLockS>
    1860:	78 94       	sei
    1862:	08 95       	ret

00001864 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    1868:	c0 91 3d 04 	lds	r28, 0x043D	; 0x80043d <ch0+0x5>
    186c:	d0 91 3e 04 	lds	r29, 0x043E	; 0x80043e <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1870:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1872:	dc 01       	movw	r26, r24
    1874:	16 96       	adiw	r26, 0x06	; 6
    1876:	ed 91       	ld	r30, X+
    1878:	fc 91       	ld	r31, X
    187a:	17 97       	sbiw	r26, 0x07	; 7
    187c:	fc 8f       	std	Y+28, r31	; 0x1c
    187e:	eb 8f       	std	Y+27, r30	; 0x1b

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1880:	2d 91       	ld	r18, X+
    1882:	3c 91       	ld	r19, X
    1884:	28 17       	cp	r18, r24
    1886:	39 07       	cpc	r19, r25
    1888:	81 f1       	breq	.+96     	; 0x18ea <chMtxUnlock+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    188a:	3d 8d       	ldd	r19, Y+29	; 0x1d
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    188c:	30 97       	sbiw	r30, 0x00	; 0
    188e:	79 f0       	breq	.+30     	; 0x18ae <chMtxUnlock+0x4a>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1890:	a0 81       	ld	r26, Z
    1892:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    1894:	ea 17       	cp	r30, r26
    1896:	fb 07       	cpc	r31, r27
    1898:	29 f0       	breq	.+10     	; 0x18a4 <chMtxUnlock+0x40>
    189a:	14 96       	adiw	r26, 0x04	; 4
    189c:	2c 91       	ld	r18, X
    189e:	32 17       	cp	r19, r18
    18a0:	08 f4       	brcc	.+2      	; 0x18a4 <chMtxUnlock+0x40>
    18a2:	32 2f       	mov	r19, r18
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    18a4:	06 80       	ldd	r0, Z+6	; 0x06
    18a6:	f7 81       	ldd	r31, Z+7	; 0x07
    18a8:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    18aa:	30 97       	sbiw	r30, 0x00	; 0
    18ac:	89 f7       	brne	.-30     	; 0x1890 <chMtxUnlock+0x2c>
    18ae:	fc 01       	movw	r30, r24
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    18b0:	3c 83       	std	Y+4, r19	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    18b2:	a0 81       	ld	r26, Z
    18b4:	b1 81       	ldd	r27, Z+1	; 0x01

  qp->next       = p->next;
    18b6:	cd 91       	ld	r28, X+
    18b8:	dc 91       	ld	r29, X
    18ba:	11 97       	sbiw	r26, 0x01	; 1
    18bc:	d1 83       	std	Z+1, r29	; 0x01
    18be:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    18c0:	9b 83       	std	Y+3, r25	; 0x03
    18c2:	8a 83       	std	Y+2, r24	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    18c4:	b5 83       	std	Z+5, r27	; 0x05
    18c6:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    18c8:	5b 96       	adiw	r26, 0x1b	; 27
    18ca:	8d 91       	ld	r24, X+
    18cc:	9c 91       	ld	r25, X
    18ce:	5c 97       	sbiw	r26, 0x1c	; 28
    18d0:	97 83       	std	Z+7, r25	; 0x07
    18d2:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    18d4:	5c 96       	adiw	r26, 0x1c	; 28
    18d6:	fc 93       	st	X, r31
    18d8:	ee 93       	st	-X, r30
    18da:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    18dc:	cd 01       	movw	r24, r26
    18de:	e4 db       	rcall	.-2104   	; 0x10a8 <chSchReadyI>
      chSchRescheduleS();
    18e0:	fd dc       	rcall	.-1542   	; 0x12dc <chSchRescheduleS>
    18e2:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    18e4:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    18e6:	cf 91       	pop	r28
    18e8:	08 95       	ret
    18ea:	f9 01       	movw	r30, r18
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    18ec:	15 82       	std	Z+5, r1	; 0x05
    18ee:	14 82       	std	Z+4, r1	; 0x04
    18f0:	78 94       	sei
    18f2:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    18f4:	cf 91       	pop	r28
    18f6:	08 95       	ret

000018f8 <chMtxUnlockS>:
    18f8:	cf 93       	push	r28
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    18fa:	df 93       	push	r29
    18fc:	ec 01       	movw	r28, r24
    18fe:	20 91 3d 04 	lds	r18, 0x043D	; 0x80043d <ch0+0x5>
    1902:	30 91 3e 04 	lds	r19, 0x043E	; 0x80043e <ch0+0x6>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1906:	ee 81       	ldd	r30, Y+6	; 0x06
    1908:	ff 81       	ldd	r31, Y+7	; 0x07
    190a:	d9 01       	movw	r26, r18
    190c:	5c 96       	adiw	r26, 0x1c	; 28
    190e:	fc 93       	st	X, r31
    1910:	ee 93       	st	-X, r30
    1912:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1914:	a8 81       	ld	r26, Y
    1916:	b9 81       	ldd	r27, Y+1	; 0x01
    1918:	a8 17       	cp	r26, r24
    191a:	b9 07       	cpc	r27, r25
    191c:	61 f1       	breq	.+88     	; 0x1976 <chMtxUnlockS+0x7e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    191e:	d9 01       	movw	r26, r18
    1920:	5d 96       	adiw	r26, 0x1d	; 29
    1922:	9c 91       	ld	r25, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1924:	30 97       	sbiw	r30, 0x00	; 0
    1926:	79 f0       	breq	.+30     	; 0x1946 <chMtxUnlockS+0x4e>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1928:	a0 81       	ld	r26, Z
    192a:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    192c:	ea 17       	cp	r30, r26
    192e:	fb 07       	cpc	r31, r27
    1930:	29 f0       	breq	.+10     	; 0x193c <chMtxUnlockS+0x44>
    1932:	14 96       	adiw	r26, 0x04	; 4
    1934:	8c 91       	ld	r24, X
    1936:	98 17       	cp	r25, r24
    1938:	08 f4       	brcc	.+2      	; 0x193c <chMtxUnlockS+0x44>
    193a:	98 2f       	mov	r25, r24
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    193c:	06 80       	ldd	r0, Z+6	; 0x06
    193e:	f7 81       	ldd	r31, Z+7	; 0x07
    1940:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1942:	30 97       	sbiw	r30, 0x00	; 0
    1944:	89 f7       	brne	.-30     	; 0x1928 <chMtxUnlockS+0x30>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1946:	f9 01       	movw	r30, r18
    1948:	94 83       	std	Z+4, r25	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    194a:	e8 81       	ld	r30, Y
    194c:	f9 81       	ldd	r31, Y+1	; 0x01

  qp->next       = p->next;
    194e:	a0 81       	ld	r26, Z
    1950:	b1 81       	ldd	r27, Z+1	; 0x01
    1952:	b9 83       	std	Y+1, r27	; 0x01
    1954:	a8 83       	st	Y, r26
  qp->next->prev = qp;
    1956:	13 96       	adiw	r26, 0x03	; 3
    1958:	dc 93       	st	X, r29
    195a:	ce 93       	st	-X, r28
    195c:	12 97       	sbiw	r26, 0x02	; 2
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    195e:	fd 83       	std	Y+5, r31	; 0x05
    1960:	ec 83       	std	Y+4, r30	; 0x04
      mp->next = tp->mtxlist;
    1962:	83 8d       	ldd	r24, Z+27	; 0x1b
    1964:	94 8d       	ldd	r25, Z+28	; 0x1c
    1966:	9f 83       	std	Y+7, r25	; 0x07
    1968:	8e 83       	std	Y+6, r24	; 0x06
      tp->mtxlist = mp;
    196a:	d4 8f       	std	Z+28, r29	; 0x1c
    196c:	c3 8f       	std	Z+27, r28	; 0x1b
      (void) chSchReadyI(tp);
    196e:	cf 01       	movw	r24, r30
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    1974:	99 cb       	rjmp	.-2254   	; 0x10a8 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
    1976:	15 96       	adiw	r26, 0x05	; 5
    1978:	1c 92       	st	X, r1
    197a:	1e 92       	st	-X, r1
    197c:	14 97       	sbiw	r26, 0x04	; 4
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	08 95       	ret

00001984 <chCondObjectInit>:
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  }
}
    1984:	fc 01       	movw	r30, r24
    1986:	91 83       	std	Z+1, r25	; 0x01
    1988:	80 83       	st	Z, r24
    198a:	93 83       	std	Z+3, r25	; 0x03
    198c:	82 83       	std	Z+2, r24	; 0x02
    198e:	08 95       	ret

00001990 <chCondSignal>:
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	fc 01       	movw	r30, r24
    1996:	f8 94       	cli
    1998:	80 81       	ld	r24, Z
    199a:	91 81       	ldd	r25, Z+1	; 0x01
    199c:	e8 17       	cp	r30, r24
    199e:	f9 07       	cpc	r31, r25
    19a0:	61 f0       	breq	.+24     	; 0x19ba <chCondSignal+0x2a>
    19a2:	ec 01       	movw	r28, r24
    19a4:	a8 81       	ld	r26, Y
    19a6:	b9 81       	ldd	r27, Y+1	; 0x01
    19a8:	b1 83       	std	Z+1, r27	; 0x01
    19aa:	a0 83       	st	Z, r26
    19ac:	13 96       	adiw	r26, 0x03	; 3
    19ae:	fc 93       	st	X, r31
    19b0:	ee 93       	st	-X, r30
    19b2:	12 97       	sbiw	r26, 0x02	; 2
    19b4:	70 e0       	ldi	r23, 0x00	; 0
    19b6:	60 e0       	ldi	r22, 0x00	; 0
    19b8:	f4 db       	rcall	.-2072   	; 0x11a2 <chSchWakeupS>
    19ba:	78 94       	sei
    19bc:	df 91       	pop	r29
    19be:	cf 91       	pop	r28
    19c0:	08 95       	ret

000019c2 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
    19c2:	ef 92       	push	r14
    19c4:	ff 92       	push	r15
    19c6:	0f 93       	push	r16
    19c8:	1f 93       	push	r17
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	8c 01       	movw	r16, r24
    19d0:	c0 91 3d 04 	lds	r28, 0x043D	; 0x80043d <ch0+0x5>
    19d4:	d0 91 3e 04 	lds	r29, 0x043E	; 0x80043e <ch0+0x6>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
    19d8:	eb 8c       	ldd	r14, Y+27	; 0x1b
    19da:	fc 8c       	ldd	r15, Y+28	; 0x1c
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
    19dc:	c7 01       	movw	r24, r14
    19de:	8c df       	rcall	.-232    	; 0x18f8 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
    19e0:	1b 8b       	std	Y+19, r17	; 0x13
    19e2:	0a 8b       	std	Y+18, r16	; 0x12
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
    19e4:	d8 01       	movw	r26, r16
    19e6:	f8 01       	movw	r30, r16
    19e8:	04 c0       	rjmp	.+8      	; 0x19f2 <chCondWaitS+0x30>
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
    19ea:	94 81       	ldd	r25, Z+4	; 0x04
    19ec:	8c 81       	ldd	r24, Y+4	; 0x04
    19ee:	98 17       	cp	r25, r24
    19f0:	18 f1       	brcs	.+70     	; 0x1a38 <chCondWaitS+0x76>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    19f2:	01 90       	ld	r0, Z+
    19f4:	f0 81       	ld	r31, Z
    19f6:	e0 2d       	mov	r30, r0
  } while ((cp != qp) &&
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
    19f8:	0e 17       	cp	r16, r30
    19fa:	1f 07       	cpc	r17, r31
    19fc:	b1 f7       	brne	.-20     	; 0x19ea <chCondWaitS+0x28>
  tp->next       = cp;
    19fe:	b9 83       	std	Y+1, r27	; 0x01
    1a00:	a8 83       	st	Y, r26
  tp->prev       = cp->prev;
    1a02:	12 96       	adiw	r26, 0x02	; 2
    1a04:	ed 91       	ld	r30, X+
    1a06:	fc 91       	ld	r31, X
    1a08:	13 97       	sbiw	r26, 0x03	; 3
    1a0a:	fb 83       	std	Y+3, r31	; 0x03
    1a0c:	ea 83       	std	Y+2, r30	; 0x02
  tp->prev->next = tp;
    1a0e:	d1 83       	std	Z+1, r29	; 0x01
    1a10:	c0 83       	st	Z, r28
  cp->prev       = tp;
    1a12:	13 96       	adiw	r26, 0x03	; 3
    1a14:	dc 93       	st	X, r29
    1a16:	ce 93       	st	-X, r28
    1a18:	12 97       	sbiw	r26, 0x02	; 2
  chSchGoSleepS(CH_STATE_WTCOND);
    1a1a:	87 e0       	ldi	r24, 0x07	; 7
    1a1c:	69 db       	rcall	.-2350   	; 0x10f0 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
    1a1e:	0a 88       	ldd	r0, Y+18	; 0x12
    1a20:	db 89       	ldd	r29, Y+19	; 0x13
  chMtxLockS(mp);
    1a22:	c0 2d       	mov	r28, r0
    1a24:	c7 01       	movw	r24, r14
    1a26:	3c de       	rcall	.-904    	; 0x16a0 <chMtxLockS>

  return msg;
}
    1a28:	ce 01       	movw	r24, r28
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	ff 90       	pop	r15
    1a34:	ef 90       	pop	r14
    1a36:	08 95       	ret
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    1a38:	df 01       	movw	r26, r30
    1a3a:	e1 cf       	rjmp	.-62     	; 0x19fe <chCondWaitS+0x3c>

00001a3c <chCondWait>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1a3c:	f8 94       	cli
 */
msg_t chCondWait(condition_variable_t *cp) {
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
    1a3e:	c1 df       	rcall	.-126    	; 0x19c2 <chCondWaitS>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1a40:	78 94       	sei
  chSysUnlock();
  return msg;
}
    1a42:	08 95       	ret

00001a44 <chEvtSignalI>:

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
  chSysUnlock();
}
    1a44:	fc 01       	movw	r30, r24
    1a46:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a48:	68 2b       	or	r22, r24
    1a4a:	62 8f       	std	Z+26, r22	; 0x1a
    1a4c:	87 85       	ldd	r24, Z+15	; 0x0f
    1a4e:	8a 30       	cpi	r24, 0x0A	; 10
    1a50:	59 f0       	breq	.+22     	; 0x1a68 <chEvtSignalI+0x24>
    1a52:	8b 30       	cpi	r24, 0x0B	; 11
    1a54:	09 f0       	breq	.+2      	; 0x1a58 <chEvtSignalI+0x14>
    1a56:	08 95       	ret
    1a58:	82 89       	ldd	r24, Z+18	; 0x12
    1a5a:	68 23       	and	r22, r24
    1a5c:	86 13       	cpse	r24, r22
    1a5e:	fb cf       	rjmp	.-10     	; 0x1a56 <chEvtSignalI+0x12>
    1a60:	13 8a       	std	Z+19, r1	; 0x13
    1a62:	12 8a       	std	Z+18, r1	; 0x12
    1a64:	cf 01       	movw	r24, r30
    1a66:	20 cb       	rjmp	.-2496   	; 0x10a8 <chSchReadyI>
    1a68:	82 89       	ldd	r24, Z+18	; 0x12
    1a6a:	68 23       	and	r22, r24
    1a6c:	c9 f7       	brne	.-14     	; 0x1a60 <chEvtSignalI+0x1c>
    1a6e:	08 95       	ret

00001a70 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1a70:	ef 92       	push	r14
    1a72:	ff 92       	push	r15
    1a74:	1f 93       	push	r17
    1a76:	cf 93       	push	r28
    1a78:	df 93       	push	r29
    1a7a:	7c 01       	movw	r14, r24
    1a7c:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    1a7e:	fc 01       	movw	r30, r24
    1a80:	c0 81       	ld	r28, Z
    1a82:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1a84:	8c 17       	cp	r24, r28
    1a86:	9d 07       	cpc	r25, r29
    1a88:	91 f0       	breq	.+36     	; 0x1aae <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    1a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8c:	81 2b       	or	r24, r17
    1a8e:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1a90:	11 23       	and	r17, r17
    1a92:	19 f0       	breq	.+6      	; 0x1a9a <chEvtBroadcastFlagsI+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
    1a94:	8e 81       	ldd	r24, Y+6	; 0x06
    1a96:	81 23       	and	r24, r17
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1a98:	21 f0       	breq	.+8      	; 0x1aa2 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1a9a:	6c 81       	ldd	r22, Y+4	; 0x04
    1a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9e:	9b 81       	ldd	r25, Y+3	; 0x03
    1aa0:	d1 df       	rcall	.-94     	; 0x1a44 <chEvtSignalI>
    }
    elp = elp->next;
    1aa2:	09 90       	ld	r0, Y+
    1aa4:	d8 81       	ld	r29, Y
    1aa6:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1aa8:	ec 16       	cp	r14, r28
    1aaa:	fd 06       	cpc	r15, r29
    1aac:	71 f7       	brne	.-36     	; 0x1a8a <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	1f 91       	pop	r17
    1ab4:	ff 90       	pop	r15
    1ab6:	ef 90       	pop	r14
    1ab8:	08 95       	ret

00001aba <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1aba:	ed e7       	ldi	r30, 0x7D	; 125
    1abc:	f4 e0       	ldi	r31, 0x04	; 4
    1abe:	85 ec       	ldi	r24, 0xC5	; 197
    1ac0:	91 e0       	ldi	r25, 0x01	; 1
    1ac2:	91 83       	std	Z+1, r25	; 0x01
    1ac4:	80 83       	st	Z, r24
    1ac6:	85 e4       	ldi	r24, 0x45	; 69
    1ac8:	92 e0       	ldi	r25, 0x02	; 2
    1aca:	93 83       	std	Z+3, r25	; 0x03
    1acc:	82 83       	std	Z+2, r24	; 0x02
    1ace:	08 95       	ret

00001ad0 <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1ad0:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    1ad2:	e0 91 7f 04 	lds	r30, 0x047F	; 0x80047f <ch_memcore+0x2>
    1ad6:	f0 91 80 04 	lds	r31, 0x0480	; 0x800480 <ch_memcore+0x3>
    1ada:	9f 01       	movw	r18, r30
    1adc:	28 1b       	sub	r18, r24
    1ade:	39 0b       	sbc	r19, r25
    1ae0:	c9 01       	movw	r24, r18
    1ae2:	71 95       	neg	r23
    1ae4:	61 95       	neg	r22
    1ae6:	71 09       	sbc	r23, r1
    1ae8:	86 23       	and	r24, r22
    1aea:	97 23       	and	r25, r23
  prev = p - offset;
    1aec:	9c 01       	movw	r18, r24
    1aee:	24 1b       	sub	r18, r20
    1af0:	35 0b       	sbc	r19, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    1af2:	40 91 7d 04 	lds	r20, 0x047D	; 0x80047d <ch_memcore>
    1af6:	50 91 7e 04 	lds	r21, 0x047E	; 0x80047e <ch_memcore+0x1>
    1afa:	24 17       	cp	r18, r20
    1afc:	35 07       	cpc	r19, r21
    1afe:	48 f0       	brcs	.+18     	; 0x1b12 <chCoreAllocFromTop+0x42>
    1b00:	e2 17       	cp	r30, r18
    1b02:	f3 07       	cpc	r31, r19
    1b04:	30 f0       	brcs	.+12     	; 0x1b12 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    1b06:	30 93 80 04 	sts	0x0480, r19	; 0x800480 <ch_memcore+0x3>
    1b0a:	20 93 7f 04 	sts	0x047F, r18	; 0x80047f <ch_memcore+0x2>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1b0e:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    1b10:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    1b18:	08 95       	ret

00001b1a <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
    1b1a:	e5 e4       	ldi	r30, 0x45	; 69
    1b1c:	f2 e0       	ldi	r31, 0x02	; 2
    1b1e:	88 e6       	ldi	r24, 0x68	; 104
    1b20:	9d e0       	ldi	r25, 0x0D	; 13
    1b22:	91 83       	std	Z+1, r25	; 0x01
    1b24:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
    1b26:	13 82       	std	Z+3, r1	; 0x03
    1b28:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
    1b2a:	15 82       	std	Z+5, r1	; 0x05
    1b2c:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    1b2e:	8b e4       	ldi	r24, 0x4B	; 75
    1b30:	92 e0       	ldi	r25, 0x02	; 2
    1b32:	ae cd       	rjmp	.-1188   	; 0x1690 <chMtxObjectInit>

00001b34 <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    1b34:	2f 92       	push	r2
  asm volatile ("push    r3");
    1b36:	3f 92       	push	r3
  asm volatile ("push    r4");
    1b38:	4f 92       	push	r4
  asm volatile ("push    r5");
    1b3a:	5f 92       	push	r5
  asm volatile ("push    r6");
    1b3c:	6f 92       	push	r6
  asm volatile ("push    r7");
    1b3e:	7f 92       	push	r7
  asm volatile ("push    r8");
    1b40:	8f 92       	push	r8
  asm volatile ("push    r9");
    1b42:	9f 92       	push	r9
  asm volatile ("push    r10");
    1b44:	af 92       	push	r10
  asm volatile ("push    r11");
    1b46:	bf 92       	push	r11
  asm volatile ("push    r12");
    1b48:	cf 92       	push	r12
  asm volatile ("push    r13");
    1b4a:	df 92       	push	r13
  asm volatile ("push    r14");
    1b4c:	ef 92       	push	r14
  asm volatile ("push    r15");
    1b4e:	ff 92       	push	r15
  asm volatile ("push    r16");
    1b50:	0f 93       	push	r16
  asm volatile ("push    r17");
    1b52:	1f 93       	push	r17
  asm volatile ("push    r28");
    1b54:	cf 93       	push	r28
  asm volatile ("push    r29");
    1b56:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    1b58:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    1b5a:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    1b5c:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    1b5e:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    1b60:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    1b62:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    1b64:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    1b66:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    1b68:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1b6a:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    1b6c:	df 91       	pop	r29
  asm volatile ("pop     r28");
    1b6e:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    1b70:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1b72:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    1b74:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    1b76:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    1b78:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1b7a:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    1b7c:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    1b7e:	af 90       	pop	r10
  asm volatile ("pop     r9");
    1b80:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1b82:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    1b84:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    1b86:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    1b88:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1b8a:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1b8c:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1b8e:	2f 90       	pop	r2
  asm volatile ("ret");
    1b90:	08 95       	ret

00001b92 <_port_thread_start>:
    1b92:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    1b94:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    1b96:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    1b98:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1b9a:	39 cd       	rjmp	.-1422   	; 0x160e <chThdExit>
}
    1b9c:	08 95       	ret

00001b9e <vt_cb>:
 
  return msg;
}

void vt_cb(void *arg)
{
    1b9e:	0f 93       	push	r16
    1ba0:	1f 93       	push	r17
    1ba2:	cf 93       	push	r28
    1ba4:	df 93       	push	r29
    1ba6:	ec 01       	movw	r28, r24
  chSysLockFromISR();
  palTogglePad(IOPORT2, PORTB_LED1);
    1ba8:	85 b1       	in	r24, 0x05	; 5
    1baa:	90 e2       	ldi	r25, 0x20	; 32
    1bac:	89 27       	eor	r24, r25
    1bae:	85 b9       	out	0x05, r24	; 5
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1bb0:	88 81       	ld	r24, Y
    1bb2:	99 81       	ldd	r25, Y+1	; 0x01
    1bb4:	89 2b       	or	r24, r25
    1bb6:	11 f0       	breq	.+4      	; 0x1bbc <vt_cb+0x1e>
    chVTDoResetI(vtp);
    1bb8:	ce 01       	movw	r24, r28
    1bba:	7f d8       	rcall	.-3842   	; 0xcba <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1bbc:	8e 01       	movw	r16, r28
    1bbe:	2f ec       	ldi	r18, 0xCF	; 207
    1bc0:	3d e0       	ldi	r19, 0x0D	; 13
    1bc2:	48 e2       	ldi	r20, 0x28	; 40
    1bc4:	51 e3       	ldi	r21, 0x31	; 49
    1bc6:	61 e0       	ldi	r22, 0x01	; 1
    1bc8:	70 e0       	ldi	r23, 0x00	; 0
    1bca:	ce 01       	movw	r24, r28
    1bcc:	68 d8       	rcall	.-3888   	; 0xc9e <chVTDoSetI>
  chVTSetI((virtual_timer_t *)arg, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, arg);
  chSysUnlockFromISR();
}
    1bce:	df 91       	pop	r29
    1bd0:	cf 91       	pop	r28
    1bd2:	1f 91       	pop	r17
    1bd4:	0f 91       	pop	r16
    1bd6:	08 95       	ret

00001bd8 <queueInit>:
/*
 * Synchronized queue initialization.
 */
void queueInit(void) {
 
  chMtxObjectInit(&qmtx);
    1bd8:	8e ed       	ldi	r24, 0xDE	; 222
    1bda:	92 e0       	ldi	r25, 0x02	; 2
    1bdc:	59 dd       	rcall	.-1358   	; 0x1690 <chMtxObjectInit>
  chCondObjectInit(&qempty);
    1bde:	8a ed       	ldi	r24, 0xDA	; 218
    1be0:	92 e0       	ldi	r25, 0x02	; 2
    1be2:	d0 de       	rcall	.-608    	; 0x1984 <chCondObjectInit>
  chCondObjectInit(&qfull);
    1be4:	86 ed       	ldi	r24, 0xD6	; 214
    1be6:	92 e0       	ldi	r25, 0x02	; 2
    1be8:	cd de       	rcall	.-614    	; 0x1984 <chCondObjectInit>
 
  rdp = wrp = &queue[0];
    1bea:	8c ee       	ldi	r24, 0xEC	; 236
    1bec:	92 e0       	ldi	r25, 0x02	; 2
    1bee:	90 93 e9 02 	sts	0x02E9, r25	; 0x8002e9 <wrp+0x1>
    1bf2:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <wrp>
    1bf6:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <rdp+0x1>
    1bfa:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <rdp>
  qsize = 0;
    1bfe:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <qsize+0x1>
    1c02:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <qsize>
}
    1c06:	08 95       	ret

00001c08 <enqueue>:

/*
 * Writes a message into the queue, if the queue is full waits
 * for a free slot.
 */
void enqueue(msg_t msg) {
    1c08:	cf 93       	push	r28
    1c0a:	df 93       	push	r29
    1c0c:	ec 01       	movw	r28, r24
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
    1c0e:	8e ed       	ldi	r24, 0xDE	; 222
    1c10:	92 e0       	ldi	r25, 0x02	; 2
    1c12:	24 de       	rcall	.-952    	; 0x185c <chMtxLock>
 
  /* Waiting for space in the queue.*/
  while (qsize >= QUEUE_SIZE)
    1c14:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <qsize>
    1c18:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <qsize+0x1>
    1c1c:	80 38       	cpi	r24, 0x80	; 128
    1c1e:	91 05       	cpc	r25, r1
    1c20:	50 f0       	brcs	.+20     	; 0x1c36 <enqueue+0x2e>
    chCondWait(&qfull);
    1c22:	86 ed       	ldi	r24, 0xD6	; 214
    1c24:	92 e0       	ldi	r25, 0x02	; 2
    1c26:	0a df       	rcall	.-492    	; 0x1a3c <chCondWait>
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for space in the queue.*/
  while (qsize >= QUEUE_SIZE)
    1c28:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <qsize>
    1c2c:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <qsize+0x1>
    1c30:	80 38       	cpi	r24, 0x80	; 128
    1c32:	91 05       	cpc	r25, r1
    1c34:	b0 f7       	brcc	.-20     	; 0x1c22 <enqueue+0x1a>
    chCondWait(&qfull);
 
  /* Writing the message in the queue.*/  
  *wrp = msg;
    1c36:	e0 91 e8 02 	lds	r30, 0x02E8	; 0x8002e8 <wrp>
    1c3a:	f0 91 e9 02 	lds	r31, 0x02E9	; 0x8002e9 <wrp+0x1>
    1c3e:	c1 93       	st	Z+, r28
    1c40:	d1 93       	st	Z+, r29
  if (++wrp >= &queue[QUEUE_SIZE])
    1c42:	23 e0       	ldi	r18, 0x03	; 3
    1c44:	ec 3e       	cpi	r30, 0xEC	; 236
    1c46:	f2 07       	cpc	r31, r18
    1c48:	98 f0       	brcs	.+38     	; 0x1c70 <enqueue+0x68>
    wrp = &queue[0];
    1c4a:	2c ee       	ldi	r18, 0xEC	; 236
    1c4c:	32 e0       	ldi	r19, 0x02	; 2
    1c4e:	30 93 e9 02 	sts	0x02E9, r19	; 0x8002e9 <wrp+0x1>
    1c52:	20 93 e8 02 	sts	0x02E8, r18	; 0x8002e8 <wrp>
  qsize++;
    1c56:	01 96       	adiw	r24, 0x01	; 1
    1c58:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <qsize+0x1>
    1c5c:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <qsize>
 
  /* Signaling that there is at least a message.*/
  chCondSignal(&qempty);
    1c60:	8a ed       	ldi	r24, 0xDA	; 218
    1c62:	92 e0       	ldi	r25, 0x02	; 2
    1c64:	95 de       	rcall	.-726    	; 0x1990 <chCondSignal>
 
  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    1c66:	8e ed       	ldi	r24, 0xDE	; 222
}
    1c68:	92 e0       	ldi	r25, 0x02	; 2
    1c6a:	df 91       	pop	r29
 
  /* Signaling that there is at least a message.*/
  chCondSignal(&qempty);
 
  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    1c6c:	cf 91       	pop	r28
    1c6e:	fa cd       	rjmp	.-1036   	; 0x1864 <chMtxUnlock>
  while (qsize >= QUEUE_SIZE)
    chCondWait(&qfull);
 
  /* Writing the message in the queue.*/  
  *wrp = msg;
  if (++wrp >= &queue[QUEUE_SIZE])
    1c70:	f0 93 e9 02 	sts	0x02E9, r31	; 0x8002e9 <wrp+0x1>
    1c74:	e0 93 e8 02 	sts	0x02E8, r30	; 0x8002e8 <wrp>
    1c78:	ee cf       	rjmp	.-36     	; 0x1c56 <enqueue+0x4e>

00001c7a <main>:
/*
 * Application entry point.
 */
int main(void)
{
  queueInit();
    1c7a:	ae df       	rcall	.-164    	; 0x1bd8 <queueInit>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    1c7c:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
  chSysInit();
    1c80:	0e 94 a0 04 	call	0x940	; 0x940 <chSysInit>

  /* Configuração dos botões */
  palSetLineMode(PED_FLAG, PAL_MODE_INPUT_PULLUP);
    1c84:	62 e0       	ldi	r22, 0x02	; 2
    1c86:	86 e2       	ldi	r24, 0x26	; 38
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1c8e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1c92:	18 2f       	mov	r17, r24
    1c94:	62 e0       	ldi	r22, 0x02	; 2
    1c96:	86 e2       	ldi	r24, 0x26	; 38
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1c9e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1ca2:	c1 e0       	ldi	r28, 0x01	; 1
    1ca4:	d0 e0       	ldi	r29, 0x00	; 0
    1ca6:	be 01       	movw	r22, r28
    1ca8:	01 c0       	rjmp	.+2      	; 0x1cac <main+0x32>
    1caa:	66 0f       	add	r22, r22
    1cac:	1a 95       	dec	r17
    1cae:	ea f7       	brpl	.-6      	; 0x1caa <main+0x30>
    1cb0:	43 e0       	ldi	r20, 0x03	; 3
    1cb2:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palSetLineMode(SEC_FLAG, PAL_MODE_INPUT_PULLUP);
    1cb6:	64 e0       	ldi	r22, 0x04	; 4
    1cb8:	86 e2       	ldi	r24, 0x26	; 38
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1cc0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1cc4:	18 2f       	mov	r17, r24
    1cc6:	64 e0       	ldi	r22, 0x04	; 4
    1cc8:	86 e2       	ldi	r24, 0x26	; 38
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1cd0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1cd4:	be 01       	movw	r22, r28
    1cd6:	01 c0       	rjmp	.+2      	; 0x1cda <main+0x60>
    1cd8:	66 0f       	add	r22, r22
    1cda:	1a 95       	dec	r17
    1cdc:	ea f7       	brpl	.-6      	; 0x1cd8 <main+0x5e>
    1cde:	43 e0       	ldi	r20, 0x03	; 3
    1ce0:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palSetLineMode(AMB_PRIM, PAL_MODE_INPUT_PULLUP);
    1ce4:	63 e0       	ldi	r22, 0x03	; 3
    1ce6:	86 e2       	ldi	r24, 0x26	; 38
    1ce8:	90 e0       	ldi	r25, 0x00	; 0
    1cea:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1cee:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1cf2:	18 2f       	mov	r17, r24
    1cf4:	63 e0       	ldi	r22, 0x03	; 3
    1cf6:	86 e2       	ldi	r24, 0x26	; 38
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1cfe:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1d02:	be 01       	movw	r22, r28
    1d04:	01 c0       	rjmp	.+2      	; 0x1d08 <main+0x8e>
    1d06:	66 0f       	add	r22, r22
    1d08:	1a 95       	dec	r17
    1d0a:	ea f7       	brpl	.-6      	; 0x1d06 <main+0x8c>
    1d0c:	43 e0       	ldi	r20, 0x03	; 3
    1d0e:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palSetLineMode(AMB_SEC, PAL_MODE_INPUT_PULLUP);
    1d12:	65 e0       	ldi	r22, 0x05	; 5
    1d14:	86 e2       	ldi	r24, 0x26	; 38
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d1c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1d20:	18 2f       	mov	r17, r24
    1d22:	65 e0       	ldi	r22, 0x05	; 5
    1d24:	86 e2       	ldi	r24, 0x26	; 38
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d2c:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1d30:	be 01       	movw	r22, r28
    1d32:	01 c0       	rjmp	.+2      	; 0x1d36 <main+0xbc>
    1d34:	66 0f       	add	r22, r22
    1d36:	1a 95       	dec	r17
    1d38:	ea f7       	brpl	.-6      	; 0x1d34 <main+0xba>
    1d3a:	43 e0       	ldi	r20, 0x03	; 3
    1d3c:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>

  // Pedestre
  palSetLineMode(PEDESTRE_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
    1d40:	63 e0       	ldi	r22, 0x03	; 3
    1d42:	83 e2       	ldi	r24, 0x23	; 35
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d4a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1d4e:	18 2f       	mov	r17, r24
    1d50:	63 e0       	ldi	r22, 0x03	; 3
    1d52:	83 e2       	ldi	r24, 0x23	; 35
    1d54:	90 e0       	ldi	r25, 0x00	; 0
    1d56:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d5a:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1d5e:	be 01       	movw	r22, r28
    1d60:	01 c0       	rjmp	.+2      	; 0x1d64 <main+0xea>
    1d62:	66 0f       	add	r22, r22
    1d64:	1a 95       	dec	r17
    1d66:	ea f7       	brpl	.-6      	; 0x1d62 <main+0xe8>
    1d68:	46 e0       	ldi	r20, 0x06	; 6
    1d6a:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(PEDESTRE_VERDE);
    1d6e:	63 e0       	ldi	r22, 0x03	; 3
    1d70:	83 e2       	ldi	r24, 0x23	; 35
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d78:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1d7c:	18 2f       	mov	r17, r24
    1d7e:	63 e0       	ldi	r22, 0x03	; 3
    1d80:	83 e2       	ldi	r24, 0x23	; 35
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1d88:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	92 81       	ldd	r25, Z+2	; 0x02
    1d90:	9e 01       	movw	r18, r28
    1d92:	02 c0       	rjmp	.+4      	; 0x1d98 <main+0x11e>
    1d94:	22 0f       	add	r18, r18
    1d96:	33 1f       	adc	r19, r19
    1d98:	1a 95       	dec	r17
    1d9a:	e2 f7       	brpl	.-8      	; 0x1d94 <main+0x11a>
    1d9c:	20 95       	com	r18
    1d9e:	30 95       	com	r19
    1da0:	92 23       	and	r25, r18
    1da2:	92 83       	std	Z+2, r25	; 0x02
  palSetLineMode(PEDESTRE_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
    1da4:	62 e0       	ldi	r22, 0x02	; 2
    1da6:	83 e2       	ldi	r24, 0x23	; 35
    1da8:	90 e0       	ldi	r25, 0x00	; 0
    1daa:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1dae:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1db2:	18 2f       	mov	r17, r24
    1db4:	62 e0       	ldi	r22, 0x02	; 2
    1db6:	83 e2       	ldi	r24, 0x23	; 35
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1dbe:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1dc2:	be 01       	movw	r22, r28
    1dc4:	01 c0       	rjmp	.+2      	; 0x1dc8 <main+0x14e>
    1dc6:	66 0f       	add	r22, r22
    1dc8:	1a 95       	dec	r17
    1dca:	ea f7       	brpl	.-6      	; 0x1dc6 <main+0x14c>
    1dcc:	46 e0       	ldi	r20, 0x06	; 6
    1dce:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(PEDESTRE_VERMELHO);
    1dd2:	62 e0       	ldi	r22, 0x02	; 2
    1dd4:	83 e2       	ldi	r24, 0x23	; 35
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1ddc:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1de0:	18 2f       	mov	r17, r24
    1de2:	62 e0       	ldi	r22, 0x02	; 2
    1de4:	83 e2       	ldi	r24, 0x23	; 35
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1dec:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1df0:	fc 01       	movw	r30, r24
    1df2:	92 81       	ldd	r25, Z+2	; 0x02
    1df4:	9e 01       	movw	r18, r28
    1df6:	02 c0       	rjmp	.+4      	; 0x1dfc <main+0x182>
    1df8:	22 0f       	add	r18, r18
    1dfa:	33 1f       	adc	r19, r19
    1dfc:	1a 95       	dec	r17
    1dfe:	e2 f7       	brpl	.-8      	; 0x1df8 <main+0x17e>
    1e00:	20 95       	com	r18
    1e02:	30 95       	com	r19
    1e04:	92 23       	and	r25, r18
    1e06:	92 83       	std	Z+2, r25	; 0x02

  // Primário
  palSetLineMode(PRIMARIO_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
    1e08:	67 e0       	ldi	r22, 0x07	; 7
    1e0a:	89 e2       	ldi	r24, 0x29	; 41
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e12:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1e16:	18 2f       	mov	r17, r24
    1e18:	67 e0       	ldi	r22, 0x07	; 7
    1e1a:	89 e2       	ldi	r24, 0x29	; 41
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e22:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1e26:	be 01       	movw	r22, r28
    1e28:	01 c0       	rjmp	.+2      	; 0x1e2c <main+0x1b2>
    1e2a:	66 0f       	add	r22, r22
    1e2c:	1a 95       	dec	r17
    1e2e:	ea f7       	brpl	.-6      	; 0x1e2a <main+0x1b0>
    1e30:	46 e0       	ldi	r20, 0x06	; 6
    1e32:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(PRIMARIO_VERDE);
    1e36:	67 e0       	ldi	r22, 0x07	; 7
    1e38:	89 e2       	ldi	r24, 0x29	; 41
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e40:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1e44:	18 2f       	mov	r17, r24
    1e46:	67 e0       	ldi	r22, 0x07	; 7
    1e48:	89 e2       	ldi	r24, 0x29	; 41
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e50:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1e54:	fc 01       	movw	r30, r24
    1e56:	92 81       	ldd	r25, Z+2	; 0x02
    1e58:	9e 01       	movw	r18, r28
    1e5a:	02 c0       	rjmp	.+4      	; 0x1e60 <main+0x1e6>
    1e5c:	22 0f       	add	r18, r18
    1e5e:	33 1f       	adc	r19, r19
    1e60:	1a 95       	dec	r17
    1e62:	e2 f7       	brpl	.-8      	; 0x1e5c <main+0x1e2>
    1e64:	20 95       	com	r18
    1e66:	30 95       	com	r19
    1e68:	92 23       	and	r25, r18
    1e6a:	92 83       	std	Z+2, r25	; 0x02
  palSetLineMode(PRIMARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
    1e6c:	64 e0       	ldi	r22, 0x04	; 4
    1e6e:	89 e2       	ldi	r24, 0x29	; 41
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e76:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1e7a:	18 2f       	mov	r17, r24
    1e7c:	64 e0       	ldi	r22, 0x04	; 4
    1e7e:	89 e2       	ldi	r24, 0x29	; 41
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1e86:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1e8a:	be 01       	movw	r22, r28
    1e8c:	01 c0       	rjmp	.+2      	; 0x1e90 <main+0x216>
    1e8e:	66 0f       	add	r22, r22
    1e90:	1a 95       	dec	r17
    1e92:	ea f7       	brpl	.-6      	; 0x1e8e <main+0x214>
    1e94:	46 e0       	ldi	r20, 0x06	; 6
    1e96:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(PRIMARIO_AMARELO);
    1e9a:	64 e0       	ldi	r22, 0x04	; 4
    1e9c:	89 e2       	ldi	r24, 0x29	; 41
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1ea4:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1ea8:	18 2f       	mov	r17, r24
    1eaa:	64 e0       	ldi	r22, 0x04	; 4
    1eac:	89 e2       	ldi	r24, 0x29	; 41
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1eb4:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1eb8:	fc 01       	movw	r30, r24
    1eba:	92 81       	ldd	r25, Z+2	; 0x02
    1ebc:	9e 01       	movw	r18, r28
    1ebe:	02 c0       	rjmp	.+4      	; 0x1ec4 <main+0x24a>
    1ec0:	22 0f       	add	r18, r18
    1ec2:	33 1f       	adc	r19, r19
    1ec4:	1a 95       	dec	r17
    1ec6:	e2 f7       	brpl	.-8      	; 0x1ec0 <main+0x246>
    1ec8:	20 95       	com	r18
    1eca:	30 95       	com	r19
    1ecc:	92 23       	and	r25, r18
    1ece:	92 83       	std	Z+2, r25	; 0x02
  palSetLineMode(PRIMARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
    1ed0:	66 e0       	ldi	r22, 0x06	; 6
    1ed2:	89 e2       	ldi	r24, 0x29	; 41
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1eda:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1ede:	18 2f       	mov	r17, r24
    1ee0:	66 e0       	ldi	r22, 0x06	; 6
    1ee2:	89 e2       	ldi	r24, 0x29	; 41
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1eea:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1eee:	be 01       	movw	r22, r28
    1ef0:	01 c0       	rjmp	.+2      	; 0x1ef4 <main+0x27a>
    1ef2:	66 0f       	add	r22, r22
    1ef4:	1a 95       	dec	r17
    1ef6:	ea f7       	brpl	.-6      	; 0x1ef2 <main+0x278>
    1ef8:	46 e0       	ldi	r20, 0x06	; 6
    1efa:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(PRIMARIO_VERMELHO);
    1efe:	66 e0       	ldi	r22, 0x06	; 6
    1f00:	89 e2       	ldi	r24, 0x29	; 41
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f08:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1f0c:	18 2f       	mov	r17, r24
    1f0e:	66 e0       	ldi	r22, 0x06	; 6
    1f10:	89 e2       	ldi	r24, 0x29	; 41
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f18:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	92 81       	ldd	r25, Z+2	; 0x02
    1f20:	9e 01       	movw	r18, r28
    1f22:	02 c0       	rjmp	.+4      	; 0x1f28 <main+0x2ae>
    1f24:	22 0f       	add	r18, r18
    1f26:	33 1f       	adc	r19, r19
    1f28:	1a 95       	dec	r17
    1f2a:	e2 f7       	brpl	.-8      	; 0x1f24 <main+0x2aa>
    1f2c:	20 95       	com	r18
    1f2e:	30 95       	com	r19
    1f30:	92 23       	and	r25, r18
    1f32:	92 83       	std	Z+2, r25	; 0x02

  // Secundário
  palSetLineMode(SECUNDARIO_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	83 e2       	ldi	r24, 0x23	; 35
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f3e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1f42:	18 2f       	mov	r17, r24
    1f44:	61 e0       	ldi	r22, 0x01	; 1
    1f46:	83 e2       	ldi	r24, 0x23	; 35
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f4e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1f52:	be 01       	movw	r22, r28
    1f54:	01 c0       	rjmp	.+2      	; 0x1f58 <main+0x2de>
    1f56:	66 0f       	add	r22, r22
    1f58:	1a 95       	dec	r17
    1f5a:	ea f7       	brpl	.-6      	; 0x1f56 <main+0x2dc>
    1f5c:	46 e0       	ldi	r20, 0x06	; 6
    1f5e:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(SECUNDARIO_VERDE);
    1f62:	61 e0       	ldi	r22, 0x01	; 1
    1f64:	83 e2       	ldi	r24, 0x23	; 35
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f6c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1f70:	18 2f       	mov	r17, r24
    1f72:	61 e0       	ldi	r22, 0x01	; 1
    1f74:	83 e2       	ldi	r24, 0x23	; 35
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1f7c:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1f80:	fc 01       	movw	r30, r24
    1f82:	92 81       	ldd	r25, Z+2	; 0x02
    1f84:	9e 01       	movw	r18, r28
    1f86:	02 c0       	rjmp	.+4      	; 0x1f8c <main+0x312>
    1f88:	22 0f       	add	r18, r18
    1f8a:	33 1f       	adc	r19, r19
    1f8c:	1a 95       	dec	r17
    1f8e:	e2 f7       	brpl	.-8      	; 0x1f88 <main+0x30e>
    1f90:	20 95       	com	r18
    1f92:	30 95       	com	r19
    1f94:	92 23       	and	r25, r18
    1f96:	92 83       	std	Z+2, r25	; 0x02
  palSetLineMode(SECUNDARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
    1f98:	65 e0       	ldi	r22, 0x05	; 5
    1f9a:	89 e2       	ldi	r24, 0x29	; 41
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1fa2:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1fa6:	18 2f       	mov	r17, r24
    1fa8:	65 e0       	ldi	r22, 0x05	; 5
    1faa:	89 e2       	ldi	r24, 0x29	; 41
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1fb2:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1fb6:	be 01       	movw	r22, r28
    1fb8:	01 c0       	rjmp	.+2      	; 0x1fbc <main+0x342>
    1fba:	66 0f       	add	r22, r22
    1fbc:	1a 95       	dec	r17
    1fbe:	ea f7       	brpl	.-6      	; 0x1fba <main+0x340>
    1fc0:	46 e0       	ldi	r20, 0x06	; 6
    1fc2:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(SECUNDARIO_AMARELO);
    1fc6:	65 e0       	ldi	r22, 0x05	; 5
    1fc8:	89 e2       	ldi	r24, 0x29	; 41
    1fca:	90 e0       	ldi	r25, 0x00	; 0
    1fcc:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1fd0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    1fd4:	18 2f       	mov	r17, r24
    1fd6:	65 e0       	ldi	r22, 0x05	; 5
    1fd8:	89 e2       	ldi	r24, 0x29	; 41
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    1fe0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    1fe4:	fc 01       	movw	r30, r24
    1fe6:	92 81       	ldd	r25, Z+2	; 0x02
    1fe8:	9e 01       	movw	r18, r28
    1fea:	02 c0       	rjmp	.+4      	; 0x1ff0 <main+0x376>
    1fec:	22 0f       	add	r18, r18
    1fee:	33 1f       	adc	r19, r19
    1ff0:	1a 95       	dec	r17
    1ff2:	e2 f7       	brpl	.-8      	; 0x1fec <main+0x372>
    1ff4:	20 95       	com	r18
    1ff6:	30 95       	com	r19
    1ff8:	92 23       	and	r25, r18
    1ffa:	92 83       	std	Z+2, r25	; 0x02
  palSetLineMode(SECUNDARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
    1ffc:	60 e0       	ldi	r22, 0x00	; 0
    1ffe:	83 e2       	ldi	r24, 0x23	; 35
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2006:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    200a:	18 2f       	mov	r17, r24
    200c:	60 e0       	ldi	r22, 0x00	; 0
    200e:	83 e2       	ldi	r24, 0x23	; 35
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2016:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    201a:	be 01       	movw	r22, r28
    201c:	01 c0       	rjmp	.+2      	; 0x2020 <main+0x3a6>
    201e:	66 0f       	add	r22, r22
    2020:	1a 95       	dec	r17
    2022:	ea f7       	brpl	.-6      	; 0x201e <main+0x3a4>
    2024:	46 e0       	ldi	r20, 0x06	; 6
    2026:	0e 94 af 03 	call	0x75e	; 0x75e <_pal_lld_setgroupmode>
  palClearLine(SECUNDARIO_VERMELHO);
    202a:	60 e0       	ldi	r22, 0x00	; 0
    202c:	83 e2       	ldi	r24, 0x23	; 35
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2034:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    2038:	18 2f       	mov	r17, r24
    203a:	60 e0       	ldi	r22, 0x00	; 0
    203c:	83 e2       	ldi	r24, 0x23	; 35
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2044:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    2048:	fc 01       	movw	r30, r24
    204a:	92 81       	ldd	r25, Z+2	; 0x02
    204c:	9e 01       	movw	r18, r28
    204e:	02 c0       	rjmp	.+4      	; 0x2054 <main+0x3da>
    2050:	22 0f       	add	r18, r18
    2052:	33 1f       	adc	r19, r19
    2054:	1a 95       	dec	r17
    2056:	e2 f7       	brpl	.-8      	; 0x2050 <main+0x3d6>
    2058:	20 95       	com	r18
    205a:	30 95       	com	r19
    205c:	29 23       	and	r18, r25
    205e:	22 83       	std	Z+2, r18	; 0x02

  /*
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    2060:	10 e0       	ldi	r17, 0x00	; 0
    2062:	00 e0       	ldi	r16, 0x00	; 0
    2064:	2b ee       	ldi	r18, 0xEB	; 235
    2066:	30 e1       	ldi	r19, 0x10	; 16
    2068:	40 e8       	ldi	r20, 0x80	; 128
    206a:	63 e8       	ldi	r22, 0x83	; 131
    206c:	70 e0       	ldi	r23, 0x00	; 0
    206e:	83 e5       	ldi	r24, 0x53	; 83
    2070:	92 e0       	ldi	r25, 0x02	; 2
    2072:	52 da       	rcall	.-2908   	; 0x1518 <chThdCreateStatic>
    2074:	08 c0       	rjmp	.+16     	; 0x2086 <main+0x40c>

  while (1)
  {
    if (palReadLine(AMB_SEC) == PAL_LOW)
    {
      enqueue(AMB_SECUNDARIO);
    2076:	84 e0       	ldi	r24, 0x04	; 4
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	c6 dd       	rcall	.-1140   	; 0x1c08 <enqueue>
    else if (palReadLine(PED_FLAG) == PAL_LOW)
    {
      enqueue(PEDESTRE);
    }
    /* Debouncing. */
    chThdSleepMilliseconds(200);
    207c:	65 e3       	ldi	r22, 0x35	; 53
    207e:	7c e0       	ldi	r23, 0x0C	; 12
    2080:	80 e0       	ldi	r24, 0x00	; 0
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	c6 da       	rcall	.-2676   	; 0x1612 <chThdSleep>
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);

  while (1)
  {
    if (palReadLine(AMB_SEC) == PAL_LOW)
    2086:	65 e0       	ldi	r22, 0x05	; 5
    2088:	86 e2       	ldi	r24, 0x26	; 38
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2090:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    2094:	fc 01       	movw	r30, r24
    2096:	c0 81       	ld	r28, Z
    2098:	65 e0       	ldi	r22, 0x05	; 5
    209a:	86 e2       	ldi	r24, 0x26	; 38
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    20a2:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    20a6:	2c 2f       	mov	r18, r28
    20a8:	30 e0       	ldi	r19, 0x00	; 0
    20aa:	02 c0       	rjmp	.+4      	; 0x20b0 <main+0x436>
    20ac:	35 95       	asr	r19
    20ae:	27 95       	ror	r18
    20b0:	8a 95       	dec	r24
    20b2:	e2 f7       	brpl	.-8      	; 0x20ac <main+0x432>
    20b4:	20 ff       	sbrs	r18, 0
    20b6:	df cf       	rjmp	.-66     	; 0x2076 <main+0x3fc>
    {
      enqueue(AMB_SECUNDARIO);
    }
    else if (palReadLine(AMB_PRIM) == PAL_LOW)
    20b8:	63 e0       	ldi	r22, 0x03	; 3
    20ba:	86 e2       	ldi	r24, 0x26	; 38
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    20c2:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    20c6:	fc 01       	movw	r30, r24
    20c8:	c0 81       	ld	r28, Z
    20ca:	63 e0       	ldi	r22, 0x03	; 3
    20cc:	86 e2       	ldi	r24, 0x26	; 38
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    20d4:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    20d8:	2c 2f       	mov	r18, r28
    20da:	30 e0       	ldi	r19, 0x00	; 0
    20dc:	02 c0       	rjmp	.+4      	; 0x20e2 <main+0x468>
    20de:	35 95       	asr	r19
    20e0:	27 95       	ror	r18
    20e2:	8a 95       	dec	r24
    20e4:	e2 f7       	brpl	.-8      	; 0x20de <main+0x464>
    20e6:	20 fd       	sbrc	r18, 0
    {
      enqueue(AMB_PRIMARIO);
    20e8:	04 c0       	rjmp	.+8      	; 0x20f2 <main+0x478>
    20ea:	83 e0       	ldi	r24, 0x03	; 3
    20ec:	90 e0       	ldi	r25, 0x00	; 0
    20ee:	8c dd       	rcall	.-1256   	; 0x1c08 <enqueue>
    20f0:	c5 cf       	rjmp	.-118    	; 0x207c <main+0x402>
    }
    else if (palReadLine(SEC_FLAG) == PAL_LOW)
    20f2:	64 e0       	ldi	r22, 0x04	; 4
    20f4:	86 e2       	ldi	r24, 0x26	; 38
    20f6:	90 e0       	ldi	r25, 0x00	; 0
    20f8:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    20fc:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    2100:	fc 01       	movw	r30, r24
    2102:	c0 81       	ld	r28, Z
    2104:	64 e0       	ldi	r22, 0x04	; 4
    2106:	86 e2       	ldi	r24, 0x26	; 38
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    210e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    2112:	2c 2f       	mov	r18, r28
    2114:	30 e0       	ldi	r19, 0x00	; 0
    2116:	02 c0       	rjmp	.+4      	; 0x211c <main+0x4a2>
    2118:	35 95       	asr	r19
    211a:	27 95       	ror	r18
    211c:	8a 95       	dec	r24
    211e:	e2 f7       	brpl	.-8      	; 0x2118 <main+0x49e>
    2120:	20 fd       	sbrc	r18, 0
    {
      enqueue(SECUNDARIO);
    2122:	04 c0       	rjmp	.+8      	; 0x212c <main+0x4b2>
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	6f dd       	rcall	.-1314   	; 0x1c08 <enqueue>
    212a:	a8 cf       	rjmp	.-176    	; 0x207c <main+0x402>
    }
    else if (palReadLine(PED_FLAG) == PAL_LOW)
    212c:	62 e0       	ldi	r22, 0x02	; 2
    212e:	86 e2       	ldi	r24, 0x26	; 38
    2130:	90 e0       	ldi	r25, 0x00	; 0
    2132:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2136:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    213a:	fc 01       	movw	r30, r24
    213c:	c0 81       	ld	r28, Z
    213e:	62 e0       	ldi	r22, 0x02	; 2
    2140:	86 e2       	ldi	r24, 0x26	; 38
    2142:	90 e0       	ldi	r25, 0x00	; 0
    2144:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    2148:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    214c:	2c 2f       	mov	r18, r28
    214e:	30 e0       	ldi	r19, 0x00	; 0
    2150:	02 c0       	rjmp	.+4      	; 0x2156 <main+0x4dc>
    2152:	35 95       	asr	r19
    2154:	27 95       	ror	r18
    2156:	8a 95       	dec	r24
    2158:	e2 f7       	brpl	.-8      	; 0x2152 <main+0x4d8>
    215a:	20 fd       	sbrc	r18, 0
    {
      enqueue(PEDESTRE);
    215c:	8f cf       	rjmp	.-226    	; 0x207c <main+0x402>
    215e:	82 e0       	ldi	r24, 0x02	; 2
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	52 dd       	rcall	.-1372   	; 0x1c08 <enqueue>
    2164:	8b cf       	rjmp	.-234    	; 0x207c <main+0x402>

00002166 <dequeue>:

/*
 * Reads a message from the queue, if the queue is empty waits
 * for a message.
 */
msg_t dequeue(void) {
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
  msg_t msg;
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
    216a:	8e ed       	ldi	r24, 0xDE	; 222
    216c:	92 e0       	ldi	r25, 0x02	; 2
    216e:	76 db       	rcall	.-2324   	; 0x185c <chMtxLock>
 
  /* Waiting for messages in the queue.*/
  while (qsize == 0)
    2170:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <qsize>
    2174:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <qsize+0x1>
    2178:	00 97       	sbiw	r24, 0x00	; 0
    217a:	49 f4       	brne	.+18     	; 0x218e <dequeue+0x28>
    chCondWait(&qempty);
    217c:	8a ed       	ldi	r24, 0xDA	; 218
    217e:	92 e0       	ldi	r25, 0x02	; 2
    2180:	5d dc       	rcall	.-1862   	; 0x1a3c <chCondWait>
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for messages in the queue.*/
  while (qsize == 0)
    2182:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <qsize>
    2186:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <qsize+0x1>
    218a:	00 97       	sbiw	r24, 0x00	; 0
    218c:	b9 f3       	breq	.-18     	; 0x217c <dequeue+0x16>
    chCondWait(&qempty);
 
  /* Reading the message from the queue.*/  
  msg = *rdp;
    218e:	e0 91 ea 02 	lds	r30, 0x02EA	; 0x8002ea <rdp>
    2192:	f0 91 eb 02 	lds	r31, 0x02EB	; 0x8002eb <rdp+0x1>
    2196:	c1 91       	ld	r28, Z+
    2198:	d1 91       	ld	r29, Z+
  if (++rdp >= &queue[QUEUE_SIZE])
    219a:	23 e0       	ldi	r18, 0x03	; 3
    219c:	ec 3e       	cpi	r30, 0xEC	; 236
    219e:	f2 07       	cpc	r31, r18
    21a0:	a8 f0       	brcs	.+42     	; 0x21cc <dequeue+0x66>
    rdp = &queue[0];
    21a2:	2c ee       	ldi	r18, 0xEC	; 236
    21a4:	32 e0       	ldi	r19, 0x02	; 2
    21a6:	30 93 eb 02 	sts	0x02EB, r19	; 0x8002eb <rdp+0x1>
    21aa:	20 93 ea 02 	sts	0x02EA, r18	; 0x8002ea <rdp>
  qsize--;
    21ae:	01 97       	sbiw	r24, 0x01	; 1
    21b0:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <qsize+0x1>
    21b4:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <qsize>
 
  /* Signaling that there is at least one free slot.*/
  chCondSignal(&qfull);
    21b8:	86 ed       	ldi	r24, 0xD6	; 214
    21ba:	92 e0       	ldi	r25, 0x02	; 2
    21bc:	e9 db       	rcall	.-2094   	; 0x1990 <chCondSignal>
 
  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    21be:	8e ed       	ldi	r24, 0xDE	; 222
    21c0:	92 e0       	ldi	r25, 0x02	; 2
    21c2:	50 db       	rcall	.-2400   	; 0x1864 <chMtxUnlock>
    21c4:	ce 01       	movw	r24, r28
 
  return msg;
}
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	08 95       	ret
    21cc:	f0 93 eb 02 	sts	0x02EB, r31	; 0x8002eb <rdp+0x1>
  while (qsize == 0)
    chCondWait(&qempty);
 
  /* Reading the message from the queue.*/  
  msg = *rdp;
  if (++rdp >= &queue[QUEUE_SIZE])
    21d0:	e0 93 ea 02 	sts	0x02EA, r30	; 0x8002ea <rdp>
    21d4:	ec cf       	rjmp	.-40     	; 0x21ae <dequeue+0x48>

000021d6 <Thread1>:
    21d6:	cf 93       	push	r28
 * LED blinker thread, times are in milliseconds.
 */

static THD_WORKING_AREA(waThread1, 32);
static THD_FUNCTION(Thread1, arg)
{
    21d8:	df 93       	push	r29
    21da:	cd b7       	in	r28, 0x3d	; 61
    21dc:	de b7       	in	r29, 0x3e	; 62
    21de:	60 97       	sbiw	r28, 0x10	; 16
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	de bf       	out	0x3e, r29	; 62
    21e6:	0f be       	out	0x3f, r0	; 63
    21e8:	cd bf       	out	0x3d, r28	; 61
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->dlist.next = NULL;
    21ea:	1a 82       	std	Y+2, r1	; 0x02
    21ec:	19 82       	std	Y+1, r1	; 0x01
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    21ee:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	89 2b       	or	r24, r25
    21f6:	a9 f1       	breq	.+106    	; 0x2262 <Thread1+0x8c>
    chVTDoResetI(vtp);
    21f8:	ce 01       	movw	r24, r28
    21fa:	01 96       	adiw	r24, 0x01	; 1
    21fc:	7c 01       	movw	r14, r24
    21fe:	0e 94 5d 06 	call	0xcba	; 0xcba <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    2202:	87 01       	movw	r16, r14
    2204:	2f ec       	ldi	r18, 0xCF	; 207
    2206:	3d e0       	ldi	r19, 0x0D	; 13
    2208:	48 e2       	ldi	r20, 0x28	; 40
    220a:	51 e3       	ldi	r21, 0x31	; 49
    220c:	61 e0       	ldi	r22, 0x01	; 1
    220e:	70 e0       	ldi	r23, 0x00	; 0
    2210:	c7 01       	movw	r24, r14
    2212:	0e 94 4f 06 	call	0xc9e	; 0xc9e <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    2216:	78 94       	sei
  msg_t ev;
  while (1)
  {
    ev = dequeue();
    if (ev == AMB_PRIMARIO){
      palSetLine(PRIMARIO_VERDE);
    2218:	ee 24       	eor	r14, r14
    221a:	e3 94       	inc	r14
    221c:	f1 2c       	mov	r15, r1
    221e:	05 c0       	rjmp	.+10     	; 0x222a <Thread1+0x54>
    }
    chThdSleepMilliseconds(100);
    2220:	6b e1       	ldi	r22, 0x1B	; 27
    2222:	76 e0       	ldi	r23, 0x06	; 6
    2224:	80 e0       	ldi	r24, 0x00	; 0
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	f4 d9       	rcall	.-3096   	; 0x1612 <chThdSleep>
  chVTSet(&vt, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, (void *)&vt);

  msg_t ev;
  while (1)
  {
    ev = dequeue();
    222a:	9d df       	rcall	.-198    	; 0x2166 <dequeue>
    222c:	03 97       	sbiw	r24, 0x03	; 3
    if (ev == AMB_PRIMARIO){
    222e:	c1 f7       	brne	.-16     	; 0x2220 <Thread1+0x4a>
    2230:	67 e0       	ldi	r22, 0x07	; 7
      palSetLine(PRIMARIO_VERDE);
    2232:	89 e2       	ldi	r24, 0x29	; 41
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    223a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <_pal_lld_getpadfromline>
    223e:	18 2f       	mov	r17, r24
    2240:	67 e0       	ldi	r22, 0x07	; 7
    2242:	89 e2       	ldi	r24, 0x29	; 41
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_pal_lld_setlineid>
    224a:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <_pal_lld_getportfromline>
    224e:	fc 01       	movw	r30, r24
    2250:	92 81       	ldd	r25, Z+2	; 0x02
    2252:	97 01       	movw	r18, r14
    2254:	01 c0       	rjmp	.+2      	; 0x2258 <Thread1+0x82>
    2256:	22 0f       	add	r18, r18
    2258:	1a 95       	dec	r17
    225a:	ea f7       	brpl	.-6      	; 0x2256 <Thread1+0x80>
    225c:	92 2b       	or	r25, r18
    225e:	92 83       	std	Z+2, r25	; 0x02
    2260:	df cf       	rjmp	.-66     	; 0x2220 <Thread1+0x4a>
    2262:	ce 01       	movw	r24, r28
    2264:	01 96       	adiw	r24, 0x01	; 1
    2266:	7c 01       	movw	r14, r24
    2268:	cc cf       	rjmp	.-104    	; 0x2202 <Thread1+0x2c>

0000226a <vfprintf>:
    226a:	ab e0       	ldi	r26, 0x0B	; 11
    226c:	b0 e0       	ldi	r27, 0x00	; 0
    226e:	ea e3       	ldi	r30, 0x3A	; 58
    2270:	f1 e1       	ldi	r31, 0x11	; 17
    2272:	c4 c2       	rjmp	.+1416   	; 0x27fc <__prologue_saves__+0x8>
    2274:	6c 01       	movw	r12, r24
    2276:	7b 01       	movw	r14, r22
    2278:	3a 01       	movw	r6, r20
    227a:	fc 01       	movw	r30, r24
    227c:	17 82       	std	Z+7, r1	; 0x07
    227e:	16 82       	std	Z+6, r1	; 0x06
    2280:	83 81       	ldd	r24, Z+3	; 0x03
    2282:	81 ff       	sbrs	r24, 1
    2284:	ff c0       	rjmp	.+510    	; 0x2484 <vfprintf+0x21a>
    2286:	ce 01       	movw	r24, r28
    2288:	01 96       	adiw	r24, 0x01	; 1
    228a:	4c 01       	movw	r8, r24
    228c:	f6 01       	movw	r30, r12
    228e:	b3 80       	ldd	r11, Z+3	; 0x03
    2290:	f7 01       	movw	r30, r14
    2292:	b3 fc       	sbrc	r11, 3
    2294:	05 91       	lpm	r16, Z+
    2296:	b3 fe       	sbrs	r11, 3
    2298:	01 91       	ld	r16, Z+
    229a:	7f 01       	movw	r14, r30
    229c:	00 23       	and	r16, r16
    229e:	41 f1       	breq	.+80     	; 0x22f0 <vfprintf+0x86>
    22a0:	05 32       	cpi	r16, 0x25	; 37
    22a2:	39 f4       	brne	.+14     	; 0x22b2 <vfprintf+0x48>
    22a4:	b3 fc       	sbrc	r11, 3
    22a6:	05 91       	lpm	r16, Z+
    22a8:	b3 fe       	sbrs	r11, 3
    22aa:	01 91       	ld	r16, Z+
    22ac:	7f 01       	movw	r14, r30
    22ae:	05 32       	cpi	r16, 0x25	; 37
    22b0:	39 f5       	brne	.+78     	; 0x2300 <vfprintf+0x96>
    22b2:	b6 01       	movw	r22, r12
    22b4:	80 2f       	mov	r24, r16
    22b6:	90 e0       	ldi	r25, 0x00	; 0
    22b8:	2c d3       	rcall	.+1624   	; 0x2912 <fputc>
    22ba:	53 01       	movw	r10, r6
    22bc:	35 01       	movw	r6, r10
    22be:	e6 cf       	rjmp	.-52     	; 0x228c <vfprintf+0x22>
    22c0:	10 68       	ori	r17, 0x80	; 128
    22c2:	f7 01       	movw	r30, r14
    22c4:	b3 fc       	sbrc	r11, 3
    22c6:	05 91       	lpm	r16, Z+
    22c8:	b3 fe       	sbrs	r11, 3
    22ca:	01 91       	ld	r16, Z+
    22cc:	7f 01       	movw	r14, r30
    22ce:	17 fd       	sbrc	r17, 7
    22d0:	0d c0       	rjmp	.+26     	; 0x22ec <vfprintf+0x82>
    22d2:	00 23       	and	r16, r16
    22d4:	69 f0       	breq	.+26     	; 0x22f0 <vfprintf+0x86>
    22d6:	60 2f       	mov	r22, r16
    22d8:	70 e0       	ldi	r23, 0x00	; 0
    22da:	8f e6       	ldi	r24, 0x6F	; 111
    22dc:	90 e0       	ldi	r25, 0x00	; 0
    22de:	c9 d2       	rcall	.+1426   	; 0x2872 <strchr_P>
    22e0:	89 2b       	or	r24, r25
    22e2:	79 f7       	brne	.-34     	; 0x22c2 <vfprintf+0x58>
    22e4:	03 32       	cpi	r16, 0x23	; 35
    22e6:	51 f0       	breq	.+20     	; 0x22fc <vfprintf+0x92>
    22e8:	0c 36       	cpi	r16, 0x6C	; 108
    22ea:	51 f3       	breq	.-44     	; 0x22c0 <vfprintf+0x56>
    22ec:	01 11       	cpse	r16, r1
    22ee:	0a c0       	rjmp	.+20     	; 0x2304 <vfprintf+0x9a>
    22f0:	f6 01       	movw	r30, r12
    22f2:	86 81       	ldd	r24, Z+6	; 0x06
    22f4:	97 81       	ldd	r25, Z+7	; 0x07
    22f6:	2b 96       	adiw	r28, 0x0b	; 11
    22f8:	ee e0       	ldi	r30, 0x0E	; 14
    22fa:	9c c2       	rjmp	.+1336   	; 0x2834 <__epilogue_restores__+0x8>
    22fc:	10 e1       	ldi	r17, 0x10	; 16
    22fe:	e1 cf       	rjmp	.-62     	; 0x22c2 <vfprintf+0x58>
    2300:	10 e0       	ldi	r17, 0x00	; 0
    2302:	e5 cf       	rjmp	.-54     	; 0x22ce <vfprintf+0x64>
    2304:	60 2f       	mov	r22, r16
    2306:	70 e0       	ldi	r23, 0x00	; 0
    2308:	88 e6       	ldi	r24, 0x68	; 104
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	b2 d2       	rcall	.+1380   	; 0x2872 <strchr_P>
    230e:	89 2b       	or	r24, r25
    2310:	49 f0       	breq	.+18     	; 0x2324 <vfprintf+0xba>
    2312:	53 01       	movw	r10, r6
    2314:	f4 e0       	ldi	r31, 0x04	; 4
    2316:	af 0e       	add	r10, r31
    2318:	b1 1c       	adc	r11, r1
    231a:	b6 01       	movw	r22, r12
    231c:	8f e3       	ldi	r24, 0x3F	; 63
    231e:	90 e0       	ldi	r25, 0x00	; 0
    2320:	f8 d2       	rcall	.+1520   	; 0x2912 <fputc>
    2322:	cc cf       	rjmp	.-104    	; 0x22bc <vfprintf+0x52>
    2324:	03 36       	cpi	r16, 0x63	; 99
    2326:	09 f4       	brne	.+2      	; 0x232a <vfprintf+0xc0>
    2328:	52 c0       	rjmp	.+164    	; 0x23ce <vfprintf+0x164>
    232a:	03 37       	cpi	r16, 0x73	; 115
    232c:	09 f4       	brne	.+2      	; 0x2330 <vfprintf+0xc6>
    232e:	59 c0       	rjmp	.+178    	; 0x23e2 <vfprintf+0x178>
    2330:	03 35       	cpi	r16, 0x53	; 83
    2332:	09 f4       	brne	.+2      	; 0x2336 <vfprintf+0xcc>
    2334:	55 c0       	rjmp	.+170    	; 0x23e0 <vfprintf+0x176>
    2336:	04 36       	cpi	r16, 0x64	; 100
    2338:	19 f0       	breq	.+6      	; 0x2340 <vfprintf+0xd6>
    233a:	09 36       	cpi	r16, 0x69	; 105
    233c:	09 f0       	breq	.+2      	; 0x2340 <vfprintf+0xd6>
    233e:	70 c0       	rjmp	.+224    	; 0x2420 <vfprintf+0x1b6>
    2340:	53 01       	movw	r10, r6
    2342:	17 ff       	sbrs	r17, 7
    2344:	62 c0       	rjmp	.+196    	; 0x240a <vfprintf+0x1a0>
    2346:	f4 e0       	ldi	r31, 0x04	; 4
    2348:	af 0e       	add	r10, r31
    234a:	b1 1c       	adc	r11, r1
    234c:	f3 01       	movw	r30, r6
    234e:	60 81       	ld	r22, Z
    2350:	71 81       	ldd	r23, Z+1	; 0x01
    2352:	82 81       	ldd	r24, Z+2	; 0x02
    2354:	93 81       	ldd	r25, Z+3	; 0x03
    2356:	1f 7e       	andi	r17, 0xEF	; 239
    2358:	97 ff       	sbrs	r25, 7
    235a:	08 c0       	rjmp	.+16     	; 0x236c <vfprintf+0x102>
    235c:	90 95       	com	r25
    235e:	80 95       	com	r24
    2360:	70 95       	com	r23
    2362:	61 95       	neg	r22
    2364:	7f 4f       	sbci	r23, 0xFF	; 255
    2366:	8f 4f       	sbci	r24, 0xFF	; 255
    2368:	9f 4f       	sbci	r25, 0xFF	; 255
    236a:	10 64       	ori	r17, 0x40	; 64
    236c:	2a e0       	ldi	r18, 0x0A	; 10
    236e:	30 e0       	ldi	r19, 0x00	; 0
    2370:	a4 01       	movw	r20, r8
    2372:	17 d3       	rcall	.+1582   	; 0x29a2 <__ultoa_invert>
    2374:	08 2f       	mov	r16, r24
    2376:	08 19       	sub	r16, r8
    2378:	16 ff       	sbrs	r17, 6
    237a:	04 c0       	rjmp	.+8      	; 0x2384 <vfprintf+0x11a>
    237c:	b6 01       	movw	r22, r12
    237e:	8d e2       	ldi	r24, 0x2D	; 45
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	c7 d2       	rcall	.+1422   	; 0x2912 <fputc>
    2384:	14 ff       	sbrs	r17, 4
    2386:	13 c0       	rjmp	.+38     	; 0x23ae <vfprintf+0x144>
    2388:	fe 01       	movw	r30, r28
    238a:	e0 0f       	add	r30, r16
    238c:	f1 1d       	adc	r31, r1
    238e:	80 81       	ld	r24, Z
    2390:	80 33       	cpi	r24, 0x30	; 48
    2392:	69 f0       	breq	.+26     	; 0x23ae <vfprintf+0x144>
    2394:	b6 01       	movw	r22, r12
    2396:	80 e3       	ldi	r24, 0x30	; 48
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	bb d2       	rcall	.+1398   	; 0x2912 <fputc>
    239c:	12 ff       	sbrs	r17, 2
    239e:	07 c0       	rjmp	.+14     	; 0x23ae <vfprintf+0x144>
    23a0:	10 72       	andi	r17, 0x20	; 32
    23a2:	81 2f       	mov	r24, r17
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	b6 01       	movw	r22, r12
    23a8:	88 5a       	subi	r24, 0xA8	; 168
    23aa:	9f 4f       	sbci	r25, 0xFF	; 255
    23ac:	b2 d2       	rcall	.+1380   	; 0x2912 <fputc>
    23ae:	01 50       	subi	r16, 0x01	; 1
    23b0:	10 e0       	ldi	r17, 0x00	; 0
    23b2:	0f 5f       	subi	r16, 0xFF	; 255
    23b4:	1f 4f       	sbci	r17, 0xFF	; 255
    23b6:	08 0d       	add	r16, r8
    23b8:	19 1d       	adc	r17, r9
    23ba:	f8 01       	movw	r30, r16
    23bc:	82 91       	ld	r24, -Z
    23be:	8f 01       	movw	r16, r30
    23c0:	b6 01       	movw	r22, r12
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	a6 d2       	rcall	.+1356   	; 0x2912 <fputc>
    23c6:	08 15       	cp	r16, r8
    23c8:	19 05       	cpc	r17, r9
    23ca:	b9 f7       	brne	.-18     	; 0x23ba <vfprintf+0x150>
    23cc:	77 cf       	rjmp	.-274    	; 0x22bc <vfprintf+0x52>
    23ce:	53 01       	movw	r10, r6
    23d0:	82 e0       	ldi	r24, 0x02	; 2
    23d2:	a8 0e       	add	r10, r24
    23d4:	b1 1c       	adc	r11, r1
    23d6:	b6 01       	movw	r22, r12
    23d8:	f3 01       	movw	r30, r6
    23da:	80 81       	ld	r24, Z
    23dc:	91 81       	ldd	r25, Z+1	; 0x01
    23de:	a0 cf       	rjmp	.-192    	; 0x2320 <vfprintf+0xb6>
    23e0:	11 60       	ori	r17, 0x01	; 1
    23e2:	53 01       	movw	r10, r6
    23e4:	f2 e0       	ldi	r31, 0x02	; 2
    23e6:	af 0e       	add	r10, r31
    23e8:	b1 1c       	adc	r11, r1
    23ea:	f3 01       	movw	r30, r6
    23ec:	60 80       	ld	r6, Z
    23ee:	71 80       	ldd	r7, Z+1	; 0x01
    23f0:	f3 01       	movw	r30, r6
    23f2:	10 fd       	sbrc	r17, 0
    23f4:	85 91       	lpm	r24, Z+
    23f6:	10 ff       	sbrs	r17, 0
    23f8:	81 91       	ld	r24, Z+
    23fa:	3f 01       	movw	r6, r30
    23fc:	88 23       	and	r24, r24
    23fe:	09 f4       	brne	.+2      	; 0x2402 <vfprintf+0x198>
    2400:	5d cf       	rjmp	.-326    	; 0x22bc <vfprintf+0x52>
    2402:	b6 01       	movw	r22, r12
    2404:	90 e0       	ldi	r25, 0x00	; 0
    2406:	85 d2       	rcall	.+1290   	; 0x2912 <fputc>
    2408:	f3 cf       	rjmp	.-26     	; 0x23f0 <vfprintf+0x186>
    240a:	f2 e0       	ldi	r31, 0x02	; 2
    240c:	af 0e       	add	r10, r31
    240e:	b1 1c       	adc	r11, r1
    2410:	f3 01       	movw	r30, r6
    2412:	60 81       	ld	r22, Z
    2414:	71 81       	ldd	r23, Z+1	; 0x01
    2416:	07 2e       	mov	r0, r23
    2418:	00 0c       	add	r0, r0
    241a:	88 0b       	sbc	r24, r24
    241c:	99 0b       	sbc	r25, r25
    241e:	9b cf       	rjmp	.-202    	; 0x2356 <vfprintf+0xec>
    2420:	00 37       	cpi	r16, 0x70	; 112
    2422:	09 f1       	breq	.+66     	; 0x2466 <vfprintf+0x1fc>
    2424:	40 f4       	brcc	.+16     	; 0x2436 <vfprintf+0x1cc>
    2426:	08 35       	cpi	r16, 0x58	; 88
    2428:	01 f1       	breq	.+64     	; 0x246a <vfprintf+0x200>
    242a:	0f 36       	cpi	r16, 0x6F	; 111
    242c:	09 f0       	breq	.+2      	; 0x2430 <vfprintf+0x1c6>
    242e:	60 cf       	rjmp	.-320    	; 0x22f0 <vfprintf+0x86>
    2430:	28 e0       	ldi	r18, 0x08	; 8
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	0c c0       	rjmp	.+24     	; 0x244e <vfprintf+0x1e4>
    2436:	05 37       	cpi	r16, 0x75	; 117
    2438:	39 f0       	breq	.+14     	; 0x2448 <vfprintf+0x1de>
    243a:	08 37       	cpi	r16, 0x78	; 120
    243c:	09 f0       	breq	.+2      	; 0x2440 <vfprintf+0x1d6>
    243e:	58 cf       	rjmp	.-336    	; 0x22f0 <vfprintf+0x86>
    2440:	14 62       	ori	r17, 0x24	; 36
    2442:	20 e1       	ldi	r18, 0x10	; 16
    2444:	30 e0       	ldi	r19, 0x00	; 0
    2446:	03 c0       	rjmp	.+6      	; 0x244e <vfprintf+0x1e4>
    2448:	1f 7e       	andi	r17, 0xEF	; 239
    244a:	2a e0       	ldi	r18, 0x0A	; 10
    244c:	30 e0       	ldi	r19, 0x00	; 0
    244e:	53 01       	movw	r10, r6
    2450:	17 ff       	sbrs	r17, 7
    2452:	0f c0       	rjmp	.+30     	; 0x2472 <vfprintf+0x208>
    2454:	f4 e0       	ldi	r31, 0x04	; 4
    2456:	af 0e       	add	r10, r31
    2458:	b1 1c       	adc	r11, r1
    245a:	f3 01       	movw	r30, r6
    245c:	60 81       	ld	r22, Z
    245e:	71 81       	ldd	r23, Z+1	; 0x01
    2460:	82 81       	ldd	r24, Z+2	; 0x02
    2462:	93 81       	ldd	r25, Z+3	; 0x03
    2464:	85 cf       	rjmp	.-246    	; 0x2370 <vfprintf+0x106>
    2466:	10 61       	ori	r17, 0x10	; 16
    2468:	eb cf       	rjmp	.-42     	; 0x2440 <vfprintf+0x1d6>
    246a:	14 60       	ori	r17, 0x04	; 4
    246c:	20 e1       	ldi	r18, 0x10	; 16
    246e:	32 e0       	ldi	r19, 0x02	; 2
    2470:	ee cf       	rjmp	.-36     	; 0x244e <vfprintf+0x1e4>
    2472:	f2 e0       	ldi	r31, 0x02	; 2
    2474:	af 0e       	add	r10, r31
    2476:	b1 1c       	adc	r11, r1
    2478:	f3 01       	movw	r30, r6
    247a:	60 81       	ld	r22, Z
    247c:	71 81       	ldd	r23, Z+1	; 0x01
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	80 e0       	ldi	r24, 0x00	; 0
    2482:	76 cf       	rjmp	.-276    	; 0x2370 <vfprintf+0x106>
    2484:	8f ef       	ldi	r24, 0xFF	; 255
    2486:	9f ef       	ldi	r25, 0xFF	; 255
    2488:	36 cf       	rjmp	.-404    	; 0x22f6 <vfprintf+0x8c>

0000248a <putval>:
    248a:	20 fd       	sbrc	r18, 0
    248c:	09 c0       	rjmp	.+18     	; 0x24a0 <putval+0x16>
    248e:	fc 01       	movw	r30, r24
    2490:	23 fd       	sbrc	r18, 3
    2492:	05 c0       	rjmp	.+10     	; 0x249e <putval+0x14>
    2494:	22 ff       	sbrs	r18, 2
    2496:	02 c0       	rjmp	.+4      	; 0x249c <putval+0x12>
    2498:	73 83       	std	Z+3, r23	; 0x03
    249a:	62 83       	std	Z+2, r22	; 0x02
    249c:	51 83       	std	Z+1, r21	; 0x01
    249e:	40 83       	st	Z, r20
    24a0:	08 95       	ret

000024a2 <mulacc>:
    24a2:	44 fd       	sbrc	r20, 4
    24a4:	17 c0       	rjmp	.+46     	; 0x24d4 <mulacc+0x32>
    24a6:	46 fd       	sbrc	r20, 6
    24a8:	1d c0       	rjmp	.+58     	; 0x24e4 <mulacc+0x42>
    24aa:	db 01       	movw	r26, r22
    24ac:	fc 01       	movw	r30, r24
    24ae:	aa 0f       	add	r26, r26
    24b0:	bb 1f       	adc	r27, r27
    24b2:	ee 1f       	adc	r30, r30
    24b4:	ff 1f       	adc	r31, r31
    24b6:	10 94       	com	r1
    24b8:	d1 f7       	brne	.-12     	; 0x24ae <mulacc+0xc>
    24ba:	6a 0f       	add	r22, r26
    24bc:	7b 1f       	adc	r23, r27
    24be:	8e 1f       	adc	r24, r30
    24c0:	9f 1f       	adc	r25, r31
    24c2:	66 0f       	add	r22, r22
    24c4:	77 1f       	adc	r23, r23
    24c6:	88 1f       	adc	r24, r24
    24c8:	99 1f       	adc	r25, r25
    24ca:	62 0f       	add	r22, r18
    24cc:	71 1d       	adc	r23, r1
    24ce:	81 1d       	adc	r24, r1
    24d0:	91 1d       	adc	r25, r1
    24d2:	08 95       	ret
    24d4:	33 e0       	ldi	r19, 0x03	; 3
    24d6:	66 0f       	add	r22, r22
    24d8:	77 1f       	adc	r23, r23
    24da:	88 1f       	adc	r24, r24
    24dc:	99 1f       	adc	r25, r25
    24de:	31 50       	subi	r19, 0x01	; 1
    24e0:	d1 f7       	brne	.-12     	; 0x24d6 <mulacc+0x34>
    24e2:	f3 cf       	rjmp	.-26     	; 0x24ca <mulacc+0x28>
    24e4:	34 e0       	ldi	r19, 0x04	; 4
    24e6:	f7 cf       	rjmp	.-18     	; 0x24d6 <mulacc+0x34>

000024e8 <skip_spaces>:
    24e8:	0f 93       	push	r16
    24ea:	1f 93       	push	r17
    24ec:	cf 93       	push	r28
    24ee:	df 93       	push	r29
    24f0:	8c 01       	movw	r16, r24
    24f2:	c8 01       	movw	r24, r16
    24f4:	d2 d1       	rcall	.+932    	; 0x289a <fgetc>
    24f6:	ec 01       	movw	r28, r24
    24f8:	97 fd       	sbrc	r25, 7
    24fa:	06 c0       	rjmp	.+12     	; 0x2508 <skip_spaces+0x20>
    24fc:	b2 d1       	rcall	.+868    	; 0x2862 <isspace>
    24fe:	89 2b       	or	r24, r25
    2500:	c1 f7       	brne	.-16     	; 0x24f2 <skip_spaces+0xa>
    2502:	b8 01       	movw	r22, r16
    2504:	ce 01       	movw	r24, r28
    2506:	35 d2       	rcall	.+1130   	; 0x2972 <ungetc>
    2508:	ce 01       	movw	r24, r28
    250a:	df 91       	pop	r29
    250c:	cf 91       	pop	r28
    250e:	1f 91       	pop	r17
    2510:	0f 91       	pop	r16
    2512:	08 95       	ret

00002514 <conv_int>:
    2514:	8f 92       	push	r8
    2516:	9f 92       	push	r9
    2518:	af 92       	push	r10
    251a:	bf 92       	push	r11
    251c:	ef 92       	push	r14
    251e:	ff 92       	push	r15
    2520:	0f 93       	push	r16
    2522:	1f 93       	push	r17
    2524:	cf 93       	push	r28
    2526:	df 93       	push	r29
    2528:	8c 01       	movw	r16, r24
    252a:	d6 2f       	mov	r29, r22
    252c:	7a 01       	movw	r14, r20
    252e:	b2 2e       	mov	r11, r18
    2530:	b4 d1       	rcall	.+872    	; 0x289a <fgetc>
    2532:	9c 01       	movw	r18, r24
    2534:	33 27       	eor	r19, r19
    2536:	2b 32       	cpi	r18, 0x2B	; 43
    2538:	31 05       	cpc	r19, r1
    253a:	29 f0       	breq	.+10     	; 0x2546 <conv_int+0x32>
    253c:	2d 32       	cpi	r18, 0x2D	; 45
    253e:	31 05       	cpc	r19, r1
    2540:	a1 f4       	brne	.+40     	; 0x256a <conv_int+0x56>
    2542:	68 94       	set
    2544:	b7 f8       	bld	r11, 7
    2546:	d1 50       	subi	r29, 0x01	; 1
    2548:	61 f4       	brne	.+24     	; 0x2562 <conv_int+0x4e>
    254a:	80 e0       	ldi	r24, 0x00	; 0
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	ff 90       	pop	r15
    2556:	ef 90       	pop	r14
    2558:	bf 90       	pop	r11
    255a:	af 90       	pop	r10
    255c:	9f 90       	pop	r9
    255e:	8f 90       	pop	r8
    2560:	08 95       	ret
    2562:	c8 01       	movw	r24, r16
    2564:	9a d1       	rcall	.+820    	; 0x289a <fgetc>
    2566:	97 fd       	sbrc	r25, 7
    2568:	f0 cf       	rjmp	.-32     	; 0x254a <conv_int+0x36>
    256a:	cb 2d       	mov	r28, r11
    256c:	cd 7f       	andi	r28, 0xFD	; 253
    256e:	2b 2d       	mov	r18, r11
    2570:	20 73       	andi	r18, 0x30	; 48
    2572:	e9 f4       	brne	.+58     	; 0x25ae <conv_int+0x9a>
    2574:	80 33       	cpi	r24, 0x30	; 48
    2576:	d9 f4       	brne	.+54     	; 0x25ae <conv_int+0x9a>
    2578:	aa 24       	eor	r10, r10
    257a:	aa 94       	dec	r10
    257c:	ad 0e       	add	r10, r29
    257e:	79 f0       	breq	.+30     	; 0x259e <conv_int+0x8a>
    2580:	c8 01       	movw	r24, r16
    2582:	8b d1       	rcall	.+790    	; 0x289a <fgetc>
    2584:	97 fd       	sbrc	r25, 7
    2586:	0b c0       	rjmp	.+22     	; 0x259e <conv_int+0x8a>
    2588:	28 2f       	mov	r18, r24
    258a:	2f 7d       	andi	r18, 0xDF	; 223
    258c:	28 35       	cpi	r18, 0x58	; 88
    258e:	59 f4       	brne	.+22     	; 0x25a6 <conv_int+0x92>
    2590:	c2 64       	ori	r28, 0x42	; 66
    2592:	d2 50       	subi	r29, 0x02	; 2
    2594:	21 f0       	breq	.+8      	; 0x259e <conv_int+0x8a>
    2596:	c8 01       	movw	r24, r16
    2598:	80 d1       	rcall	.+768    	; 0x289a <fgetc>
    259a:	97 ff       	sbrs	r25, 7
    259c:	08 c0       	rjmp	.+16     	; 0x25ae <conv_int+0x9a>
    259e:	81 2c       	mov	r8, r1
    25a0:	91 2c       	mov	r9, r1
    25a2:	54 01       	movw	r10, r8
    25a4:	1a c0       	rjmp	.+52     	; 0x25da <conv_int+0xc6>
    25a6:	b6 fe       	sbrs	r11, 6
    25a8:	29 c0       	rjmp	.+82     	; 0x25fc <conv_int+0xe8>
    25aa:	c2 60       	ori	r28, 0x02	; 2
    25ac:	da 2d       	mov	r29, r10
    25ae:	81 2c       	mov	r8, r1
    25b0:	91 2c       	mov	r9, r1
    25b2:	54 01       	movw	r10, r8
    25b4:	20 ed       	ldi	r18, 0xD0	; 208
    25b6:	28 0f       	add	r18, r24
    25b8:	28 30       	cpi	r18, 0x08	; 8
    25ba:	18 f1       	brcs	.+70     	; 0x2602 <conv_int+0xee>
    25bc:	c4 fd       	sbrc	r28, 4
    25be:	09 c0       	rjmp	.+18     	; 0x25d2 <conv_int+0xbe>
    25c0:	2a 30       	cpi	r18, 0x0A	; 10
    25c2:	f8 f0       	brcs	.+62     	; 0x2602 <conv_int+0xee>
    25c4:	c6 ff       	sbrs	r28, 6
    25c6:	05 c0       	rjmp	.+10     	; 0x25d2 <conv_int+0xbe>
    25c8:	2f 7d       	andi	r18, 0xDF	; 223
    25ca:	3f ee       	ldi	r19, 0xEF	; 239
    25cc:	32 0f       	add	r19, r18
    25ce:	36 30       	cpi	r19, 0x06	; 6
    25d0:	b8 f0       	brcs	.+46     	; 0x2600 <conv_int+0xec>
    25d2:	b8 01       	movw	r22, r16
    25d4:	ce d1       	rcall	.+924    	; 0x2972 <ungetc>
    25d6:	c1 ff       	sbrs	r28, 1
    25d8:	b8 cf       	rjmp	.-144    	; 0x254a <conv_int+0x36>
    25da:	c7 ff       	sbrs	r28, 7
    25dc:	08 c0       	rjmp	.+16     	; 0x25ee <conv_int+0xda>
    25de:	b0 94       	com	r11
    25e0:	a0 94       	com	r10
    25e2:	90 94       	com	r9
    25e4:	80 94       	com	r8
    25e6:	81 1c       	adc	r8, r1
    25e8:	91 1c       	adc	r9, r1
    25ea:	a1 1c       	adc	r10, r1
    25ec:	b1 1c       	adc	r11, r1
    25ee:	2c 2f       	mov	r18, r28
    25f0:	b5 01       	movw	r22, r10
    25f2:	a4 01       	movw	r20, r8
    25f4:	c7 01       	movw	r24, r14
    25f6:	49 df       	rcall	.-366    	; 0x248a <putval>
    25f8:	81 e0       	ldi	r24, 0x01	; 1
    25fa:	a8 cf       	rjmp	.-176    	; 0x254c <conv_int+0x38>
    25fc:	c2 61       	ori	r28, 0x12	; 18
    25fe:	d6 cf       	rjmp	.-84     	; 0x25ac <conv_int+0x98>
    2600:	27 50       	subi	r18, 0x07	; 7
    2602:	4c 2f       	mov	r20, r28
    2604:	c5 01       	movw	r24, r10
    2606:	b4 01       	movw	r22, r8
    2608:	4c df       	rcall	.-360    	; 0x24a2 <mulacc>
    260a:	4b 01       	movw	r8, r22
    260c:	5c 01       	movw	r10, r24
    260e:	c2 60       	ori	r28, 0x02	; 2
    2610:	d1 50       	subi	r29, 0x01	; 1
    2612:	19 f3       	breq	.-58     	; 0x25da <conv_int+0xc6>
    2614:	c8 01       	movw	r24, r16
    2616:	41 d1       	rcall	.+642    	; 0x289a <fgetc>
    2618:	97 ff       	sbrs	r25, 7
    261a:	cc cf       	rjmp	.-104    	; 0x25b4 <conv_int+0xa0>
    261c:	dc cf       	rjmp	.-72     	; 0x25d6 <conv_int+0xc2>

0000261e <vfscanf>:
    261e:	b0 e0       	ldi	r27, 0x00	; 0
    2620:	a0 e0       	ldi	r26, 0x00	; 0
    2622:	e4 e1       	ldi	r30, 0x14	; 20
    2624:	f3 e1       	ldi	r31, 0x13	; 19
    2626:	e9 c0       	rjmp	.+466    	; 0x27fa <__prologue_saves__+0x6>
    2628:	6c 01       	movw	r12, r24
    262a:	eb 01       	movw	r28, r22
    262c:	5a 01       	movw	r10, r20
    262e:	fc 01       	movw	r30, r24
    2630:	17 82       	std	Z+7, r1	; 0x07
    2632:	16 82       	std	Z+6, r1	; 0x06
    2634:	51 2c       	mov	r5, r1
    2636:	f6 01       	movw	r30, r12
    2638:	f3 80       	ldd	r15, Z+3	; 0x03
    263a:	fe 01       	movw	r30, r28
    263c:	f3 fc       	sbrc	r15, 3
    263e:	85 91       	lpm	r24, Z+
    2640:	f3 fe       	sbrs	r15, 3
    2642:	81 91       	ld	r24, Z+
    2644:	18 2f       	mov	r17, r24
    2646:	ef 01       	movw	r28, r30
    2648:	88 23       	and	r24, r24
    264a:	c9 f0       	breq	.+50     	; 0x267e <vfscanf+0x60>
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	09 d1       	rcall	.+530    	; 0x2862 <isspace>
    2650:	89 2b       	or	r24, r25
    2652:	19 f0       	breq	.+6      	; 0x265a <vfscanf+0x3c>
    2654:	c6 01       	movw	r24, r12
    2656:	48 df       	rcall	.-368    	; 0x24e8 <skip_spaces>
    2658:	ee cf       	rjmp	.-36     	; 0x2636 <vfscanf+0x18>
    265a:	15 32       	cpi	r17, 0x25	; 37
    265c:	41 f4       	brne	.+16     	; 0x266e <vfscanf+0x50>
    265e:	fe 01       	movw	r30, r28
    2660:	f3 fc       	sbrc	r15, 3
    2662:	15 91       	lpm	r17, Z+
    2664:	f3 fe       	sbrs	r15, 3
    2666:	11 91       	ld	r17, Z+
    2668:	ef 01       	movw	r28, r30
    266a:	15 32       	cpi	r17, 0x25	; 37
    266c:	59 f4       	brne	.+22     	; 0x2684 <vfscanf+0x66>
    266e:	c6 01       	movw	r24, r12
    2670:	14 d1       	rcall	.+552    	; 0x289a <fgetc>
    2672:	97 fd       	sbrc	r25, 7
    2674:	98 c0       	rjmp	.+304    	; 0x27a6 <vfscanf+0x188>
    2676:	18 17       	cp	r17, r24
    2678:	f1 f2       	breq	.-68     	; 0x2636 <vfscanf+0x18>
    267a:	b6 01       	movw	r22, r12
    267c:	7a d1       	rcall	.+756    	; 0x2972 <ungetc>
    267e:	85 2d       	mov	r24, r5
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	95 c0       	rjmp	.+298    	; 0x27ae <vfscanf+0x190>
    2684:	00 e0       	ldi	r16, 0x00	; 0
    2686:	1a 32       	cpi	r17, 0x2A	; 42
    2688:	31 f4       	brne	.+12     	; 0x2696 <vfscanf+0x78>
    268a:	f3 fc       	sbrc	r15, 3
    268c:	15 91       	lpm	r17, Z+
    268e:	f3 fe       	sbrs	r15, 3
    2690:	11 91       	ld	r17, Z+
    2692:	ef 01       	movw	r28, r30
    2694:	01 e0       	ldi	r16, 0x01	; 1
    2696:	e1 2c       	mov	r14, r1
    2698:	20 ed       	ldi	r18, 0xD0	; 208
    269a:	21 0f       	add	r18, r17
    269c:	2a 30       	cpi	r18, 0x0A	; 10
    269e:	38 f1       	brcs	.+78     	; 0x26ee <vfscanf+0xd0>
    26a0:	01 ff       	sbrs	r16, 1
    26a2:	34 c0       	rjmp	.+104    	; 0x270c <vfscanf+0xee>
    26a4:	ee 20       	and	r14, r14
    26a6:	59 f3       	breq	.-42     	; 0x267e <vfscanf+0x60>
    26a8:	18 36       	cpi	r17, 0x68	; 104
    26aa:	99 f1       	breq	.+102    	; 0x2712 <vfscanf+0xf4>
    26ac:	1c 36       	cpi	r17, 0x6C	; 108
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <vfscanf+0x94>
    26b0:	3a c0       	rjmp	.+116    	; 0x2726 <vfscanf+0x108>
    26b2:	11 23       	and	r17, r17
    26b4:	21 f3       	breq	.-56     	; 0x267e <vfscanf+0x60>
    26b6:	61 2f       	mov	r22, r17
    26b8:	70 e0       	ldi	r23, 0x00	; 0
    26ba:	8f e7       	ldi	r24, 0x7F	; 127
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	d9 d0       	rcall	.+434    	; 0x2872 <strchr_P>
    26c0:	89 2b       	or	r24, r25
    26c2:	e9 f2       	breq	.-70     	; 0x267e <vfscanf+0x60>
    26c4:	91 2c       	mov	r9, r1
    26c6:	81 2c       	mov	r8, r1
    26c8:	00 fd       	sbrc	r16, 0
    26ca:	06 c0       	rjmp	.+12     	; 0x26d8 <vfscanf+0xba>
    26cc:	f5 01       	movw	r30, r10
    26ce:	80 80       	ld	r8, Z
    26d0:	91 80       	ldd	r9, Z+1	; 0x01
    26d2:	c5 01       	movw	r24, r10
    26d4:	02 96       	adiw	r24, 0x02	; 2
    26d6:	5c 01       	movw	r10, r24
    26d8:	1e 36       	cpi	r17, 0x6E	; 110
    26da:	69 f5       	brne	.+90     	; 0x2736 <vfscanf+0x118>
    26dc:	f6 01       	movw	r30, r12
    26de:	46 81       	ldd	r20, Z+6	; 0x06
    26e0:	57 81       	ldd	r21, Z+7	; 0x07
    26e2:	70 e0       	ldi	r23, 0x00	; 0
    26e4:	60 e0       	ldi	r22, 0x00	; 0
    26e6:	20 2f       	mov	r18, r16
    26e8:	c4 01       	movw	r24, r8
    26ea:	cf de       	rcall	.-610    	; 0x248a <putval>
    26ec:	a4 cf       	rjmp	.-184    	; 0x2636 <vfscanf+0x18>
    26ee:	02 60       	ori	r16, 0x02	; 2
    26f0:	6e 2d       	mov	r22, r14
    26f2:	70 e0       	ldi	r23, 0x00	; 0
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	80 e0       	ldi	r24, 0x00	; 0
    26f8:	40 e2       	ldi	r20, 0x20	; 32
    26fa:	d3 de       	rcall	.-602    	; 0x24a2 <mulacc>
    26fc:	e6 2e       	mov	r14, r22
    26fe:	fe 01       	movw	r30, r28
    2700:	f3 fc       	sbrc	r15, 3
    2702:	15 91       	lpm	r17, Z+
    2704:	f3 fe       	sbrs	r15, 3
    2706:	11 91       	ld	r17, Z+
    2708:	ef 01       	movw	r28, r30
    270a:	c6 cf       	rjmp	.-116    	; 0x2698 <vfscanf+0x7a>
    270c:	ee 24       	eor	r14, r14
    270e:	ea 94       	dec	r14
    2710:	cb cf       	rjmp	.-106    	; 0x26a8 <vfscanf+0x8a>
    2712:	fe 01       	movw	r30, r28
    2714:	f3 fc       	sbrc	r15, 3
    2716:	15 91       	lpm	r17, Z+
    2718:	f3 fe       	sbrs	r15, 3
    271a:	11 91       	ld	r17, Z+
    271c:	ef 01       	movw	r28, r30
    271e:	18 36       	cpi	r17, 0x68	; 104
    2720:	09 f0       	breq	.+2      	; 0x2724 <vfscanf+0x106>
    2722:	c7 cf       	rjmp	.-114    	; 0x26b2 <vfscanf+0x94>
    2724:	08 60       	ori	r16, 0x08	; 8
    2726:	04 60       	ori	r16, 0x04	; 4
    2728:	fe 01       	movw	r30, r28
    272a:	f3 fc       	sbrc	r15, 3
    272c:	15 91       	lpm	r17, Z+
    272e:	f3 fe       	sbrs	r15, 3
    2730:	11 91       	ld	r17, Z+
    2732:	ef 01       	movw	r28, r30
    2734:	be cf       	rjmp	.-132    	; 0x26b2 <vfscanf+0x94>
    2736:	13 36       	cpi	r17, 0x63	; 99
    2738:	b9 f4       	brne	.+46     	; 0x2768 <vfscanf+0x14a>
    273a:	01 fd       	sbrc	r16, 1
    273c:	02 c0       	rjmp	.+4      	; 0x2742 <vfscanf+0x124>
    273e:	ee 24       	eor	r14, r14
    2740:	e3 94       	inc	r14
    2742:	c6 01       	movw	r24, r12
    2744:	aa d0       	rcall	.+340    	; 0x289a <fgetc>
    2746:	97 fd       	sbrc	r25, 7
    2748:	2e c0       	rjmp	.+92     	; 0x27a6 <vfscanf+0x188>
    274a:	81 14       	cp	r8, r1
    274c:	91 04       	cpc	r9, r1
    274e:	29 f0       	breq	.+10     	; 0x275a <vfscanf+0x13c>
    2750:	f4 01       	movw	r30, r8
    2752:	80 83       	st	Z, r24
    2754:	c4 01       	movw	r24, r8
    2756:	01 96       	adiw	r24, 0x01	; 1
    2758:	4c 01       	movw	r8, r24
    275a:	ea 94       	dec	r14
    275c:	e1 10       	cpse	r14, r1
    275e:	f1 cf       	rjmp	.-30     	; 0x2742 <vfscanf+0x124>
    2760:	00 fd       	sbrc	r16, 0
    2762:	69 cf       	rjmp	.-302    	; 0x2636 <vfscanf+0x18>
    2764:	53 94       	inc	r5
    2766:	67 cf       	rjmp	.-306    	; 0x2636 <vfscanf+0x18>
    2768:	c6 01       	movw	r24, r12
    276a:	be de       	rcall	.-644    	; 0x24e8 <skip_spaces>
    276c:	97 fd       	sbrc	r25, 7
    276e:	1b c0       	rjmp	.+54     	; 0x27a6 <vfscanf+0x188>
    2770:	1f 36       	cpi	r17, 0x6F	; 111
    2772:	09 f4       	brne	.+2      	; 0x2776 <vfscanf+0x158>
    2774:	3d c0       	rjmp	.+122    	; 0x27f0 <vfscanf+0x1d2>
    2776:	30 f4       	brcc	.+12     	; 0x2784 <vfscanf+0x166>
    2778:	14 36       	cpi	r17, 0x64	; 100
    277a:	41 f0       	breq	.+16     	; 0x278c <vfscanf+0x16e>
    277c:	19 36       	cpi	r17, 0x69	; 105
    277e:	39 f0       	breq	.+14     	; 0x278e <vfscanf+0x170>
    2780:	00 64       	ori	r16, 0x40	; 64
    2782:	05 c0       	rjmp	.+10     	; 0x278e <vfscanf+0x170>
    2784:	13 37       	cpi	r17, 0x73	; 115
    2786:	11 f1       	breq	.+68     	; 0x27cc <vfscanf+0x1ae>
    2788:	15 37       	cpi	r17, 0x75	; 117
    278a:	d1 f7       	brne	.-12     	; 0x2780 <vfscanf+0x162>
    278c:	00 62       	ori	r16, 0x20	; 32
    278e:	20 2f       	mov	r18, r16
    2790:	a4 01       	movw	r20, r8
    2792:	6e 2d       	mov	r22, r14
    2794:	c6 01       	movw	r24, r12
    2796:	be de       	rcall	.-644    	; 0x2514 <conv_int>
    2798:	81 11       	cpse	r24, r1
    279a:	e2 cf       	rjmp	.-60     	; 0x2760 <vfscanf+0x142>
    279c:	f6 01       	movw	r30, r12
    279e:	83 81       	ldd	r24, Z+3	; 0x03
    27a0:	80 73       	andi	r24, 0x30	; 48
    27a2:	09 f4       	brne	.+2      	; 0x27a6 <vfscanf+0x188>
    27a4:	6c cf       	rjmp	.-296    	; 0x267e <vfscanf+0x60>
    27a6:	8f ef       	ldi	r24, 0xFF	; 255
    27a8:	9f ef       	ldi	r25, 0xFF	; 255
    27aa:	51 10       	cpse	r5, r1
    27ac:	68 cf       	rjmp	.-304    	; 0x267e <vfscanf+0x60>
    27ae:	cd b7       	in	r28, 0x3d	; 61
    27b0:	de b7       	in	r29, 0x3e	; 62
    27b2:	ef e0       	ldi	r30, 0x0F	; 15
    27b4:	3e c0       	rjmp	.+124    	; 0x2832 <__epilogue_restores__+0x6>
    27b6:	81 14       	cp	r8, r1
    27b8:	91 04       	cpc	r9, r1
    27ba:	29 f0       	breq	.+10     	; 0x27c6 <vfscanf+0x1a8>
    27bc:	f4 01       	movw	r30, r8
    27be:	60 82       	st	Z, r6
    27c0:	c4 01       	movw	r24, r8
    27c2:	01 96       	adiw	r24, 0x01	; 1
    27c4:	4c 01       	movw	r8, r24
    27c6:	ea 94       	dec	r14
    27c8:	ee 20       	and	r14, r14
    27ca:	59 f0       	breq	.+22     	; 0x27e2 <vfscanf+0x1c4>
    27cc:	c6 01       	movw	r24, r12
    27ce:	65 d0       	rcall	.+202    	; 0x289a <fgetc>
    27d0:	3c 01       	movw	r6, r24
    27d2:	97 fd       	sbrc	r25, 7
    27d4:	06 c0       	rjmp	.+12     	; 0x27e2 <vfscanf+0x1c4>
    27d6:	45 d0       	rcall	.+138    	; 0x2862 <isspace>
    27d8:	89 2b       	or	r24, r25
    27da:	69 f3       	breq	.-38     	; 0x27b6 <vfscanf+0x198>
    27dc:	b6 01       	movw	r22, r12
    27de:	c3 01       	movw	r24, r6
    27e0:	c8 d0       	rcall	.+400    	; 0x2972 <ungetc>
    27e2:	81 14       	cp	r8, r1
    27e4:	91 04       	cpc	r9, r1
    27e6:	09 f4       	brne	.+2      	; 0x27ea <vfscanf+0x1cc>
    27e8:	bb cf       	rjmp	.-138    	; 0x2760 <vfscanf+0x142>
    27ea:	f4 01       	movw	r30, r8
    27ec:	10 82       	st	Z, r1
    27ee:	b8 cf       	rjmp	.-144    	; 0x2760 <vfscanf+0x142>
    27f0:	00 61       	ori	r16, 0x10	; 16
    27f2:	cd cf       	rjmp	.-102    	; 0x278e <vfscanf+0x170>

000027f4 <__prologue_saves__>:
    27f4:	2f 92       	push	r2
    27f6:	3f 92       	push	r3
    27f8:	4f 92       	push	r4
    27fa:	5f 92       	push	r5
    27fc:	6f 92       	push	r6
    27fe:	7f 92       	push	r7
    2800:	8f 92       	push	r8
    2802:	9f 92       	push	r9
    2804:	af 92       	push	r10
    2806:	bf 92       	push	r11
    2808:	cf 92       	push	r12
    280a:	df 92       	push	r13
    280c:	ef 92       	push	r14
    280e:	ff 92       	push	r15
    2810:	0f 93       	push	r16
    2812:	1f 93       	push	r17
    2814:	cf 93       	push	r28
    2816:	df 93       	push	r29
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
    281c:	ca 1b       	sub	r28, r26
    281e:	db 0b       	sbc	r29, r27
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	f8 94       	cli
    2824:	de bf       	out	0x3e, r29	; 62
    2826:	0f be       	out	0x3f, r0	; 63
    2828:	cd bf       	out	0x3d, r28	; 61
    282a:	09 94       	ijmp

0000282c <__epilogue_restores__>:
    282c:	2a 88       	ldd	r2, Y+18	; 0x12
    282e:	39 88       	ldd	r3, Y+17	; 0x11
    2830:	48 88       	ldd	r4, Y+16	; 0x10
    2832:	5f 84       	ldd	r5, Y+15	; 0x0f
    2834:	6e 84       	ldd	r6, Y+14	; 0x0e
    2836:	7d 84       	ldd	r7, Y+13	; 0x0d
    2838:	8c 84       	ldd	r8, Y+12	; 0x0c
    283a:	9b 84       	ldd	r9, Y+11	; 0x0b
    283c:	aa 84       	ldd	r10, Y+10	; 0x0a
    283e:	b9 84       	ldd	r11, Y+9	; 0x09
    2840:	c8 84       	ldd	r12, Y+8	; 0x08
    2842:	df 80       	ldd	r13, Y+7	; 0x07
    2844:	ee 80       	ldd	r14, Y+6	; 0x06
    2846:	fd 80       	ldd	r15, Y+5	; 0x05
    2848:	0c 81       	ldd	r16, Y+4	; 0x04
    284a:	1b 81       	ldd	r17, Y+3	; 0x03
    284c:	aa 81       	ldd	r26, Y+2	; 0x02
    284e:	b9 81       	ldd	r27, Y+1	; 0x01
    2850:	ce 0f       	add	r28, r30
    2852:	d1 1d       	adc	r29, r1
    2854:	0f b6       	in	r0, 0x3f	; 63
    2856:	f8 94       	cli
    2858:	de bf       	out	0x3e, r29	; 62
    285a:	0f be       	out	0x3f, r0	; 63
    285c:	cd bf       	out	0x3d, r28	; 61
    285e:	ed 01       	movw	r28, r26
    2860:	08 95       	ret

00002862 <isspace>:
    2862:	91 11       	cpse	r25, r1
    2864:	fc c0       	rjmp	.+504    	; 0x2a5e <__ctype_isfalse>
    2866:	80 32       	cpi	r24, 0x20	; 32
    2868:	19 f0       	breq	.+6      	; 0x2870 <isspace+0xe>
    286a:	89 50       	subi	r24, 0x09	; 9
    286c:	85 50       	subi	r24, 0x05	; 5
    286e:	d0 f7       	brcc	.-12     	; 0x2864 <isspace+0x2>
    2870:	08 95       	ret

00002872 <strchr_P>:
    2872:	fc 01       	movw	r30, r24
    2874:	05 90       	lpm	r0, Z+
    2876:	06 16       	cp	r0, r22
    2878:	21 f0       	breq	.+8      	; 0x2882 <strchr_P+0x10>
    287a:	00 20       	and	r0, r0
    287c:	d9 f7       	brne	.-10     	; 0x2874 <strchr_P+0x2>
    287e:	c0 01       	movw	r24, r0
    2880:	08 95       	ret
    2882:	31 97       	sbiw	r30, 0x01	; 1
    2884:	cf 01       	movw	r24, r30
    2886:	08 95       	ret

00002888 <memcpy>:
    2888:	fb 01       	movw	r30, r22
    288a:	dc 01       	movw	r26, r24
    288c:	02 c0       	rjmp	.+4      	; 0x2892 <memcpy+0xa>
    288e:	01 90       	ld	r0, Z+
    2890:	0d 92       	st	X+, r0
    2892:	41 50       	subi	r20, 0x01	; 1
    2894:	50 40       	sbci	r21, 0x00	; 0
    2896:	d8 f7       	brcc	.-10     	; 0x288e <memcpy+0x6>
    2898:	08 95       	ret

0000289a <fgetc>:
    289a:	cf 93       	push	r28
    289c:	df 93       	push	r29
    289e:	ec 01       	movw	r28, r24
    28a0:	2b 81       	ldd	r18, Y+3	; 0x03
    28a2:	20 ff       	sbrs	r18, 0
    28a4:	1a c0       	rjmp	.+52     	; 0x28da <fgetc+0x40>
    28a6:	26 ff       	sbrs	r18, 6
    28a8:	0c c0       	rjmp	.+24     	; 0x28c2 <fgetc+0x28>
    28aa:	2f 7b       	andi	r18, 0xBF	; 191
    28ac:	2b 83       	std	Y+3, r18	; 0x03
    28ae:	8e 81       	ldd	r24, Y+6	; 0x06
    28b0:	9f 81       	ldd	r25, Y+7	; 0x07
    28b2:	01 96       	adiw	r24, 0x01	; 1
    28b4:	9f 83       	std	Y+7, r25	; 0x07
    28b6:	8e 83       	std	Y+6, r24	; 0x06
    28b8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	df 91       	pop	r29
    28be:	cf 91       	pop	r28
    28c0:	08 95       	ret
    28c2:	22 ff       	sbrs	r18, 2
    28c4:	18 c0       	rjmp	.+48     	; 0x28f6 <fgetc+0x5c>
    28c6:	e8 81       	ld	r30, Y
    28c8:	f9 81       	ldd	r31, Y+1	; 0x01
    28ca:	80 81       	ld	r24, Z
    28cc:	08 2e       	mov	r0, r24
    28ce:	00 0c       	add	r0, r0
    28d0:	99 0b       	sbc	r25, r25
    28d2:	00 97       	sbiw	r24, 0x00	; 0
    28d4:	29 f4       	brne	.+10     	; 0x28e0 <fgetc+0x46>
    28d6:	20 62       	ori	r18, 0x20	; 32
    28d8:	2b 83       	std	Y+3, r18	; 0x03
    28da:	8f ef       	ldi	r24, 0xFF	; 255
    28dc:	9f ef       	ldi	r25, 0xFF	; 255
    28de:	ee cf       	rjmp	.-36     	; 0x28bc <fgetc+0x22>
    28e0:	31 96       	adiw	r30, 0x01	; 1
    28e2:	f9 83       	std	Y+1, r31	; 0x01
    28e4:	e8 83       	st	Y, r30
    28e6:	2e 81       	ldd	r18, Y+6	; 0x06
    28e8:	3f 81       	ldd	r19, Y+7	; 0x07
    28ea:	2f 5f       	subi	r18, 0xFF	; 255
    28ec:	3f 4f       	sbci	r19, 0xFF	; 255
    28ee:	3f 83       	std	Y+7, r19	; 0x07
    28f0:	2e 83       	std	Y+6, r18	; 0x06
    28f2:	99 27       	eor	r25, r25
    28f4:	e3 cf       	rjmp	.-58     	; 0x28bc <fgetc+0x22>
    28f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    28f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    28fa:	09 95       	icall
    28fc:	97 ff       	sbrs	r25, 7
    28fe:	f3 cf       	rjmp	.-26     	; 0x28e6 <fgetc+0x4c>
    2900:	2b 81       	ldd	r18, Y+3	; 0x03
    2902:	01 96       	adiw	r24, 0x01	; 1
    2904:	21 f0       	breq	.+8      	; 0x290e <fgetc+0x74>
    2906:	80 e2       	ldi	r24, 0x20	; 32
    2908:	82 2b       	or	r24, r18
    290a:	8b 83       	std	Y+3, r24	; 0x03
    290c:	e6 cf       	rjmp	.-52     	; 0x28da <fgetc+0x40>
    290e:	80 e1       	ldi	r24, 0x10	; 16
    2910:	fb cf       	rjmp	.-10     	; 0x2908 <fgetc+0x6e>

00002912 <fputc>:
    2912:	0f 93       	push	r16
    2914:	1f 93       	push	r17
    2916:	cf 93       	push	r28
    2918:	df 93       	push	r29
    291a:	18 2f       	mov	r17, r24
    291c:	09 2f       	mov	r16, r25
    291e:	eb 01       	movw	r28, r22
    2920:	8b 81       	ldd	r24, Y+3	; 0x03
    2922:	81 fd       	sbrc	r24, 1
    2924:	09 c0       	rjmp	.+18     	; 0x2938 <fputc+0x26>
    2926:	1f ef       	ldi	r17, 0xFF	; 255
    2928:	0f ef       	ldi	r16, 0xFF	; 255
    292a:	81 2f       	mov	r24, r17
    292c:	90 2f       	mov	r25, r16
    292e:	df 91       	pop	r29
    2930:	cf 91       	pop	r28
    2932:	1f 91       	pop	r17
    2934:	0f 91       	pop	r16
    2936:	08 95       	ret
    2938:	82 ff       	sbrs	r24, 2
    293a:	14 c0       	rjmp	.+40     	; 0x2964 <fputc+0x52>
    293c:	2e 81       	ldd	r18, Y+6	; 0x06
    293e:	3f 81       	ldd	r19, Y+7	; 0x07
    2940:	8c 81       	ldd	r24, Y+4	; 0x04
    2942:	9d 81       	ldd	r25, Y+5	; 0x05
    2944:	28 17       	cp	r18, r24
    2946:	39 07       	cpc	r19, r25
    2948:	3c f4       	brge	.+14     	; 0x2958 <fputc+0x46>
    294a:	e8 81       	ld	r30, Y
    294c:	f9 81       	ldd	r31, Y+1	; 0x01
    294e:	cf 01       	movw	r24, r30
    2950:	01 96       	adiw	r24, 0x01	; 1
    2952:	99 83       	std	Y+1, r25	; 0x01
    2954:	88 83       	st	Y, r24
    2956:	10 83       	st	Z, r17
    2958:	8e 81       	ldd	r24, Y+6	; 0x06
    295a:	9f 81       	ldd	r25, Y+7	; 0x07
    295c:	01 96       	adiw	r24, 0x01	; 1
    295e:	9f 83       	std	Y+7, r25	; 0x07
    2960:	8e 83       	std	Y+6, r24	; 0x06
    2962:	e3 cf       	rjmp	.-58     	; 0x292a <fputc+0x18>
    2964:	e8 85       	ldd	r30, Y+8	; 0x08
    2966:	f9 85       	ldd	r31, Y+9	; 0x09
    2968:	81 2f       	mov	r24, r17
    296a:	09 95       	icall
    296c:	89 2b       	or	r24, r25
    296e:	a1 f3       	breq	.-24     	; 0x2958 <fputc+0x46>
    2970:	da cf       	rjmp	.-76     	; 0x2926 <fputc+0x14>

00002972 <ungetc>:
    2972:	fb 01       	movw	r30, r22
    2974:	23 81       	ldd	r18, Z+3	; 0x03
    2976:	20 ff       	sbrs	r18, 0
    2978:	11 c0       	rjmp	.+34     	; 0x299c <ungetc+0x2a>
    297a:	26 fd       	sbrc	r18, 6
    297c:	0f c0       	rjmp	.+30     	; 0x299c <ungetc+0x2a>
    297e:	8f 3f       	cpi	r24, 0xFF	; 255
    2980:	98 07       	cpc	r25, r24
    2982:	71 f0       	breq	.+28     	; 0x29a0 <ungetc+0x2e>
    2984:	82 83       	std	Z+2, r24	; 0x02
    2986:	2f 7d       	andi	r18, 0xDF	; 223
    2988:	20 64       	ori	r18, 0x40	; 64
    298a:	23 83       	std	Z+3, r18	; 0x03
    298c:	26 81       	ldd	r18, Z+6	; 0x06
    298e:	37 81       	ldd	r19, Z+7	; 0x07
    2990:	21 50       	subi	r18, 0x01	; 1
    2992:	31 09       	sbc	r19, r1
    2994:	37 83       	std	Z+7, r19	; 0x07
    2996:	26 83       	std	Z+6, r18	; 0x06
    2998:	99 27       	eor	r25, r25
    299a:	08 95       	ret
    299c:	8f ef       	ldi	r24, 0xFF	; 255
    299e:	9f ef       	ldi	r25, 0xFF	; 255
    29a0:	08 95       	ret

000029a2 <__ultoa_invert>:
    29a2:	fa 01       	movw	r30, r20
    29a4:	aa 27       	eor	r26, r26
    29a6:	28 30       	cpi	r18, 0x08	; 8
    29a8:	51 f1       	breq	.+84     	; 0x29fe <__ultoa_invert+0x5c>
    29aa:	20 31       	cpi	r18, 0x10	; 16
    29ac:	81 f1       	breq	.+96     	; 0x2a0e <__ultoa_invert+0x6c>
    29ae:	e8 94       	clt
    29b0:	6f 93       	push	r22
    29b2:	6e 7f       	andi	r22, 0xFE	; 254
    29b4:	6e 5f       	subi	r22, 0xFE	; 254
    29b6:	7f 4f       	sbci	r23, 0xFF	; 255
    29b8:	8f 4f       	sbci	r24, 0xFF	; 255
    29ba:	9f 4f       	sbci	r25, 0xFF	; 255
    29bc:	af 4f       	sbci	r26, 0xFF	; 255
    29be:	b1 e0       	ldi	r27, 0x01	; 1
    29c0:	3e d0       	rcall	.+124    	; 0x2a3e <__ultoa_invert+0x9c>
    29c2:	b4 e0       	ldi	r27, 0x04	; 4
    29c4:	3c d0       	rcall	.+120    	; 0x2a3e <__ultoa_invert+0x9c>
    29c6:	67 0f       	add	r22, r23
    29c8:	78 1f       	adc	r23, r24
    29ca:	89 1f       	adc	r24, r25
    29cc:	9a 1f       	adc	r25, r26
    29ce:	a1 1d       	adc	r26, r1
    29d0:	68 0f       	add	r22, r24
    29d2:	79 1f       	adc	r23, r25
    29d4:	8a 1f       	adc	r24, r26
    29d6:	91 1d       	adc	r25, r1
    29d8:	a1 1d       	adc	r26, r1
    29da:	6a 0f       	add	r22, r26
    29dc:	71 1d       	adc	r23, r1
    29de:	81 1d       	adc	r24, r1
    29e0:	91 1d       	adc	r25, r1
    29e2:	a1 1d       	adc	r26, r1
    29e4:	20 d0       	rcall	.+64     	; 0x2a26 <__ultoa_invert+0x84>
    29e6:	09 f4       	brne	.+2      	; 0x29ea <__ultoa_invert+0x48>
    29e8:	68 94       	set
    29ea:	3f 91       	pop	r19
    29ec:	2a e0       	ldi	r18, 0x0A	; 10
    29ee:	26 9f       	mul	r18, r22
    29f0:	11 24       	eor	r1, r1
    29f2:	30 19       	sub	r19, r0
    29f4:	30 5d       	subi	r19, 0xD0	; 208
    29f6:	31 93       	st	Z+, r19
    29f8:	de f6       	brtc	.-74     	; 0x29b0 <__ultoa_invert+0xe>
    29fa:	cf 01       	movw	r24, r30
    29fc:	08 95       	ret
    29fe:	46 2f       	mov	r20, r22
    2a00:	47 70       	andi	r20, 0x07	; 7
    2a02:	40 5d       	subi	r20, 0xD0	; 208
    2a04:	41 93       	st	Z+, r20
    2a06:	b3 e0       	ldi	r27, 0x03	; 3
    2a08:	0f d0       	rcall	.+30     	; 0x2a28 <__ultoa_invert+0x86>
    2a0a:	c9 f7       	brne	.-14     	; 0x29fe <__ultoa_invert+0x5c>
    2a0c:	f6 cf       	rjmp	.-20     	; 0x29fa <__ultoa_invert+0x58>
    2a0e:	46 2f       	mov	r20, r22
    2a10:	4f 70       	andi	r20, 0x0F	; 15
    2a12:	40 5d       	subi	r20, 0xD0	; 208
    2a14:	4a 33       	cpi	r20, 0x3A	; 58
    2a16:	18 f0       	brcs	.+6      	; 0x2a1e <__ultoa_invert+0x7c>
    2a18:	49 5d       	subi	r20, 0xD9	; 217
    2a1a:	31 fd       	sbrc	r19, 1
    2a1c:	40 52       	subi	r20, 0x20	; 32
    2a1e:	41 93       	st	Z+, r20
    2a20:	02 d0       	rcall	.+4      	; 0x2a26 <__ultoa_invert+0x84>
    2a22:	a9 f7       	brne	.-22     	; 0x2a0e <__ultoa_invert+0x6c>
    2a24:	ea cf       	rjmp	.-44     	; 0x29fa <__ultoa_invert+0x58>
    2a26:	b4 e0       	ldi	r27, 0x04	; 4
    2a28:	a6 95       	lsr	r26
    2a2a:	97 95       	ror	r25
    2a2c:	87 95       	ror	r24
    2a2e:	77 95       	ror	r23
    2a30:	67 95       	ror	r22
    2a32:	ba 95       	dec	r27
    2a34:	c9 f7       	brne	.-14     	; 0x2a28 <__ultoa_invert+0x86>
    2a36:	00 97       	sbiw	r24, 0x00	; 0
    2a38:	61 05       	cpc	r22, r1
    2a3a:	71 05       	cpc	r23, r1
    2a3c:	08 95       	ret
    2a3e:	9b 01       	movw	r18, r22
    2a40:	ac 01       	movw	r20, r24
    2a42:	0a 2e       	mov	r0, r26
    2a44:	06 94       	lsr	r0
    2a46:	57 95       	ror	r21
    2a48:	47 95       	ror	r20
    2a4a:	37 95       	ror	r19
    2a4c:	27 95       	ror	r18
    2a4e:	ba 95       	dec	r27
    2a50:	c9 f7       	brne	.-14     	; 0x2a44 <__ultoa_invert+0xa2>
    2a52:	62 0f       	add	r22, r18
    2a54:	73 1f       	adc	r23, r19
    2a56:	84 1f       	adc	r24, r20
    2a58:	95 1f       	adc	r25, r21
    2a5a:	a0 1d       	adc	r26, r0
    2a5c:	08 95       	ret

00002a5e <__ctype_isfalse>:
    2a5e:	99 27       	eor	r25, r25
    2a60:	88 27       	eor	r24, r24

00002a62 <__ctype_istrue>:
    2a62:	08 95       	ret

00002a64 <_exit>:
    2a64:	f8 94       	cli

00002a66 <__stop_program>:
    2a66:	ff cf       	rjmp	.-2      	; 0x2a66 <__stop_program>
