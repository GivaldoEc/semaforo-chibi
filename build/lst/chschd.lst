   1               		.file	"chschd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.__sch_wakeup,"ax",@progbits
  12               	__sch_wakeup:
  13               	.LFB199:
  14               		.file 1 "../../os/rt/src/chschd.c"
   1:../../os/rt/src/chschd.c **** /*
   2:../../os/rt/src/chschd.c ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/src/chschd.c ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/src/chschd.c **** 
   5:../../os/rt/src/chschd.c ****     This file is part of ChibiOS.
   6:../../os/rt/src/chschd.c **** 
   7:../../os/rt/src/chschd.c ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/src/chschd.c ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/src/chschd.c ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/src/chschd.c **** 
  11:../../os/rt/src/chschd.c ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/src/chschd.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/src/chschd.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/src/chschd.c ****     GNU General Public License for more details.
  15:../../os/rt/src/chschd.c **** 
  16:../../os/rt/src/chschd.c ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/src/chschd.c ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/src/chschd.c **** */
  19:../../os/rt/src/chschd.c **** 
  20:../../os/rt/src/chschd.c **** /**
  21:../../os/rt/src/chschd.c ****  * @file    rt/src/chschd.c
  22:../../os/rt/src/chschd.c ****  * @brief   Scheduler code.
  23:../../os/rt/src/chschd.c ****  *
  24:../../os/rt/src/chschd.c ****  * @addtogroup scheduler
  25:../../os/rt/src/chschd.c ****  * @details This module provides the default portable scheduler code.
  26:../../os/rt/src/chschd.c ****  * @{
  27:../../os/rt/src/chschd.c ****  */
  28:../../os/rt/src/chschd.c **** 
  29:../../os/rt/src/chschd.c **** #include "ch.h"
  30:../../os/rt/src/chschd.c **** 
  31:../../os/rt/src/chschd.c **** /*===========================================================================*/
  32:../../os/rt/src/chschd.c **** /* Module local definitions.                                                 */
  33:../../os/rt/src/chschd.c **** /*===========================================================================*/
  34:../../os/rt/src/chschd.c **** 
  35:../../os/rt/src/chschd.c **** /*===========================================================================*/
  36:../../os/rt/src/chschd.c **** /* Module exported variables.                                                */
  37:../../os/rt/src/chschd.c **** /*===========================================================================*/
  38:../../os/rt/src/chschd.c **** 
  39:../../os/rt/src/chschd.c **** /*===========================================================================*/
  40:../../os/rt/src/chschd.c **** /* Module local types.                                                       */
  41:../../os/rt/src/chschd.c **** /*===========================================================================*/
  42:../../os/rt/src/chschd.c **** 
  43:../../os/rt/src/chschd.c **** /*===========================================================================*/
  44:../../os/rt/src/chschd.c **** /* Module local variables.                                                   */
  45:../../os/rt/src/chschd.c **** /*===========================================================================*/
  46:../../os/rt/src/chschd.c **** 
  47:../../os/rt/src/chschd.c **** /*===========================================================================*/
  48:../../os/rt/src/chschd.c **** /* Module local functions.                                                   */
  49:../../os/rt/src/chschd.c **** /*===========================================================================*/
  50:../../os/rt/src/chschd.c **** 
  51:../../os/rt/src/chschd.c **** /**
  52:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it behind its peers.
  53:../../os/rt/src/chschd.c ****  * @details The thread is positioned behind all threads with higher or equal
  54:../../os/rt/src/chschd.c ****  *          priority.
  55:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
  56:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
  57:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
  58:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
  59:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
  60:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
  61:../../os/rt/src/chschd.c ****  *
  62:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
  63:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
  64:../../os/rt/src/chschd.c ****  *
  65:../../os/rt/src/chschd.c ****  * @notapi
  66:../../os/rt/src/chschd.c ****  */
  67:../../os/rt/src/chschd.c **** static thread_t *__sch_ready_behind(thread_t *tp) {
  68:../../os/rt/src/chschd.c **** 
  69:../../os/rt/src/chschd.c ****   chDbgAssert((tp->state != CH_STATE_READY) &&
  70:../../os/rt/src/chschd.c ****               (tp->state != CH_STATE_FINAL),
  71:../../os/rt/src/chschd.c ****               "invalid state");
  72:../../os/rt/src/chschd.c **** 
  73:../../os/rt/src/chschd.c ****   /* Tracing the event.*/
  74:../../os/rt/src/chschd.c ****   __trace_ready(tp, tp->u.rdymsg);
  75:../../os/rt/src/chschd.c **** 
  76:../../os/rt/src/chschd.c ****   /* The thread is marked ready.*/
  77:../../os/rt/src/chschd.c ****   tp->state = CH_STATE_READY;
  78:../../os/rt/src/chschd.c **** 
  79:../../os/rt/src/chschd.c ****   /* Insertion in the priority queue.*/
  80:../../os/rt/src/chschd.c ****   return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
  81:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
  82:../../os/rt/src/chschd.c **** }
  83:../../os/rt/src/chschd.c **** 
  84:../../os/rt/src/chschd.c **** /**
  85:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it ahead its peers.
  86:../../os/rt/src/chschd.c ****  * @details The thread is positioned ahead all threads with higher or equal
  87:../../os/rt/src/chschd.c ****  *          priority.
  88:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
  89:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
  90:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
  91:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
  92:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
  93:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
  94:../../os/rt/src/chschd.c ****  *
  95:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
  96:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
  97:../../os/rt/src/chschd.c ****  *
  98:../../os/rt/src/chschd.c ****  * @notapi
  99:../../os/rt/src/chschd.c ****  */
 100:../../os/rt/src/chschd.c **** static thread_t *__sch_ready_ahead(thread_t *tp) {
 101:../../os/rt/src/chschd.c **** 
 102:../../os/rt/src/chschd.c ****   chDbgAssert((tp->state != CH_STATE_READY) &&
 103:../../os/rt/src/chschd.c ****               (tp->state != CH_STATE_FINAL),
 104:../../os/rt/src/chschd.c ****               "invalid state");
 105:../../os/rt/src/chschd.c **** 
 106:../../os/rt/src/chschd.c ****   /* Tracing the event.*/
 107:../../os/rt/src/chschd.c ****   __trace_ready(tp, tp->u.rdymsg);
 108:../../os/rt/src/chschd.c **** 
 109:../../os/rt/src/chschd.c ****   /* The thread is marked ready.*/
 110:../../os/rt/src/chschd.c ****   tp->state = CH_STATE_READY;
 111:../../os/rt/src/chschd.c **** 
 112:../../os/rt/src/chschd.c ****   /* Insertion in the priority queue.*/
 113:../../os/rt/src/chschd.c ****   return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 114:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 115:../../os/rt/src/chschd.c **** }
 116:../../os/rt/src/chschd.c **** 
 117:../../os/rt/src/chschd.c **** /**
 118:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 119:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list behind all
 120:../../os/rt/src/chschd.c ****  *          threads having the same priority. The thread regains its time
 121:../../os/rt/src/chschd.c ****  *          quantum.
 122:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 123:../../os/rt/src/chschd.c ****  *          itself.
 124:../../os/rt/src/chschd.c ****  *
 125:../../os/rt/src/chschd.c ****  * @notapi
 126:../../os/rt/src/chschd.c ****  */
 127:../../os/rt/src/chschd.c **** static void __sch_reschedule_behind(void) {
 128:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 129:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 130:../../os/rt/src/chschd.c ****   thread_t *ntp;
 131:../../os/rt/src/chschd.c **** 
 132:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 133:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 134:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 135:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 136:../../os/rt/src/chschd.c **** 
 137:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 138:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 139:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 140:../../os/rt/src/chschd.c ****   }
 141:../../os/rt/src/chschd.c **** 
 142:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 143:../../os/rt/src/chschd.c ****   /* It went behind peers so it gets a new time quantum.*/
 144:../../os/rt/src/chschd.c ****   otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 145:../../os/rt/src/chschd.c **** #endif
 146:../../os/rt/src/chschd.c **** 
 147:../../os/rt/src/chschd.c ****   /* Placing in ready list behind peers.*/
 148:../../os/rt/src/chschd.c ****   otp = __sch_ready_behind(otp);
 149:../../os/rt/src/chschd.c **** 
 150:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 151:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 152:../../os/rt/src/chschd.c **** }
 153:../../os/rt/src/chschd.c **** 
 154:../../os/rt/src/chschd.c **** /**
 155:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 156:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list ahead of all
 157:../../os/rt/src/chschd.c ****  *          threads having the same priority.
 158:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 159:../../os/rt/src/chschd.c ****  *          itself.
 160:../../os/rt/src/chschd.c ****  *
 161:../../os/rt/src/chschd.c ****  * @notapi
 162:../../os/rt/src/chschd.c ****  */
 163:../../os/rt/src/chschd.c **** static void __sch_reschedule_ahead(void) {
 164:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 165:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 166:../../os/rt/src/chschd.c ****   thread_t *ntp;
 167:../../os/rt/src/chschd.c **** 
 168:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 169:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 170:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 171:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 172:../../os/rt/src/chschd.c **** 
 173:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 174:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 175:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 176:../../os/rt/src/chschd.c ****   }
 177:../../os/rt/src/chschd.c **** 
 178:../../os/rt/src/chschd.c ****   /* Placing in ready list ahead of peers.*/
 179:../../os/rt/src/chschd.c ****   otp = __sch_ready_ahead(otp);
 180:../../os/rt/src/chschd.c **** 
 181:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 182:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 183:../../os/rt/src/chschd.c **** }
 184:../../os/rt/src/chschd.c **** 
 185:../../os/rt/src/chschd.c **** /*
 186:../../os/rt/src/chschd.c ****  * Timeout wakeup callback.
 187:../../os/rt/src/chschd.c ****  */
 188:../../os/rt/src/chschd.c **** static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
  15               		.loc 1 188 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  30 0004 DB01      		movw r26,r22
  31               	.LVL1:
 189:../../os/rt/src/chschd.c ****   thread_t *tp = threadref(p);
 190:../../os/rt/src/chschd.c **** 
 191:../../os/rt/src/chschd.c ****   (void)vtp;
 192:../../os/rt/src/chschd.c **** 
 193:../../os/rt/src/chschd.c ****   chSysLockFromISR();
 194:../../os/rt/src/chschd.c ****   switch (tp->state) {
  32               		.loc 1 194 0
  33 0006 1F96      		adiw r26,15
  34 0008 8C91      		ld r24,X
  35 000a 1F97      		sbiw r26,15
  36               	.LVL2:
  37 000c 8430      		cpi r24,lo8(4)
  38 000e 01F0      		breq .L3
  39 0010 00F4      		brsh .L4
  40 0012 8823      		tst r24
  41 0014 01F0      		breq .L1
  42 0016 8330      		cpi r24,lo8(3)
  43 0018 01F4      		brne .L2
 195:../../os/rt/src/chschd.c ****   case CH_STATE_READY:
 196:../../os/rt/src/chschd.c ****     /* Handling the special case where the thread has been made ready by
 197:../../os/rt/src/chschd.c ****        another thread with higher priority.*/
 198:../../os/rt/src/chschd.c ****     chSysUnlockFromISR();
 199:../../os/rt/src/chschd.c ****     return;
 200:../../os/rt/src/chschd.c ****   case CH_STATE_SUSPENDED:
 201:../../os/rt/src/chschd.c ****     *tp->u.wttrp = NULL;
  44               		.loc 1 201 0
  45 001a 5296      		adiw r26,18
  46 001c ED91      		ld r30,X+
  47 001e FC91      		ld r31,X
  48 0020 5397      		sbiw r26,18+1
  49 0022 1182      		std Z+1,__zero_reg__
  50 0024 1082      		st Z,__zero_reg__
  51               	.L2:
 202:../../os/rt/src/chschd.c ****     break;
 203:../../os/rt/src/chschd.c **** #if CH_CFG_USE_SEMAPHORES == TRUE
 204:../../os/rt/src/chschd.c ****   case CH_STATE_WTSEM:
 205:../../os/rt/src/chschd.c ****     chSemFastSignalI(tp->u.wtsemp);
 206:../../os/rt/src/chschd.c **** #endif
 207:../../os/rt/src/chschd.c ****     /* Falls through.*/
 208:../../os/rt/src/chschd.c ****   case CH_STATE_QUEUED:
 209:../../os/rt/src/chschd.c ****     /* Falls through.*/
 210:../../os/rt/src/chschd.c **** #if CH_CFG_USE_MESSAGES == TRUE
 211:../../os/rt/src/chschd.c ****   case CH_STATE_SNDMSGQ:
 212:../../os/rt/src/chschd.c ****     /* Falls through.*/
 213:../../os/rt/src/chschd.c **** #endif
 214:../../os/rt/src/chschd.c **** #if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
 215:../../os/rt/src/chschd.c ****   case CH_STATE_WTCOND:
 216:../../os/rt/src/chschd.c **** #endif
 217:../../os/rt/src/chschd.c ****     /* States requiring dequeuing.*/
 218:../../os/rt/src/chschd.c ****     (void) ch_queue_dequeue(&tp->hdr.queue);
 219:../../os/rt/src/chschd.c ****     break;
 220:../../os/rt/src/chschd.c ****   default:
 221:../../os/rt/src/chschd.c ****     /* Any other state, nothing to do.*/
 222:../../os/rt/src/chschd.c ****     break;
 223:../../os/rt/src/chschd.c ****   }
 224:../../os/rt/src/chschd.c **** 
 225:../../os/rt/src/chschd.c ****   /* Standard message for timeout conditions.*/
 226:../../os/rt/src/chschd.c ****   tp->u.rdymsg = MSG_TIMEOUT;
  52               		.loc 1 226 0
  53 0026 8FEF      		ldi r24,lo8(-1)
  54 0028 9FEF      		ldi r25,lo8(-1)
  55 002a 5396      		adiw r26,18+1
  56 002c 9C93      		st X,r25
  57 002e 8E93      		st -X,r24
  58 0030 5297      		sbiw r26,18
  59               	.LVL3:
  60               	.LBB65:
  61               	.LBB66:
  77:../../os/rt/src/chschd.c **** 
  62               		.loc 1 77 0
  63 0032 1F96      		adiw r26,15
  64 0034 1C92      		st X,__zero_reg__
  65 0036 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
  66               		.loc 1 80 0
  67 0038 1B96      		adiw r26,11
  68 003a ED91      		ld r30,X+
  69 003c FC91      		ld r31,X
  70 003e 1C97      		sbiw r26,11+1
  71               	.LVL4:
  72               	.LBB67:
  73               	.LBB68:
  74               		.file 2 "../../os/rt/include/chlists.h"
   1:../../os/rt/include/chlists.h **** /*
   2:../../os/rt/include/chlists.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chlists.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chlists.h **** 
   5:../../os/rt/include/chlists.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chlists.h **** 
   7:../../os/rt/include/chlists.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chlists.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chlists.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chlists.h **** 
  11:../../os/rt/include/chlists.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chlists.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chlists.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chlists.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chlists.h **** 
  16:../../os/rt/include/chlists.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chlists.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chlists.h **** */
  19:../../os/rt/include/chlists.h **** 
  20:../../os/rt/include/chlists.h **** /**
  21:../../os/rt/include/chlists.h ****  * @file    chlists.h
  22:../../os/rt/include/chlists.h ****  * @brief   Lists and Queues header.
  23:../../os/rt/include/chlists.h ****  *
  24:../../os/rt/include/chlists.h ****  * @addtogroup os_lists
  25:../../os/rt/include/chlists.h ****  * @{
  26:../../os/rt/include/chlists.h ****  */
  27:../../os/rt/include/chlists.h **** 
  28:../../os/rt/include/chlists.h **** #ifndef CHLISTS_H
  29:../../os/rt/include/chlists.h **** #define CHLISTS_H
  30:../../os/rt/include/chlists.h **** 
  31:../../os/rt/include/chlists.h **** /*===========================================================================*/
  32:../../os/rt/include/chlists.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chlists.h **** /*===========================================================================*/
  34:../../os/rt/include/chlists.h **** 
  35:../../os/rt/include/chlists.h **** /*===========================================================================*/
  36:../../os/rt/include/chlists.h **** /* Module pre-compile time settings.                                         */
  37:../../os/rt/include/chlists.h **** /*===========================================================================*/
  38:../../os/rt/include/chlists.h **** 
  39:../../os/rt/include/chlists.h **** /*===========================================================================*/
  40:../../os/rt/include/chlists.h **** /* Derived constants and error checks.                                       */
  41:../../os/rt/include/chlists.h **** /*===========================================================================*/
  42:../../os/rt/include/chlists.h **** 
  43:../../os/rt/include/chlists.h **** /*===========================================================================*/
  44:../../os/rt/include/chlists.h **** /* Module data structures and types.                                         */
  45:../../os/rt/include/chlists.h **** /*===========================================================================*/
  46:../../os/rt/include/chlists.h **** 
  47:../../os/rt/include/chlists.h **** /**
  48:../../os/rt/include/chlists.h ****  * @brief   Type of a generic single link list header and element.
  49:../../os/rt/include/chlists.h ****  */
  50:../../os/rt/include/chlists.h **** typedef struct ch_list ch_list_t;
  51:../../os/rt/include/chlists.h **** 
  52:../../os/rt/include/chlists.h **** /**
  53:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic single link list header
  54:../../os/rt/include/chlists.h ****  *          and element.
  55:../../os/rt/include/chlists.h ****  */
  56:../../os/rt/include/chlists.h **** struct ch_list {
  57:../../os/rt/include/chlists.h ****   ch_list_t             *next;      /**< @brief Next in the list/queue.     */
  58:../../os/rt/include/chlists.h **** };
  59:../../os/rt/include/chlists.h **** 
  60:../../os/rt/include/chlists.h **** /**
  61:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked list header and element.
  62:../../os/rt/include/chlists.h ****  */
  63:../../os/rt/include/chlists.h **** typedef struct ch_queue ch_queue_t;
  64:../../os/rt/include/chlists.h **** 
  65:../../os/rt/include/chlists.h **** /**
  66:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic bidirectional linked list header
  67:../../os/rt/include/chlists.h ****  *          and element.
  68:../../os/rt/include/chlists.h ****  */
  69:../../os/rt/include/chlists.h **** struct ch_queue {
  70:../../os/rt/include/chlists.h ****   ch_queue_t            *next;      /**< @brief Next in the list/queue.     */
  71:../../os/rt/include/chlists.h ****   ch_queue_t            *prev;      /**< @brief Previous in the queue.      */
  72:../../os/rt/include/chlists.h **** };
  73:../../os/rt/include/chlists.h **** 
  74:../../os/rt/include/chlists.h **** /**
  75:../../os/rt/include/chlists.h ****  * @brief   Type of a generic priority-ordered bidirectional linked list
  76:../../os/rt/include/chlists.h ****  *          header and element.
  77:../../os/rt/include/chlists.h ****  */
  78:../../os/rt/include/chlists.h **** typedef struct ch_priority_queue ch_priority_queue_t;
  79:../../os/rt/include/chlists.h **** 
  80:../../os/rt/include/chlists.h **** /**
  81:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic priority-ordered bidirectional
  82:../../os/rt/include/chlists.h ****  *          linked list header and element.
  83:../../os/rt/include/chlists.h ****  * @note    Link fields are void pointers in order to avoid aliasing issues.
  84:../../os/rt/include/chlists.h ****  */
  85:../../os/rt/include/chlists.h **** struct ch_priority_queue {
  86:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *next;      /**< @brief Next in the queue.          */
  87:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *prev;      /**< @brief Previous in the queue.      */
  88:../../os/rt/include/chlists.h ****   tprio_t               prio;       /**< @brief Priority of this element.   */
  89:../../os/rt/include/chlists.h **** };
  90:../../os/rt/include/chlists.h **** 
  91:../../os/rt/include/chlists.h **** /**
  92:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked delta list
  93:../../os/rt/include/chlists.h ****  *          header and element.
  94:../../os/rt/include/chlists.h ****  */
  95:../../os/rt/include/chlists.h **** typedef struct ch_delta_list ch_delta_list_t;
  96:../../os/rt/include/chlists.h **** 
  97:../../os/rt/include/chlists.h **** /**
  98:../../os/rt/include/chlists.h ****  * @brief   Delta list element and header structure.
  99:../../os/rt/include/chlists.h ****  */
 100:../../os/rt/include/chlists.h **** struct ch_delta_list {
 101:../../os/rt/include/chlists.h ****   ch_delta_list_t       *next;      /**< @brief Next in the delta list.     */
 102:../../os/rt/include/chlists.h ****   ch_delta_list_t       *prev;      /**< @brief Previous in the delta list. */
 103:../../os/rt/include/chlists.h ****   sysinterval_t         delta;      /**< @brief Time interval from previous.*/
 104:../../os/rt/include/chlists.h **** };
 105:../../os/rt/include/chlists.h **** 
 106:../../os/rt/include/chlists.h **** /*===========================================================================*/
 107:../../os/rt/include/chlists.h **** /* Module macros.                                                            */
 108:../../os/rt/include/chlists.h **** /*===========================================================================*/
 109:../../os/rt/include/chlists.h **** 
 110:../../os/rt/include/chlists.h **** /**
 111:../../os/rt/include/chlists.h ****  * @brief   Data part of a static queue object initializer.
 112:../../os/rt/include/chlists.h ****  * @details This macro should be used when statically initializing a
 113:../../os/rt/include/chlists.h ****  *          queue that is part of a bigger structure.
 114:../../os/rt/include/chlists.h ****  *
 115:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 116:../../os/rt/include/chlists.h ****  */
 117:../../os/rt/include/chlists.h **** #define __CH_QUEUE_DATA(name) {(ch_queue_t *)&name, (ch_queue_t *)&name}
 118:../../os/rt/include/chlists.h **** 
 119:../../os/rt/include/chlists.h **** /**
 120:../../os/rt/include/chlists.h ****  * @brief   Static queue object initializer.
 121:../../os/rt/include/chlists.h ****  * @details Statically initialized queues require no explicit
 122:../../os/rt/include/chlists.h ****  *          initialization using @p queue_init().
 123:../../os/rt/include/chlists.h ****  *
 124:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 125:../../os/rt/include/chlists.h ****  */
 126:../../os/rt/include/chlists.h **** #define CH_QUEUE_DECL(name)                                                 \
 127:../../os/rt/include/chlists.h ****     ch_queue_t name = __CH_QUEUE_DATA(name)
 128:../../os/rt/include/chlists.h **** 
 129:../../os/rt/include/chlists.h **** /*===========================================================================*/
 130:../../os/rt/include/chlists.h **** /* External declarations.                                                    */
 131:../../os/rt/include/chlists.h **** /*===========================================================================*/
 132:../../os/rt/include/chlists.h **** 
 133:../../os/rt/include/chlists.h **** /* Early function prototypes required by the following headers.*/
 134:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 135:../../os/rt/include/chlists.h **** extern "C" {
 136:../../os/rt/include/chlists.h **** #endif
 137:../../os/rt/include/chlists.h **** 
 138:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 139:../../os/rt/include/chlists.h **** }
 140:../../os/rt/include/chlists.h **** #endif
 141:../../os/rt/include/chlists.h **** 
 142:../../os/rt/include/chlists.h **** /*===========================================================================*/
 143:../../os/rt/include/chlists.h **** /* Module inline functions.                                                  */
 144:../../os/rt/include/chlists.h **** /*===========================================================================*/
 145:../../os/rt/include/chlists.h **** 
 146:../../os/rt/include/chlists.h **** /**
 147:../../os/rt/include/chlists.h ****  * @brief   List initialization.
 148:../../os/rt/include/chlists.h ****  *
 149:../../os/rt/include/chlists.h ****  * @param[out] lp       pointer to the list header
 150:../../os/rt/include/chlists.h ****  *
 151:../../os/rt/include/chlists.h ****  * @notapi
 152:../../os/rt/include/chlists.h ****  */
 153:../../os/rt/include/chlists.h **** static inline void ch_list_init(ch_list_t *lp) {
 154:../../os/rt/include/chlists.h **** 
 155:../../os/rt/include/chlists.h ****   lp->next = lp;
 156:../../os/rt/include/chlists.h **** }
 157:../../os/rt/include/chlists.h **** 
 158:../../os/rt/include/chlists.h **** /**
 159:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is empty.
 160:../../os/rt/include/chlists.h ****  *
 161:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 162:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 163:../../os/rt/include/chlists.h ****  *
 164:../../os/rt/include/chlists.h ****  * @notapi
 165:../../os/rt/include/chlists.h ****  */
 166:../../os/rt/include/chlists.h **** static inline bool ch_list_isempty(ch_list_t *lp) {
 167:../../os/rt/include/chlists.h **** 
 168:../../os/rt/include/chlists.h ****   return (bool)(lp->next == lp);
 169:../../os/rt/include/chlists.h **** }
 170:../../os/rt/include/chlists.h **** 
 171:../../os/rt/include/chlists.h **** /**
 172:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is not empty.
 173:../../os/rt/include/chlists.h ****  *
 174:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 175:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 176:../../os/rt/include/chlists.h ****  *
 177:../../os/rt/include/chlists.h ****  * @notapi
 178:../../os/rt/include/chlists.h ****  */
 179:../../os/rt/include/chlists.h **** static inline bool ch_list_notempty(ch_list_t *lp) {
 180:../../os/rt/include/chlists.h **** 
 181:../../os/rt/include/chlists.h ****   return (bool)(lp->next != lp);
 182:../../os/rt/include/chlists.h **** }
 183:../../os/rt/include/chlists.h **** 
 184:../../os/rt/include/chlists.h **** /**
 185:../../os/rt/include/chlists.h ****  * @brief   Pushes an element on top of a stack list.
 186:../../os/rt/include/chlists.h ****  *
 187:../../os/rt/include/chlists.h ****  * @param[in] lp    the pointer to the list header
 188:../../os/rt/include/chlists.h ****  * @param[in] p     the pointer to the element to be inserted in the list
 189:../../os/rt/include/chlists.h ****  *
 190:../../os/rt/include/chlists.h ****  * @notapi
 191:../../os/rt/include/chlists.h ****  */
 192:../../os/rt/include/chlists.h **** static inline void ch_list_link(ch_list_t *lp, ch_list_t *p) {
 193:../../os/rt/include/chlists.h **** 
 194:../../os/rt/include/chlists.h ****   p->next = lp->next;
 195:../../os/rt/include/chlists.h ****   lp->next = p;
 196:../../os/rt/include/chlists.h **** }
 197:../../os/rt/include/chlists.h **** 
 198:../../os/rt/include/chlists.h **** /**
 199:../../os/rt/include/chlists.h ****  * @brief   Pops an element from the top of a stack list and returns it.
 200:../../os/rt/include/chlists.h ****  * @pre     The list must be non-empty before calling this function.
 201:../../os/rt/include/chlists.h ****  *
 202:../../os/rt/include/chlists.h ****  * @param[in] lp        the pointer to the list header
 203:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 204:../../os/rt/include/chlists.h ****  *
 205:../../os/rt/include/chlists.h ****  * @notapi
 206:../../os/rt/include/chlists.h ****  */
 207:../../os/rt/include/chlists.h **** static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 208:../../os/rt/include/chlists.h **** 
 209:../../os/rt/include/chlists.h ****   ch_list_t *p = lp->next;
 210:../../os/rt/include/chlists.h ****   lp->next = p->next;
 211:../../os/rt/include/chlists.h **** 
 212:../../os/rt/include/chlists.h ****   return p;
 213:../../os/rt/include/chlists.h **** }
 214:../../os/rt/include/chlists.h **** 
 215:../../os/rt/include/chlists.h **** /**
 216:../../os/rt/include/chlists.h ****  * @brief   Queue initialization.
 217:../../os/rt/include/chlists.h ****  *
 218:../../os/rt/include/chlists.h ****  * @param[out] qp       pointer to the queue header
 219:../../os/rt/include/chlists.h ****  *
 220:../../os/rt/include/chlists.h ****  * @notapi
 221:../../os/rt/include/chlists.h ****  */
 222:../../os/rt/include/chlists.h **** static inline void ch_queue_init(ch_queue_t *qp) {
 223:../../os/rt/include/chlists.h **** 
 224:../../os/rt/include/chlists.h ****   qp->next = qp;
 225:../../os/rt/include/chlists.h ****   qp->prev = qp;
 226:../../os/rt/include/chlists.h **** }
 227:../../os/rt/include/chlists.h **** 
 228:../../os/rt/include/chlists.h **** /**
 229:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is empty.
 230:../../os/rt/include/chlists.h ****  *
 231:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 232:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 233:../../os/rt/include/chlists.h ****  *
 234:../../os/rt/include/chlists.h ****  * @notapi
 235:../../os/rt/include/chlists.h ****  */
 236:../../os/rt/include/chlists.h **** static inline bool ch_queue_isempty(const ch_queue_t *qp) {
 237:../../os/rt/include/chlists.h **** 
 238:../../os/rt/include/chlists.h ****   return (bool)(qp->next == qp);
 239:../../os/rt/include/chlists.h **** }
 240:../../os/rt/include/chlists.h **** 
 241:../../os/rt/include/chlists.h **** /**
 242:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is not empty.
 243:../../os/rt/include/chlists.h ****  *
 244:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 245:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 246:../../os/rt/include/chlists.h ****  *
 247:../../os/rt/include/chlists.h ****  * @notapi
 248:../../os/rt/include/chlists.h ****  */
 249:../../os/rt/include/chlists.h **** static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 250:../../os/rt/include/chlists.h **** 
 251:../../os/rt/include/chlists.h ****   return (bool)(qp->next != qp);
 252:../../os/rt/include/chlists.h **** }
 253:../../os/rt/include/chlists.h **** 
 254:../../os/rt/include/chlists.h **** /**
 255:../../os/rt/include/chlists.h ****  * @brief   Inserts an element into a queue.
 256:../../os/rt/include/chlists.h ****  *
 257:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue header
 258:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 259:../../os/rt/include/chlists.h ****  *
 260:../../os/rt/include/chlists.h ****  * @notapi
 261:../../os/rt/include/chlists.h ****  */
 262:../../os/rt/include/chlists.h **** static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 263:../../os/rt/include/chlists.h **** 
 264:../../os/rt/include/chlists.h ****   p->next       = qp;
 265:../../os/rt/include/chlists.h ****   p->prev       = qp->prev;
 266:../../os/rt/include/chlists.h ****   p->prev->next = p;
 267:../../os/rt/include/chlists.h ****   qp->prev      = p;
 268:../../os/rt/include/chlists.h **** }
 269:../../os/rt/include/chlists.h **** 
 270:../../os/rt/include/chlists.h **** /**
 271:../../os/rt/include/chlists.h ****  * @brief   Removes the first-out element from a queue and returns it.
 272:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 273:../../os/rt/include/chlists.h ****  *          element with the highest priority.
 274:../../os/rt/include/chlists.h ****  *
 275:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue list header
 276:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 277:../../os/rt/include/chlists.h ****  *
 278:../../os/rt/include/chlists.h ****  * @notapi
 279:../../os/rt/include/chlists.h ****  */
 280:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 281:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->next;
 282:../../os/rt/include/chlists.h **** 
 283:../../os/rt/include/chlists.h ****   qp->next       = p->next;
 284:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 285:../../os/rt/include/chlists.h **** 
 286:../../os/rt/include/chlists.h ****   return p;
 287:../../os/rt/include/chlists.h **** }
 288:../../os/rt/include/chlists.h **** 
 289:../../os/rt/include/chlists.h **** /**
 290:../../os/rt/include/chlists.h ****  * @brief   Removes the last-out element from a queue and returns it.
 291:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 292:../../os/rt/include/chlists.h ****  *          element with the lowest priority.
 293:../../os/rt/include/chlists.h ****  *
 294:../../os/rt/include/chlists.h ****  * @param[in] qp    the pointer to the queue list header
 295:../../os/rt/include/chlists.h ****  * @return          The removed element pointer.
 296:../../os/rt/include/chlists.h ****  *
 297:../../os/rt/include/chlists.h ****  * @notapi
 298:../../os/rt/include/chlists.h ****  */
 299:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_lifo_remove(ch_queue_t *qp) {
 300:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->prev;
 301:../../os/rt/include/chlists.h **** 
 302:../../os/rt/include/chlists.h ****   qp->prev       = p->prev;
 303:../../os/rt/include/chlists.h ****   qp->prev->next = qp;
 304:../../os/rt/include/chlists.h **** 
 305:../../os/rt/include/chlists.h ****   return p;
 306:../../os/rt/include/chlists.h **** }
 307:../../os/rt/include/chlists.h **** 
 308:../../os/rt/include/chlists.h **** /**
 309:../../os/rt/include/chlists.h ****  * @brief   Removes an element from a queue and returns it.
 310:../../os/rt/include/chlists.h ****  * @details The element is removed from the queue regardless of its relative
 311:../../os/rt/include/chlists.h ****  *          position and regardless the used insertion method.
 312:../../os/rt/include/chlists.h ****  *
 313:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be removed from the queue
 314:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 315:../../os/rt/include/chlists.h ****  *
 316:../../os/rt/include/chlists.h ****  * @notapi
 317:../../os/rt/include/chlists.h ****  */
 318:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 319:../../os/rt/include/chlists.h **** 
 320:../../os/rt/include/chlists.h ****   p->prev->next = p->next;
 321:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 322:../../os/rt/include/chlists.h **** 
 323:../../os/rt/include/chlists.h ****   return p;
 324:../../os/rt/include/chlists.h **** }
 325:../../os/rt/include/chlists.h **** 
 326:../../os/rt/include/chlists.h **** /**
 327:../../os/rt/include/chlists.h ****  * @brief   Priority queue initialization.
 328:../../os/rt/include/chlists.h ****  * @note    The queue header priority is initialized to zero, all other
 329:../../os/rt/include/chlists.h ****  *          elements in the queue are assumed to have priority greater
 330:../../os/rt/include/chlists.h ****  *          than zero.
 331:../../os/rt/include/chlists.h ****  *
 332:../../os/rt/include/chlists.h ****  * @param[out] pqp      pointer to the priority queue header
 333:../../os/rt/include/chlists.h ****  *
 334:../../os/rt/include/chlists.h ****  * @notapi
 335:../../os/rt/include/chlists.h ****  */
 336:../../os/rt/include/chlists.h **** static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 337:../../os/rt/include/chlists.h **** 
 338:../../os/rt/include/chlists.h ****   pqp->next = pqp;
 339:../../os/rt/include/chlists.h ****   pqp->prev = pqp;
 340:../../os/rt/include/chlists.h ****   pqp->prio = (tprio_t)0;
 341:../../os/rt/include/chlists.h **** }
 342:../../os/rt/include/chlists.h **** 
 343:../../os/rt/include/chlists.h **** /**
 344:../../os/rt/include/chlists.h ****  * @brief   Removes the highest priority element from a priority queue and
 345:../../os/rt/include/chlists.h ****  *          returns it.
 346:../../os/rt/include/chlists.h ****  *
 347:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 348:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 349:../../os/rt/include/chlists.h ****  *
 350:../../os/rt/include/chlists.h ****  * @notapi
 351:../../os/rt/include/chlists.h ****  */
 352:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 353:../../os/rt/include/chlists.h ****   ch_priority_queue_t *p = pqp->next;
 354:../../os/rt/include/chlists.h **** 
 355:../../os/rt/include/chlists.h ****   pqp->next       = p->next;
 356:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 357:../../os/rt/include/chlists.h **** 
 358:../../os/rt/include/chlists.h ****   return p;
 359:../../os/rt/include/chlists.h **** }
 360:../../os/rt/include/chlists.h **** 
 361:../../os/rt/include/chlists.h **** /**
 362:../../os/rt/include/chlists.h ****  * @brief   Inserts an element in the priority queue placing it behind
 363:../../os/rt/include/chlists.h ****  *          its peers.
 364:../../os/rt/include/chlists.h ****  * @details The element is positioned behind all elements with higher or
 365:../../os/rt/include/chlists.h ****  *          equal priority.
 366:../../os/rt/include/chlists.h ****  *
 367:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 368:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 369:../../os/rt/include/chlists.h ****  * @return              The inserted element pointer.
 370:../../os/rt/include/chlists.h ****  *
 371:../../os/rt/include/chlists.h ****  * @notapi
 372:../../os/rt/include/chlists.h ****  */
 373:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
 374:../../os/rt/include/chlists.h ****                                                            ch_priority_queue_t *p) {
 375:../../os/rt/include/chlists.h **** 
 376:../../os/rt/include/chlists.h ****   /* Scanning priority queue, the list is assumed to be mostly empty.*/
 377:../../os/rt/include/chlists.h ****   do {
 378:../../os/rt/include/chlists.h ****     pqp = pqp->next;
 379:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
  75               		.loc 2 379 0
  76 0040 1496      		adiw r26,4
  77 0042 9C91      		ld r25,X
  78 0044 1497      		sbiw r26,4
  79               	.L8:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
  80               		.loc 2 378 0
  81 0046 0190      		ld __tmp_reg__,Z+
  82 0048 F081      		ld r31,Z
  83 004a E02D      		mov r30,__tmp_reg__
  84               	.LVL5:
  85               		.loc 2 379 0
  86 004c 8481      		ldd r24,Z+4
  87 004e 8917      		cp r24,r25
  88 0050 00F4      		brsh .L8
 380:../../os/rt/include/chlists.h **** 
 381:../../os/rt/include/chlists.h ****   /* Insertion on prev.*/
 382:../../os/rt/include/chlists.h ****   p->next       = pqp;
  89               		.loc 2 382 0
  90 0052 1196      		adiw r26,1
  91 0054 FC93      		st X,r31
  92 0056 EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
  93               		.loc 2 383 0
  94 0058 C281      		ldd r28,Z+2
  95 005a D381      		ldd r29,Z+3
  96 005c 1396      		adiw r26,2+1
  97 005e DC93      		st X,r29
  98 0060 CE93      		st -X,r28
  99 0062 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   p->prev->next = p;
 100               		.loc 2 384 0
 101 0064 B983      		std Y+1,r27
 102 0066 A883      		st Y,r26
 385:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 103               		.loc 2 385 0
 104 0068 B383      		std Z+3,r27
 105 006a A283      		std Z+2,r26
 106               	.LVL6:
 107               	.L1:
 108               	/* epilogue start */
 109               	.LBE68:
 110               	.LBE67:
 111               	.LBE66:
 112               	.LBE65:
 227:../../os/rt/src/chschd.c **** 
 228:../../os/rt/src/chschd.c ****   /* Goes behind peers because it went to sleep voluntarily.*/
 229:../../os/rt/src/chschd.c ****   (void) __sch_ready_behind(tp);
 230:../../os/rt/src/chschd.c ****   chSysUnlockFromISR();
 231:../../os/rt/src/chschd.c **** 
 232:../../os/rt/src/chschd.c ****   return;
 233:../../os/rt/src/chschd.c **** }
 113               		.loc 1 233 0
 114 006c DF91      		pop r29
 115 006e CF91      		pop r28
 116 0070 0895      		ret
 117               	.L4:
 194:../../os/rt/src/chschd.c ****   case CH_STATE_READY:
 118               		.loc 1 194 0
 119 0072 8730      		cpi r24,lo8(7)
 120 0074 01F0      		breq .L3
 121 0076 8C30      		cpi r24,lo8(12)
 122 0078 01F0      		breq .L3
 123 007a 8530      		cpi r24,lo8(5)
 124 007c 01F4      		brne .L2
 205:../../os/rt/src/chschd.c **** #endif
 125               		.loc 1 205 0
 126 007e 5296      		adiw r26,18
 127 0080 ED91      		ld r30,X+
 128 0082 FC91      		ld r31,X
 129 0084 5397      		sbiw r26,18+1
 130               	.LVL7:
 131               	.LBB69:
 132               	.LBB70:
 133               		.file 3 "../../os/rt/include/chsem.h"
   1:../../os/rt/include/chsem.h **** /*
   2:../../os/rt/include/chsem.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chsem.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chsem.h **** 
   5:../../os/rt/include/chsem.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chsem.h **** 
   7:../../os/rt/include/chsem.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chsem.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chsem.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chsem.h **** 
  11:../../os/rt/include/chsem.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chsem.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chsem.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chsem.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chsem.h **** 
  16:../../os/rt/include/chsem.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chsem.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chsem.h **** */
  19:../../os/rt/include/chsem.h **** 
  20:../../os/rt/include/chsem.h **** /**
  21:../../os/rt/include/chsem.h ****  * @file    rt/include/chsem.h
  22:../../os/rt/include/chsem.h ****  * @brief   Semaphores macros and structures.
  23:../../os/rt/include/chsem.h ****  *
  24:../../os/rt/include/chsem.h ****  * @addtogroup semaphores
  25:../../os/rt/include/chsem.h ****  * @{
  26:../../os/rt/include/chsem.h ****  */
  27:../../os/rt/include/chsem.h **** 
  28:../../os/rt/include/chsem.h **** #ifndef CHSEM_H
  29:../../os/rt/include/chsem.h **** #define CHSEM_H
  30:../../os/rt/include/chsem.h **** 
  31:../../os/rt/include/chsem.h **** #if (CH_CFG_USE_SEMAPHORES == TRUE) || defined(__DOXYGEN__)
  32:../../os/rt/include/chsem.h **** 
  33:../../os/rt/include/chsem.h **** /*===========================================================================*/
  34:../../os/rt/include/chsem.h **** /* Module constants.                                                         */
  35:../../os/rt/include/chsem.h **** /*===========================================================================*/
  36:../../os/rt/include/chsem.h **** 
  37:../../os/rt/include/chsem.h **** /*===========================================================================*/
  38:../../os/rt/include/chsem.h **** /* Module pre-compile time settings.                                         */
  39:../../os/rt/include/chsem.h **** /*===========================================================================*/
  40:../../os/rt/include/chsem.h **** 
  41:../../os/rt/include/chsem.h **** /*===========================================================================*/
  42:../../os/rt/include/chsem.h **** /* Derived constants and error checks.                                       */
  43:../../os/rt/include/chsem.h **** /*===========================================================================*/
  44:../../os/rt/include/chsem.h **** 
  45:../../os/rt/include/chsem.h **** /*===========================================================================*/
  46:../../os/rt/include/chsem.h **** /* Module data structures and types.                                         */
  47:../../os/rt/include/chsem.h **** /*===========================================================================*/
  48:../../os/rt/include/chsem.h **** 
  49:../../os/rt/include/chsem.h **** /**
  50:../../os/rt/include/chsem.h ****  * @brief   Semaphore structure.
  51:../../os/rt/include/chsem.h ****  */
  52:../../os/rt/include/chsem.h **** typedef struct ch_semaphore {
  53:../../os/rt/include/chsem.h ****   ch_queue_t            queue;      /**< @brief Queue of the threads sleeping
  54:../../os/rt/include/chsem.h ****                                                 on this semaphore.          */
  55:../../os/rt/include/chsem.h ****   cnt_t                 cnt;        /**< @brief The semaphore counter.      */
  56:../../os/rt/include/chsem.h **** } semaphore_t;
  57:../../os/rt/include/chsem.h **** 
  58:../../os/rt/include/chsem.h **** /*===========================================================================*/
  59:../../os/rt/include/chsem.h **** /* Module macros.                                                            */
  60:../../os/rt/include/chsem.h **** /*===========================================================================*/
  61:../../os/rt/include/chsem.h **** 
  62:../../os/rt/include/chsem.h **** /**
  63:../../os/rt/include/chsem.h ****  * @brief   Data part of a static semaphore initializer.
  64:../../os/rt/include/chsem.h ****  * @details This macro should be used when statically initializing a semaphore
  65:../../os/rt/include/chsem.h ****  *          that is part of a bigger structure.
  66:../../os/rt/include/chsem.h ****  *
  67:../../os/rt/include/chsem.h ****  * @param[in] name      the name of the semaphore variable
  68:../../os/rt/include/chsem.h ****  * @param[in] n         the counter initial value, this value must be
  69:../../os/rt/include/chsem.h ****  *                      non-negative
  70:../../os/rt/include/chsem.h ****  */
  71:../../os/rt/include/chsem.h **** #define __SEMAPHORE_DATA(name, n) {__CH_QUEUE_DATA(name.queue), n}
  72:../../os/rt/include/chsem.h **** 
  73:../../os/rt/include/chsem.h **** /**
  74:../../os/rt/include/chsem.h ****  * @brief   Static semaphore initializer.
  75:../../os/rt/include/chsem.h ****  * @details Statically initialized semaphores require no explicit
  76:../../os/rt/include/chsem.h ****  *          initialization using @p chSemInit().
  77:../../os/rt/include/chsem.h ****  *
  78:../../os/rt/include/chsem.h ****  * @param[in] name      the name of the semaphore variable
  79:../../os/rt/include/chsem.h ****  * @param[in] n         the counter initial value, this value must be
  80:../../os/rt/include/chsem.h ****  *                      non-negative
  81:../../os/rt/include/chsem.h ****  */
  82:../../os/rt/include/chsem.h **** #define SEMAPHORE_DECL(name, n) semaphore_t name = __SEMAPHORE_DATA(name, n)
  83:../../os/rt/include/chsem.h **** 
  84:../../os/rt/include/chsem.h **** /*===========================================================================*/
  85:../../os/rt/include/chsem.h **** /* External declarations.                                                    */
  86:../../os/rt/include/chsem.h **** /*===========================================================================*/
  87:../../os/rt/include/chsem.h **** 
  88:../../os/rt/include/chsem.h **** #ifdef __cplusplus
  89:../../os/rt/include/chsem.h **** extern "C" {
  90:../../os/rt/include/chsem.h **** #endif
  91:../../os/rt/include/chsem.h ****   void chSemObjectInit(semaphore_t *sp, cnt_t n);
  92:../../os/rt/include/chsem.h ****   void chSemResetWithMessage(semaphore_t *sp, cnt_t n, msg_t msg);
  93:../../os/rt/include/chsem.h ****   void chSemResetWithMessageI(semaphore_t *sp, cnt_t n, msg_t msg);
  94:../../os/rt/include/chsem.h ****   msg_t chSemWait(semaphore_t *sp);
  95:../../os/rt/include/chsem.h ****   msg_t chSemWaitS(semaphore_t *sp);
  96:../../os/rt/include/chsem.h ****   msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout);
  97:../../os/rt/include/chsem.h ****   msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout);
  98:../../os/rt/include/chsem.h ****   void chSemSignal(semaphore_t *sp);
  99:../../os/rt/include/chsem.h ****   void chSemSignalI(semaphore_t *sp);
 100:../../os/rt/include/chsem.h ****   void chSemAddCounterI(semaphore_t *sp, cnt_t n);
 101:../../os/rt/include/chsem.h ****   msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw);
 102:../../os/rt/include/chsem.h **** #ifdef __cplusplus
 103:../../os/rt/include/chsem.h **** }
 104:../../os/rt/include/chsem.h **** #endif
 105:../../os/rt/include/chsem.h **** 
 106:../../os/rt/include/chsem.h **** /*===========================================================================*/
 107:../../os/rt/include/chsem.h **** /* Module inline functions.                                                  */
 108:../../os/rt/include/chsem.h **** /*===========================================================================*/
 109:../../os/rt/include/chsem.h **** 
 110:../../os/rt/include/chsem.h **** /**
 111:../../os/rt/include/chsem.h ****  * @brief   Performs a reset operation on the semaphore.
 112:../../os/rt/include/chsem.h ****  * @post    After invoking this function all the threads waiting on the
 113:../../os/rt/include/chsem.h ****  *          semaphore, if any, are released and the semaphore counter is set
 114:../../os/rt/include/chsem.h ****  *          to the specified, non negative, value.
 115:../../os/rt/include/chsem.h ****  * @note    This function implicitly sends @p MSG_RESET as message.
 116:../../os/rt/include/chsem.h ****  *
 117:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 118:../../os/rt/include/chsem.h ****  * @param[in] n         the new value of the semaphore counter. The value must
 119:../../os/rt/include/chsem.h ****  *                      be non-negative.
 120:../../os/rt/include/chsem.h ****  *
 121:../../os/rt/include/chsem.h ****  * @api
 122:../../os/rt/include/chsem.h ****  */
 123:../../os/rt/include/chsem.h **** static inline void chSemReset(semaphore_t *sp, cnt_t n) {
 124:../../os/rt/include/chsem.h **** 
 125:../../os/rt/include/chsem.h ****   chSemResetWithMessage(sp, n, MSG_RESET);
 126:../../os/rt/include/chsem.h **** }
 127:../../os/rt/include/chsem.h **** 
 128:../../os/rt/include/chsem.h **** /**
 129:../../os/rt/include/chsem.h ****  * @brief   Performs a reset operation on the semaphore.
 130:../../os/rt/include/chsem.h ****  * @post    After invoking this function all the threads waiting on the
 131:../../os/rt/include/chsem.h ****  *          semaphore, if any, are released and the semaphore counter is set
 132:../../os/rt/include/chsem.h ****  *          to the specified, non negative, value.
 133:../../os/rt/include/chsem.h ****  * @post    This function does not reschedule so a call to a rescheduling
 134:../../os/rt/include/chsem.h ****  *          function must be performed before unlocking the kernel. Note that
 135:../../os/rt/include/chsem.h ****  *          interrupt handlers always reschedule on exit so an explicit
 136:../../os/rt/include/chsem.h ****  *          reschedule must not be performed in ISRs.
 137:../../os/rt/include/chsem.h ****  * @note    This function implicitly sends @p MSG_RESET as message.
 138:../../os/rt/include/chsem.h ****  *
 139:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 140:../../os/rt/include/chsem.h ****  * @param[in] n         the new value of the semaphore counter. The value must
 141:../../os/rt/include/chsem.h ****  *                      be non-negative.
 142:../../os/rt/include/chsem.h ****  *
 143:../../os/rt/include/chsem.h ****  * @iclass
 144:../../os/rt/include/chsem.h ****  */
 145:../../os/rt/include/chsem.h **** static inline void chSemResetI(semaphore_t *sp, cnt_t n) {
 146:../../os/rt/include/chsem.h **** 
 147:../../os/rt/include/chsem.h ****   chSemResetWithMessageI(sp, n, MSG_RESET);
 148:../../os/rt/include/chsem.h **** }
 149:../../os/rt/include/chsem.h **** 
 150:../../os/rt/include/chsem.h **** /**
 151:../../os/rt/include/chsem.h ****  * @brief   Decreases the semaphore counter.
 152:../../os/rt/include/chsem.h ****  * @details This macro can be used when the counter is known to be positive.
 153:../../os/rt/include/chsem.h ****  *
 154:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 155:../../os/rt/include/chsem.h ****  *
 156:../../os/rt/include/chsem.h ****  * @iclass
 157:../../os/rt/include/chsem.h ****  */
 158:../../os/rt/include/chsem.h **** static inline void chSemFastWaitI(semaphore_t *sp) {
 159:../../os/rt/include/chsem.h **** 
 160:../../os/rt/include/chsem.h ****   chDbgCheckClassI();
 161:../../os/rt/include/chsem.h **** 
 162:../../os/rt/include/chsem.h ****   sp->cnt--;
 163:../../os/rt/include/chsem.h **** }
 164:../../os/rt/include/chsem.h **** 
 165:../../os/rt/include/chsem.h **** /**
 166:../../os/rt/include/chsem.h ****  * @brief   Increases the semaphore counter.
 167:../../os/rt/include/chsem.h ****  * @details This macro can be used when the counter is known to be not
 168:../../os/rt/include/chsem.h ****  *          negative.
 169:../../os/rt/include/chsem.h ****  *
 170:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 171:../../os/rt/include/chsem.h ****  *
 172:../../os/rt/include/chsem.h ****  * @iclass
 173:../../os/rt/include/chsem.h ****  */
 174:../../os/rt/include/chsem.h **** static inline void chSemFastSignalI(semaphore_t *sp) {
 175:../../os/rt/include/chsem.h **** 
 176:../../os/rt/include/chsem.h ****   chDbgCheckClassI();
 177:../../os/rt/include/chsem.h **** 
 178:../../os/rt/include/chsem.h ****   sp->cnt++;
 134               		.loc 3 178 0
 135 0086 8481      		ldd r24,Z+4
 136 0088 8F5F      		subi r24,lo8(-(1))
 137 008a 8483      		std Z+4,r24
 138               	.LVL8:
 139               	.L3:
 140               	.LBE70:
 141               	.LBE69:
 142               	.LBB71:
 143               	.LBB72:
 320:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 144               		.loc 2 320 0
 145 008c 1296      		adiw r26,2
 146 008e ED91      		ld r30,X+
 147 0090 FC91      		ld r31,X
 148 0092 1397      		sbiw r26,2+1
 149 0094 8D91      		ld r24,X+
 150 0096 9C91      		ld r25,X
 151 0098 1197      		sbiw r26,1
 152 009a 9183      		std Z+1,r25
 153 009c 8083      		st Z,r24
 321:../../os/rt/include/chlists.h **** 
 154               		.loc 2 321 0
 155 009e CD91      		ld r28,X+
 156 00a0 DC91      		ld r29,X
 157 00a2 1197      		sbiw r26,1
 158 00a4 FB83      		std Y+3,r31
 159 00a6 EA83      		std Y+2,r30
 160 00a8 00C0      		rjmp .L2
 161               	.LBE72:
 162               	.LBE71:
 163               		.cfi_endproc
 164               	.LFE199:
 166               		.section	.text.chSchReadyI,"ax",@progbits
 167               	.global	chSchReadyI
 169               	chSchReadyI:
 170               	.LFB200:
 234:../../os/rt/src/chschd.c **** 
 235:../../os/rt/src/chschd.c **** /*===========================================================================*/
 236:../../os/rt/src/chschd.c **** /* Module exported functions.                                                */
 237:../../os/rt/src/chschd.c **** /*===========================================================================*/
 238:../../os/rt/src/chschd.c **** 
 239:../../os/rt/src/chschd.c **** #if (CH_CFG_OPTIMIZE_SPEED == FALSE) || defined(__DOXYGEN__)
 240:../../os/rt/src/chschd.c **** /**
 241:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread into a priority ordered queue.
 242:../../os/rt/src/chschd.c ****  * @note    The insertion is done by scanning the list from the highest
 243:../../os/rt/src/chschd.c ****  *          priority toward the lowest.
 244:../../os/rt/src/chschd.c ****  *
 245:../../os/rt/src/chschd.c ****  * @param[in] qp        the pointer to the threads list header
 246:../../os/rt/src/chschd.c ****  * @param[in] tp        the pointer to the thread to be inserted in the list
 247:../../os/rt/src/chschd.c ****  *
 248:../../os/rt/src/chschd.c ****  * @notapi
 249:../../os/rt/src/chschd.c ****  */
 250:../../os/rt/src/chschd.c **** void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 251:../../os/rt/src/chschd.c **** 
 252:../../os/rt/src/chschd.c ****   ch_queue_t *cp = qp;
 253:../../os/rt/src/chschd.c ****   do {
 254:../../os/rt/src/chschd.c ****     cp = cp->next;
 255:../../os/rt/src/chschd.c ****   } while ((cp != qp) &&
 256:../../os/rt/src/chschd.c ****            (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 257:../../os/rt/src/chschd.c ****   tp->next       = cp;
 258:../../os/rt/src/chschd.c ****   tp->prev       = cp->prev;
 259:../../os/rt/src/chschd.c ****   tp->prev->next = tp;
 260:../../os/rt/src/chschd.c ****   cp->prev       = tp;
 261:../../os/rt/src/chschd.c **** }
 262:../../os/rt/src/chschd.c **** #endif /* CH_CFG_OPTIMIZE_SPEED */
 263:../../os/rt/src/chschd.c **** 
 264:../../os/rt/src/chschd.c **** /**
 265:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it behind its peers.
 266:../../os/rt/src/chschd.c ****  * @details The thread is positioned behind all threads with higher or equal
 267:../../os/rt/src/chschd.c ****  *          priority.
 268:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
 269:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
 270:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
 271:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
 272:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
 273:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
 274:../../os/rt/src/chschd.c ****  *
 275:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
 276:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
 277:../../os/rt/src/chschd.c ****  *
 278:../../os/rt/src/chschd.c ****  * @iclass
 279:../../os/rt/src/chschd.c ****  */
 280:../../os/rt/src/chschd.c **** thread_t *chSchReadyI(thread_t *tp) {
 171               		.loc 1 280 0
 172               		.cfi_startproc
 173               	.LVL9:
 174 0000 CF93      		push r28
 175               	.LCFI2:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 28, -2
 178 0002 DF93      		push r29
 179               	.LCFI3:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 29, -3
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 2 */
 185               	.L__stack_usage = 2
 186 0004 DC01      		movw r26,r24
 187               	.LVL10:
 188               	.LBB73:
 189               	.LBB74:
  77:../../os/rt/src/chschd.c **** 
 190               		.loc 1 77 0
 191 0006 1F96      		adiw r26,15
 192 0008 1C92      		st X,__zero_reg__
 193 000a 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 194               		.loc 1 80 0
 195 000c 1B96      		adiw r26,11
 196 000e ED91      		ld r30,X+
 197 0010 FC91      		ld r31,X
 198 0012 1C97      		sbiw r26,11+1
 199               	.LVL11:
 200               	.LBB75:
 201               	.LBB76:
 379:../../os/rt/include/chlists.h **** 
 202               		.loc 2 379 0
 203 0014 1496      		adiw r26,4
 204 0016 8C91      		ld r24,X
 205 0018 1497      		sbiw r26,4
 206               	.LVL12:
 207               	.L24:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 208               		.loc 2 378 0
 209 001a 0190      		ld __tmp_reg__,Z+
 210 001c F081      		ld r31,Z
 211 001e E02D      		mov r30,__tmp_reg__
 212               	.LVL13:
 379:../../os/rt/include/chlists.h **** 
 213               		.loc 2 379 0
 214 0020 9481      		ldd r25,Z+4
 215 0022 9817      		cp r25,r24
 216 0024 00F4      		brsh .L24
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 217               		.loc 2 382 0
 218 0026 1196      		adiw r26,1
 219 0028 FC93      		st X,r31
 220 002a EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 221               		.loc 2 383 0
 222 002c C281      		ldd r28,Z+2
 223 002e D381      		ldd r29,Z+3
 224 0030 1396      		adiw r26,2+1
 225 0032 DC93      		st X,r29
 226 0034 CE93      		st -X,r28
 227 0036 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 228               		.loc 2 384 0
 229 0038 B983      		std Y+1,r27
 230 003a A883      		st Y,r26
 231               		.loc 2 385 0
 232 003c B383      		std Z+3,r27
 233 003e A283      		std Z+2,r26
 234               	.LVL14:
 235               	.LBE76:
 236               	.LBE75:
 237               	.LBE74:
 238               	.LBE73:
 281:../../os/rt/src/chschd.c **** 
 282:../../os/rt/src/chschd.c ****   chDbgCheckClassI();
 283:../../os/rt/src/chschd.c ****   chDbgCheck(tp != NULL);
 284:../../os/rt/src/chschd.c **** 
 285:../../os/rt/src/chschd.c **** #if CH_CFG_SMP_MODE == TRUE
 286:../../os/rt/src/chschd.c ****   if (tp->owner != currcore) {
 287:../../os/rt/src/chschd.c ****     /* Readying up the remote thread and triggering a reschedule on
 288:../../os/rt/src/chschd.c ****        the other core.*/
 289:../../os/rt/src/chschd.c ****     chSysNotifyInstance(tp->owner);
 290:../../os/rt/src/chschd.c ****   }
 291:../../os/rt/src/chschd.c **** #endif
 292:../../os/rt/src/chschd.c **** 
 293:../../os/rt/src/chschd.c ****   return __sch_ready_behind(tp);
 294:../../os/rt/src/chschd.c **** }
 239               		.loc 1 294 0
 240 0040 CD01      		movw r24,r26
 241               	/* epilogue start */
 242 0042 DF91      		pop r29
 243 0044 CF91      		pop r28
 244 0046 0895      		ret
 245               		.cfi_endproc
 246               	.LFE200:
 248               		.section	.text.chSchGoSleepS,"ax",@progbits
 249               	.global	chSchGoSleepS
 251               	chSchGoSleepS:
 252               	.LFB201:
 295:../../os/rt/src/chschd.c **** 
 296:../../os/rt/src/chschd.c **** /**
 297:../../os/rt/src/chschd.c ****  * @brief   Puts the current thread to sleep into the specified state.
 298:../../os/rt/src/chschd.c ****  * @details The thread goes into a sleeping state. The possible
 299:../../os/rt/src/chschd.c ****  *          @ref thread_states are defined into @p threads.h.
 300:../../os/rt/src/chschd.c ****  *
 301:../../os/rt/src/chschd.c ****  * @param[in] newstate  the new thread state
 302:../../os/rt/src/chschd.c ****  *
 303:../../os/rt/src/chschd.c ****  * @sclass
 304:../../os/rt/src/chschd.c ****  */
 305:../../os/rt/src/chschd.c **** void chSchGoSleepS(tstate_t newstate) {
 253               		.loc 1 305 0
 254               		.cfi_startproc
 255               	.LVL15:
 256 0000 CF93      		push r28
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 28, -2
 260 0002 DF93      		push r29
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 29, -3
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 2 */
 267               	.L__stack_usage = 2
 268               	.LVL16:
 306:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 307:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 269               		.loc 1 307 0
 270 0004 E0E0      		ldi r30,lo8(ch0)
 271 0006 F0E0      		ldi r31,hi8(ch0)
 272 0008 6581      		ldd r22,Z+5
 273 000a 7681      		ldd r23,Z+6
 274               	.LVL17:
 308:../../os/rt/src/chschd.c ****   thread_t *ntp;
 309:../../os/rt/src/chschd.c **** 
 310:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 311:../../os/rt/src/chschd.c **** 
 312:../../os/rt/src/chschd.c ****   chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 313:../../os/rt/src/chschd.c ****   chDbgAssert(otp->owner == oip, "invalid core");
 314:../../os/rt/src/chschd.c **** 
 315:../../os/rt/src/chschd.c ****   /* New state.*/
 316:../../os/rt/src/chschd.c ****   otp->state = newstate;
 275               		.loc 1 316 0
 276 000c DB01      		movw r26,r22
 277 000e 1F96      		adiw r26,15
 278 0010 8C93      		st X,r24
 279               	.LVL18:
 280               	.LBB77:
 281               	.LBB78:
 353:../../os/rt/include/chlists.h **** 
 282               		.loc 2 353 0
 283 0012 8081      		ld r24,Z
 284 0014 9181      		ldd r25,Z+1
 285               	.LVL19:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 286               		.loc 2 355 0
 287 0016 EC01      		movw r28,r24
 288 0018 A881      		ld r26,Y
 289 001a B981      		ldd r27,Y+1
 290 001c B183      		std Z+1,r27
 291 001e A083      		st Z,r26
 356:../../os/rt/include/chlists.h **** 
 292               		.loc 2 356 0
 293 0020 1396      		adiw r26,2+1
 294 0022 FC93      		st X,r31
 295 0024 EE93      		st -X,r30
 296 0026 1297      		sbiw r26,2
 297               	.LVL20:
 298               	.LBE78:
 299               	.LBE77:
 317:../../os/rt/src/chschd.c **** 
 318:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 319:../../os/rt/src/chschd.c ****   /* The thread is renouncing its remaining time slices so it will have a new
 320:../../os/rt/src/chschd.c ****      time quantum when it will wakeup.*/
 321:../../os/rt/src/chschd.c ****   otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 322:../../os/rt/src/chschd.c **** #endif
 323:../../os/rt/src/chschd.c **** 
 324:../../os/rt/src/chschd.c ****   /* Next thread in ready list becomes current.*/
 325:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 326:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 300               		.loc 1 326 0
 301 0028 21E0      		ldi r18,lo8(1)
 302 002a 2F87      		std Y+15,r18
 327:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 303               		.loc 1 327 0
 304 002c 9683      		std Z+6,r25
 305 002e 8583      		std Z+5,r24
 328:../../os/rt/src/chschd.c **** 
 329:../../os/rt/src/chschd.c ****   /* Handling idle-enter hook.*/
 330:../../os/rt/src/chschd.c ****   if (ntp->hdr.pqueue.prio == IDLEPRIO) {
 331:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_ENTER_HOOK();
 332:../../os/rt/src/chschd.c ****   }
 333:../../os/rt/src/chschd.c **** 
 334:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 335:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 306               		.loc 1 335 0
 307 0030 0E94 0000 		call _port_switch
 308               	.LVL21:
 309               	/* epilogue start */
 336:../../os/rt/src/chschd.c **** }
 310               		.loc 1 336 0
 311 0034 DF91      		pop r29
 312 0036 CF91      		pop r28
 313 0038 0895      		ret
 314               		.cfi_endproc
 315               	.LFE201:
 317               		.section	.text.chSchGoSleepTimeoutS,"ax",@progbits
 318               	.global	chSchGoSleepTimeoutS
 320               	chSchGoSleepTimeoutS:
 321               	.LFB202:
 337:../../os/rt/src/chschd.c **** 
 338:../../os/rt/src/chschd.c **** /**
 339:../../os/rt/src/chschd.c ****  * @brief   Puts the current thread to sleep into the specified state with
 340:../../os/rt/src/chschd.c ****  *          timeout specification.
 341:../../os/rt/src/chschd.c ****  * @details The thread goes into a sleeping state, if it is not awakened
 342:../../os/rt/src/chschd.c ****  *          explicitly within the specified timeout then it is forcibly
 343:../../os/rt/src/chschd.c ****  *          awakened with a @p MSG_TIMEOUT low level message. The possible
 344:../../os/rt/src/chschd.c ****  *          @ref thread_states are defined into @p threads.h.
 345:../../os/rt/src/chschd.c ****  *
 346:../../os/rt/src/chschd.c ****  * @param[in] newstate  the new thread state
 347:../../os/rt/src/chschd.c ****  * @param[in] timeout   the number of ticks before the operation timeouts, the
 348:../../os/rt/src/chschd.c ****  *                      special values are handled as follow:
 349:../../os/rt/src/chschd.c ****  *                      - @a TIME_INFINITE the thread enters an infinite sleep
 350:../../os/rt/src/chschd.c ****  *                        state, this is equivalent to invoking
 351:../../os/rt/src/chschd.c ****  *                        @p chSchGoSleepS() but, of course, less efficient.
 352:../../os/rt/src/chschd.c ****  *                      - @a TIME_IMMEDIATE this value is not allowed.
 353:../../os/rt/src/chschd.c ****  *                      .
 354:../../os/rt/src/chschd.c ****  * @return              The wakeup message.
 355:../../os/rt/src/chschd.c ****  * @retval MSG_TIMEOUT  if a timeout occurs.
 356:../../os/rt/src/chschd.c ****  *
 357:../../os/rt/src/chschd.c ****  * @sclass
 358:../../os/rt/src/chschd.c ****  */
 359:../../os/rt/src/chschd.c **** msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 322               		.loc 1 359 0
 323               		.cfi_startproc
 324               	.LVL22:
 325 0000 DF92      		push r13
 326               	.LCFI6:
 327               		.cfi_def_cfa_offset 3
 328               		.cfi_offset 13, -2
 329 0002 EF92      		push r14
 330               	.LCFI7:
 331               		.cfi_def_cfa_offset 4
 332               		.cfi_offset 14, -3
 333 0004 FF92      		push r15
 334               	.LCFI8:
 335               		.cfi_def_cfa_offset 5
 336               		.cfi_offset 15, -4
 337 0006 0F93      		push r16
 338               	.LCFI9:
 339               		.cfi_def_cfa_offset 6
 340               		.cfi_offset 16, -5
 341 0008 1F93      		push r17
 342               	.LCFI10:
 343               		.cfi_def_cfa_offset 7
 344               		.cfi_offset 17, -6
 345 000a CF93      		push r28
 346               	.LCFI11:
 347               		.cfi_def_cfa_offset 8
 348               		.cfi_offset 28, -7
 349 000c DF93      		push r29
 350               	.LCFI12:
 351               		.cfi_def_cfa_offset 9
 352               		.cfi_offset 29, -8
 353 000e CDB7      		in r28,__SP_L__
 354 0010 DEB7      		in r29,__SP_H__
 355               	.LCFI13:
 356               		.cfi_def_cfa_register 28
 357 0012 6097      		sbiw r28,16
 358               	.LCFI14:
 359               		.cfi_def_cfa_offset 25
 360 0014 0FB6      		in __tmp_reg__,__SREG__
 361 0016 F894      		cli
 362 0018 DEBF      		out __SP_H__,r29
 363 001a 0FBE      		out __SREG__,__tmp_reg__
 364 001c CDBF      		out __SP_L__,r28
 365               	/* prologue: function */
 366               	/* frame size = 16 */
 367               	/* stack size = 23 */
 368               	.L__stack_usage = 23
 369 001e D82E      		mov r13,r24
 360:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(currcore);
 370               		.loc 1 360 0
 371 0020 E090 0000 		lds r14,ch0+5
 372 0024 F090 0000 		lds r15,ch0+5+1
 373               	.LVL23:
 361:../../os/rt/src/chschd.c **** 
 362:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 363:../../os/rt/src/chschd.c **** 
 364:../../os/rt/src/chschd.c ****   if (TIME_INFINITE != timeout) {
 374               		.loc 1 364 0
 375 0028 4F3F      		cpi r20,-1
 376 002a 8FEF      		ldi r24,-1
 377 002c 5807      		cpc r21,r24
 378 002e 6807      		cpc r22,r24
 379 0030 7807      		cpc r23,r24
 380               	.LVL24:
 381 0032 01F0      		breq .L28
 382               	.LBB79:
 365:../../os/rt/src/chschd.c ****     virtual_timer_t vt;
 366:../../os/rt/src/chschd.c **** 
 367:../../os/rt/src/chschd.c ****     chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 383               		.loc 1 367 0
 384 0034 8701      		movw r16,r14
 385 0036 20E0      		ldi r18,lo8(gs(__sch_wakeup))
 386 0038 30E0      		ldi r19,hi8(gs(__sch_wakeup))
 387 003a CE01      		movw r24,r28
 388 003c 0196      		adiw r24,1
 389 003e 0E94 0000 		call chVTDoSetI
 390               	.LVL25:
 368:../../os/rt/src/chschd.c ****     chSchGoSleepS(newstate);
 391               		.loc 1 368 0
 392 0042 8D2D      		mov r24,r13
 393 0044 0E94 0000 		call chSchGoSleepS
 394               	.LVL26:
 369:../../os/rt/src/chschd.c ****     if (chVTIsArmedI(&vt)) {
 395               		.loc 1 369 0
 396 0048 8981      		ldd r24,Y+1
 397 004a 9A81      		ldd r25,Y+2
 398 004c 892B      		or r24,r25
 399 004e 01F0      		breq .L30
 370:../../os/rt/src/chschd.c ****       chVTDoResetI(&vt);
 400               		.loc 1 370 0
 401 0050 CE01      		movw r24,r28
 402 0052 0196      		adiw r24,1
 403 0054 0E94 0000 		call chVTDoResetI
 404               	.LVL27:
 405               	.L30:
 406               	.LBE79:
 371:../../os/rt/src/chschd.c ****     }
 372:../../os/rt/src/chschd.c ****   }
 373:../../os/rt/src/chschd.c ****   else {
 374:../../os/rt/src/chschd.c ****     chSchGoSleepS(newstate);
 375:../../os/rt/src/chschd.c ****   }
 376:../../os/rt/src/chschd.c **** 
 377:../../os/rt/src/chschd.c ****   return tp->u.rdymsg;
 378:../../os/rt/src/chschd.c **** }
 407               		.loc 1 378 0
 408 0058 F701      		movw r30,r14
 409 005a 8289      		ldd r24,Z+18
 410 005c 9389      		ldd r25,Z+19
 411               	/* epilogue start */
 412 005e 6096      		adiw r28,16
 413 0060 0FB6      		in __tmp_reg__,__SREG__
 414 0062 F894      		cli
 415 0064 DEBF      		out __SP_H__,r29
 416 0066 0FBE      		out __SREG__,__tmp_reg__
 417 0068 CDBF      		out __SP_L__,r28
 418 006a DF91      		pop r29
 419 006c CF91      		pop r28
 420 006e 1F91      		pop r17
 421 0070 0F91      		pop r16
 422 0072 FF90      		pop r15
 423 0074 EF90      		pop r14
 424               	.LVL28:
 425 0076 DF90      		pop r13
 426               	.LVL29:
 427 0078 0895      		ret
 428               	.LVL30:
 429               	.L28:
 374:../../os/rt/src/chschd.c ****   }
 430               		.loc 1 374 0
 431 007a 8D2D      		mov r24,r13
 432 007c 0E94 0000 		call chSchGoSleepS
 433               	.LVL31:
 434 0080 00C0      		rjmp .L30
 435               		.cfi_endproc
 436               	.LFE202:
 438               		.section	.text.chSchWakeupS,"ax",@progbits
 439               	.global	chSchWakeupS
 441               	chSchWakeupS:
 442               	.LFB203:
 379:../../os/rt/src/chschd.c **** 
 380:../../os/rt/src/chschd.c **** /**
 381:../../os/rt/src/chschd.c ****  * @brief   Wakes up a thread.
 382:../../os/rt/src/chschd.c ****  * @details The thread is inserted into the ready list or immediately made
 383:../../os/rt/src/chschd.c ****  *          running depending on its relative priority compared to the current
 384:../../os/rt/src/chschd.c ****  *          thread.
 385:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
 386:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
 387:../../os/rt/src/chschd.c ****  * @note    It is equivalent to a @p chSchReadyI() followed by a
 388:../../os/rt/src/chschd.c ****  *          @p chSchRescheduleS() but much more efficient.
 389:../../os/rt/src/chschd.c ****  * @note    The function assumes that the current thread has the highest
 390:../../os/rt/src/chschd.c ****  *          priority.
 391:../../os/rt/src/chschd.c ****  *
 392:../../os/rt/src/chschd.c ****  * @param[in] ntp       the thread to be made ready
 393:../../os/rt/src/chschd.c ****  * @param[in] msg       the wakeup message
 394:../../os/rt/src/chschd.c ****  *
 395:../../os/rt/src/chschd.c ****  * @sclass
 396:../../os/rt/src/chschd.c ****  */
 397:../../os/rt/src/chschd.c **** void chSchWakeupS(thread_t *ntp, msg_t msg) {
 443               		.loc 1 397 0
 444               		.cfi_startproc
 445               	.LVL32:
 446 0000 CF93      		push r28
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 3
 449               		.cfi_offset 28, -2
 450 0002 DF93      		push r29
 451               	.LCFI16:
 452               		.cfi_def_cfa_offset 4
 453               		.cfi_offset 29, -3
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 2 */
 457               	.L__stack_usage = 2
 458 0004 DC01      		movw r26,r24
 459               	.LVL33:
 398:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 399:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 460               		.loc 1 399 0
 461 0006 C091 0000 		lds r28,ch0+5
 462 000a D091 0000 		lds r29,ch0+5+1
 463               	.LVL34:
 400:../../os/rt/src/chschd.c **** 
 401:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 402:../../os/rt/src/chschd.c **** 
 403:../../os/rt/src/chschd.c ****   chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 404:../../os/rt/src/chschd.c ****               (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
 405:../../os/rt/src/chschd.c ****               "priority order violation");
 406:../../os/rt/src/chschd.c **** 
 407:../../os/rt/src/chschd.c ****   /* Storing the message to be retrieved by the target thread when it will
 408:../../os/rt/src/chschd.c ****      restart execution.*/
 409:../../os/rt/src/chschd.c ****   ntp->u.rdymsg = msg;
 464               		.loc 1 409 0
 465 000e 5396      		adiw r26,18+1
 466 0010 7C93      		st X,r23
 467 0012 6E93      		st -X,r22
 468 0014 5297      		sbiw r26,18
 410:../../os/rt/src/chschd.c **** 
 411:../../os/rt/src/chschd.c **** #if CH_CFG_SMP_MODE == TRUE
 412:../../os/rt/src/chschd.c ****   if (ntp->owner != oip) {
 413:../../os/rt/src/chschd.c ****     /* Readying up the remote thread and triggering a reschedule on
 414:../../os/rt/src/chschd.c ****        the other core.*/
 415:../../os/rt/src/chschd.c ****     chSysNotifyInstance(ntp->owner);
 416:../../os/rt/src/chschd.c ****     (void) __sch_ready_behind(ntp);
 417:../../os/rt/src/chschd.c ****     return;
 418:../../os/rt/src/chschd.c ****   }
 419:../../os/rt/src/chschd.c **** #endif
 420:../../os/rt/src/chschd.c **** 
 421:../../os/rt/src/chschd.c ****   /* If the woken thread has a not-greater priority than the current
 422:../../os/rt/src/chschd.c ****      one then it is just inserted in the ready list else it made
 423:../../os/rt/src/chschd.c ****      running immediately and the invoking thread goes in the ready
 424:../../os/rt/src/chschd.c ****      list instead.
 425:../../os/rt/src/chschd.c ****      Note, we are favoring the path where the woken thread has higher
 426:../../os/rt/src/chschd.c ****      priority.*/
 427:../../os/rt/src/chschd.c ****   if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 469               		.loc 1 427 0
 470 0016 1496      		adiw r26,4
 471 0018 2C91      		ld r18,X
 472 001a 1497      		sbiw r26,4
 473 001c 9C81      		ldd r25,Y+4
 474 001e 9217      		cp r25,r18
 475 0020 00F0      		brlo .L35
 476               	.LVL35:
 477               	.LBB80:
 478               	.LBB81:
  77:../../os/rt/src/chschd.c **** 
 479               		.loc 1 77 0
 480 0022 1F96      		adiw r26,15
 481 0024 1C92      		st X,__zero_reg__
 482 0026 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 483               		.loc 1 80 0
 484 0028 1B96      		adiw r26,11
 485 002a ED91      		ld r30,X+
 486 002c FC91      		ld r31,X
 487 002e 1C97      		sbiw r26,11+1
 488               	.LVL36:
 489               	.L36:
 490               	.LBB82:
 491               	.LBB83:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 492               		.loc 2 378 0
 493 0030 0190      		ld __tmp_reg__,Z+
 494 0032 F081      		ld r31,Z
 495 0034 E02D      		mov r30,__tmp_reg__
 496               	.LVL37:
 379:../../os/rt/include/chlists.h **** 
 497               		.loc 2 379 0
 498 0036 8481      		ldd r24,Z+4
 499 0038 8217      		cp r24,r18
 500 003a 00F4      		brsh .L36
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 501               		.loc 2 382 0
 502 003c 1196      		adiw r26,1
 503 003e FC93      		st X,r31
 504 0040 EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 505               		.loc 2 383 0
 506 0042 C281      		ldd r28,Z+2
 507 0044 D381      		ldd r29,Z+3
 508               	.LVL38:
 509 0046 1396      		adiw r26,2+1
 510 0048 DC93      		st X,r29
 511 004a CE93      		st -X,r28
 512 004c 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 513               		.loc 2 384 0
 514 004e B983      		std Y+1,r27
 515 0050 A883      		st Y,r26
 516               		.loc 2 385 0
 517 0052 B383      		std Z+3,r27
 518 0054 A283      		std Z+2,r26
 519               	.LVL39:
 520               	/* epilogue start */
 521               	.LBE83:
 522               	.LBE82:
 523               	.LBE81:
 524               	.LBE80:
 428:../../os/rt/src/chschd.c ****     (void) __sch_ready_behind(ntp);
 429:../../os/rt/src/chschd.c ****   }
 430:../../os/rt/src/chschd.c ****   else {
 431:../../os/rt/src/chschd.c ****     /* The old thread goes back in the ready list ahead of its peers
 432:../../os/rt/src/chschd.c ****        because it has not exhausted its time slice.*/
 433:../../os/rt/src/chschd.c ****     otp = __sch_ready_ahead(otp);
 434:../../os/rt/src/chschd.c **** 
 435:../../os/rt/src/chschd.c ****     /* Handling idle-leave hook.*/
 436:../../os/rt/src/chschd.c ****     if (otp->hdr.pqueue.prio == IDLEPRIO) {
 437:../../os/rt/src/chschd.c ****       CH_CFG_IDLE_LEAVE_HOOK();
 438:../../os/rt/src/chschd.c ****     }
 439:../../os/rt/src/chschd.c **** 
 440:../../os/rt/src/chschd.c ****     /* The extracted thread is marked as current.*/
 441:../../os/rt/src/chschd.c ****     ntp->state = CH_STATE_CURRENT;
 442:../../os/rt/src/chschd.c ****     __instance_set_currthread(oip, ntp);
 443:../../os/rt/src/chschd.c **** 
 444:../../os/rt/src/chschd.c ****     /* Swap operation as tail call.*/
 445:../../os/rt/src/chschd.c ****     chSysSwitch(ntp, otp);
 446:../../os/rt/src/chschd.c ****   }
 447:../../os/rt/src/chschd.c **** }
 525               		.loc 1 447 0
 526 0056 DF91      		pop r29
 527 0058 CF91      		pop r28
 528 005a 0895      		ret
 529               	.LVL40:
 530               	.L35:
 531               	.LBB84:
 532               	.LBB85:
 110:../../os/rt/src/chschd.c **** 
 533               		.loc 1 110 0
 534 005c 1F86      		std Y+15,__zero_reg__
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 535               		.loc 1 113 0
 536 005e EB85      		ldd r30,Y+11
 537 0060 FC85      		ldd r31,Y+12
 538               	.LVL41:
 539               	.L38:
 540               	.LBB86:
 541               	.LBB87:
 386:../../os/rt/include/chlists.h **** 
 387:../../os/rt/include/chlists.h ****   return p;
 388:../../os/rt/include/chlists.h **** }
 389:../../os/rt/include/chlists.h **** 
 390:../../os/rt/include/chlists.h **** /**
 391:../../os/rt/include/chlists.h ****  * @brief   Inserts an element in the priority queue placing it ahead of
 392:../../os/rt/include/chlists.h ****  *          its peers.
 393:../../os/rt/include/chlists.h ****  * @details The element is positioned ahead of all elements with higher or
 394:../../os/rt/include/chlists.h ****  *          equal priority.
 395:../../os/rt/include/chlists.h ****  *
 396:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 397:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 398:../../os/rt/include/chlists.h ****  * @return              The inserted element pointer.
 399:../../os/rt/include/chlists.h ****  *
 400:../../os/rt/include/chlists.h ****  * @notapi
 401:../../os/rt/include/chlists.h ****  */
 402:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
 403:../../os/rt/include/chlists.h ****                                                           ch_priority_queue_t *p) {
 404:../../os/rt/include/chlists.h **** 
 405:../../os/rt/include/chlists.h ****   /* Scanning priority queue, the list is assumed to be mostly empty.*/
 406:../../os/rt/include/chlists.h ****   do {
 407:../../os/rt/include/chlists.h ****     pqp = pqp->next;
 542               		.loc 2 407 0
 543 0062 0190      		ld __tmp_reg__,Z+
 544 0064 F081      		ld r31,Z
 545 0066 E02D      		mov r30,__tmp_reg__
 546               	.LVL42:
 408:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 547               		.loc 2 408 0
 548 0068 8481      		ldd r24,Z+4
 549 006a 9817      		cp r25,r24
 550 006c 00F0      		brlo .L38
 551 006e CD01      		movw r24,r26
 409:../../os/rt/include/chlists.h **** 
 410:../../os/rt/include/chlists.h ****   /* Insertion on prev.*/
 411:../../os/rt/include/chlists.h ****   p->next       = pqp;
 552               		.loc 2 411 0
 553 0070 F983      		std Y+1,r31
 554 0072 E883      		st Y,r30
 412:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 555               		.loc 2 412 0
 556 0074 A281      		ldd r26,Z+2
 557 0076 B381      		ldd r27,Z+3
 558               	.LVL43:
 559 0078 BB83      		std Y+3,r27
 560 007a AA83      		std Y+2,r26
 413:../../os/rt/include/chlists.h ****   p->prev->next = p;
 561               		.loc 2 413 0
 562 007c CD93      		st X+,r28
 563 007e DC93      		st X,r29
 414:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 564               		.loc 2 414 0
 565 0080 D383      		std Z+3,r29
 566 0082 C283      		std Z+2,r28
 567               	.LVL44:
 568               	.LBE87:
 569               	.LBE86:
 570               	.LBE85:
 571               	.LBE84:
 441:../../os/rt/src/chschd.c ****     __instance_set_currthread(oip, ntp);
 572               		.loc 1 441 0
 573 0084 21E0      		ldi r18,lo8(1)
 574 0086 FC01      		movw r30,r24
 575 0088 2787      		std Z+15,r18
 442:../../os/rt/src/chschd.c **** 
 576               		.loc 1 442 0
 577 008a 9093 0000 		sts ch0+5+1,r25
 578 008e 8093 0000 		sts ch0+5,r24
 445:../../os/rt/src/chschd.c ****   }
 579               		.loc 1 445 0
 580 0092 BE01      		movw r22,r28
 581               	.LVL45:
 582 0094 0E94 0000 		call _port_switch
 583               	.LVL46:
 584               	/* epilogue start */
 585               		.loc 1 447 0
 586 0098 DF91      		pop r29
 587 009a CF91      		pop r28
 588 009c 0895      		ret
 589               		.cfi_endproc
 590               	.LFE203:
 592               		.section	.text.chSchIsPreemptionRequired,"ax",@progbits
 593               	.global	chSchIsPreemptionRequired
 595               	chSchIsPreemptionRequired:
 596               	.LFB205:
 448:../../os/rt/src/chschd.c **** 
 449:../../os/rt/src/chschd.c **** /**
 450:../../os/rt/src/chschd.c ****  * @brief   Performs a reschedule if a higher priority thread is runnable.
 451:../../os/rt/src/chschd.c ****  * @details If a thread with a higher priority than the current thread is in
 452:../../os/rt/src/chschd.c ****  *          the ready list then make the higher priority thread running.
 453:../../os/rt/src/chschd.c ****  * @note    Only local threads are considered, other cores are signaled
 454:../../os/rt/src/chschd.c ****  *          and perform a reschedule locally.
 455:../../os/rt/src/chschd.c ****  *
 456:../../os/rt/src/chschd.c ****  * @sclass
 457:../../os/rt/src/chschd.c ****  */
 458:../../os/rt/src/chschd.c **** void chSchRescheduleS(void) {
 459:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 460:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 461:../../os/rt/src/chschd.c **** 
 462:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 463:../../os/rt/src/chschd.c **** 
 464:../../os/rt/src/chschd.c ****   /* Note, we are favoring the path where the reschedule is necessary
 465:../../os/rt/src/chschd.c ****      because higher priority threads are ready.*/
 466:../../os/rt/src/chschd.c ****   if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 467:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 468:../../os/rt/src/chschd.c ****   }
 469:../../os/rt/src/chschd.c **** }
 470:../../os/rt/src/chschd.c **** 
 471:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_IS_PREEMPTION_REQUIRED_HOOKED)
 472:../../os/rt/src/chschd.c **** /**
 473:../../os/rt/src/chschd.c ****  * @brief   Evaluates if preemption is required.
 474:../../os/rt/src/chschd.c ****  * @details The decision is taken by comparing the relative priorities and
 475:../../os/rt/src/chschd.c ****  *          depending on the state of the round robin timeout counter.
 476:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 477:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 478:../../os/rt/src/chschd.c ****  *
 479:../../os/rt/src/chschd.c ****  * @retval true         if there is a thread that must go in running state
 480:../../os/rt/src/chschd.c ****  *                      immediately.
 481:../../os/rt/src/chschd.c ****  * @retval false        if preemption is not required.
 482:../../os/rt/src/chschd.c ****  *
 483:../../os/rt/src/chschd.c ****  * @special
 484:../../os/rt/src/chschd.c ****  */
 485:../../os/rt/src/chschd.c **** bool chSchIsPreemptionRequired(void) {
 597               		.loc 1 485 0
 598               		.cfi_startproc
 599               	/* prologue: function */
 600               	/* frame size = 0 */
 601               	/* stack size = 0 */
 602               	.L__stack_usage = 0
 603               	.LVL47:
 486:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 487:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 488:../../os/rt/src/chschd.c **** 
 489:../../os/rt/src/chschd.c ****   tprio_t p1 = firstprio(&oip->rlist.pqueue);
 604               		.loc 1 489 0
 605 0000 A091 0000 		lds r26,ch0
 606 0004 B091 0000 		lds r27,ch0+1
 490:../../os/rt/src/chschd.c ****   tprio_t p2 = tp->hdr.pqueue.prio;
 607               		.loc 1 490 0
 608 0008 E091 0000 		lds r30,ch0+5
 609 000c F091 0000 		lds r31,ch0+5+1
 491:../../os/rt/src/chschd.c **** 
 492:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 493:../../os/rt/src/chschd.c ****   /* If the running thread has not reached its time quantum, reschedule only
 494:../../os/rt/src/chschd.c ****      if the first thread on the ready queue has a higher priority.
 495:../../os/rt/src/chschd.c ****      Otherwise, if the running thread has used up its time quantum, reschedule
 496:../../os/rt/src/chschd.c ****      if the first thread on the ready queue has equal or higher priority.*/
 497:../../os/rt/src/chschd.c ****   return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 498:../../os/rt/src/chschd.c **** #else
 499:../../os/rt/src/chschd.c ****   /* If the round robin preemption feature is not enabled then performs a
 500:../../os/rt/src/chschd.c ****      simpler comparison.*/
 501:../../os/rt/src/chschd.c ****   return p1 > p2;
 610               		.loc 1 501 0
 611 0010 81E0      		ldi r24,lo8(1)
 612 0012 1496      		adiw r26,4
 613 0014 2C91      		ld r18,X
 614 0016 9481      		ldd r25,Z+4
 615 0018 9217      		cp r25,r18
 616 001a 00F0      		brlo .L42
 617 001c 80E0      		ldi r24,0
 618               	.L42:
 619               	/* epilogue start */
 502:../../os/rt/src/chschd.c **** #endif
 503:../../os/rt/src/chschd.c **** }
 620               		.loc 1 503 0
 621 001e 0895      		ret
 622               		.cfi_endproc
 623               	.LFE205:
 625               		.section	.text.chSchDoPreemption,"ax",@progbits
 626               	.global	chSchDoPreemption
 628               	chSchDoPreemption:
 629               	.LFB206:
 504:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_IS_PREEMPTION_REQUIRED_HOOKED) */
 505:../../os/rt/src/chschd.c **** 
 506:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_DO_PREEMPTION_HOOKED)
 507:../../os/rt/src/chschd.c **** /**
 508:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 509:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list behind or
 510:../../os/rt/src/chschd.c ****  *          ahead of all threads having the same priority depending on
 511:../../os/rt/src/chschd.c ****  *          if it used its whole time slice.
 512:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 513:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 514:../../os/rt/src/chschd.c ****  *
 515:../../os/rt/src/chschd.c ****  * @special
 516:../../os/rt/src/chschd.c ****  */
 517:../../os/rt/src/chschd.c **** void chSchDoPreemption(void) {
 630               		.loc 1 517 0
 631               		.cfi_startproc
 632 0000 CF93      		push r28
 633               	.LCFI17:
 634               		.cfi_def_cfa_offset 3
 635               		.cfi_offset 28, -2
 636 0002 DF93      		push r29
 637               	.LCFI18:
 638               		.cfi_def_cfa_offset 4
 639               		.cfi_offset 29, -3
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 2 */
 643               	.L__stack_usage = 2
 644               	.LVL48:
 518:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 519:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 645               		.loc 1 519 0
 646 0004 A091 0000 		lds r26,ch0+5
 647 0008 B091 0000 		lds r27,ch0+5+1
 648               	.LVL49:
 649               	.LBB88:
 650               	.LBB89:
 353:../../os/rt/include/chlists.h **** 
 651               		.loc 2 353 0
 652 000c 4091 0000 		lds r20,ch0
 653 0010 5091 0000 		lds r21,ch0+1
 654               	.LVL50:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 655               		.loc 2 355 0
 656 0014 EA01      		movw r28,r20
 657 0016 E881      		ld r30,Y
 658 0018 F981      		ldd r31,Y+1
 659 001a F093 0000 		sts ch0+1,r31
 660 001e E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 661               		.loc 2 356 0
 662 0022 80E0      		ldi r24,lo8(ch0)
 663 0024 90E0      		ldi r25,hi8(ch0)
 664 0026 9383      		std Z+3,r25
 665 0028 8283      		std Z+2,r24
 666               	.LVL51:
 667               	.LBE89:
 668               	.LBE88:
 520:../../os/rt/src/chschd.c ****   thread_t *ntp;
 521:../../os/rt/src/chschd.c **** 
 522:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 523:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 524:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 669               		.loc 1 524 0
 670 002a 81E0      		ldi r24,lo8(1)
 671 002c 8F87      		std Y+15,r24
 525:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 672               		.loc 1 525 0
 673 002e 5093 0000 		sts ch0+5+1,r21
 674 0032 4093 0000 		sts ch0+5,r20
 675               	.LVL52:
 676               	.LBB90:
 677               	.LBB91:
 110:../../os/rt/src/chschd.c **** 
 678               		.loc 1 110 0
 679 0036 1F96      		adiw r26,15
 680 0038 1C92      		st X,__zero_reg__
 681 003a 1F97      		sbiw r26,15
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 682               		.loc 1 113 0
 683 003c 1B96      		adiw r26,11
 684 003e ED91      		ld r30,X+
 685 0040 FC91      		ld r31,X
 686 0042 1C97      		sbiw r26,11+1
 687               	.LVL53:
 688               	.LBB92:
 689               	.LBB93:
 408:../../os/rt/include/chlists.h **** 
 690               		.loc 2 408 0
 691 0044 1496      		adiw r26,4
 692 0046 2C91      		ld r18,X
 693 0048 1497      		sbiw r26,4
 694               	.L44:
 407:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 695               		.loc 2 407 0
 696 004a 0190      		ld __tmp_reg__,Z+
 697 004c F081      		ld r31,Z
 698 004e E02D      		mov r30,__tmp_reg__
 699               	.LVL54:
 408:../../os/rt/include/chlists.h **** 
 700               		.loc 2 408 0
 701 0050 9481      		ldd r25,Z+4
 702 0052 2917      		cp r18,r25
 703 0054 00F0      		brlo .L44
 411:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 704               		.loc 2 411 0
 705 0056 1196      		adiw r26,1
 706 0058 FC93      		st X,r31
 707 005a EE93      		st -X,r30
 412:../../os/rt/include/chlists.h ****   p->prev->next = p;
 708               		.loc 2 412 0
 709 005c 8281      		ldd r24,Z+2
 710 005e 9381      		ldd r25,Z+3
 711 0060 1396      		adiw r26,2+1
 712 0062 9C93      		st X,r25
 713 0064 8E93      		st -X,r24
 714 0066 1297      		sbiw r26,2
 413:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 715               		.loc 2 413 0
 716 0068 EC01      		movw r28,r24
 717 006a B983      		std Y+1,r27
 718 006c A883      		st Y,r26
 719               		.loc 2 414 0
 720 006e B383      		std Z+3,r27
 721 0070 A283      		std Z+2,r26
 722               	.LVL55:
 723               	.LBE93:
 724               	.LBE92:
 725               	.LBE91:
 726               	.LBE90:
 526:../../os/rt/src/chschd.c **** 
 527:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 528:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 529:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 530:../../os/rt/src/chschd.c ****   }
 531:../../os/rt/src/chschd.c **** 
 532:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 533:../../os/rt/src/chschd.c ****   /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
 534:../../os/rt/src/chschd.c ****      to handle on preemption: time quantum elapsed or not.*/
 535:../../os/rt/src/chschd.c ****   if (otp->ticks == (tslices_t)0) {
 536:../../os/rt/src/chschd.c **** 
 537:../../os/rt/src/chschd.c ****     /* The thread consumed its time quantum so it is enqueued behind threads
 538:../../os/rt/src/chschd.c ****        with same priority level, however, it acquires a new time quantum.*/
 539:../../os/rt/src/chschd.c ****     otp = __sch_ready_behind(otp);
 540:../../os/rt/src/chschd.c **** 
 541:../../os/rt/src/chschd.c ****     /* The thread being swapped out receives a new time quantum.*/
 542:../../os/rt/src/chschd.c ****     otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 543:../../os/rt/src/chschd.c ****   }
 544:../../os/rt/src/chschd.c ****   else {
 545:../../os/rt/src/chschd.c ****     /* The thread didn't consume all its time quantum so it is put ahead of
 546:../../os/rt/src/chschd.c ****        threads with equal priority and does not acquire a new time quantum.*/
 547:../../os/rt/src/chschd.c ****     otp = __sch_ready_ahead(otp);
 548:../../os/rt/src/chschd.c ****   }
 549:../../os/rt/src/chschd.c **** #else /* !(CH_CFG_TIME_QUANTUM > 0) */
 550:../../os/rt/src/chschd.c ****   /* If the round-robin mechanism is disabled then the thread goes always
 551:../../os/rt/src/chschd.c ****      ahead of its peers.*/
 552:../../os/rt/src/chschd.c ****   otp = __sch_ready_ahead(otp);
 553:../../os/rt/src/chschd.c **** #endif /* !(CH_CFG_TIME_QUANTUM > 0) */
 554:../../os/rt/src/chschd.c **** 
 555:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 556:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 727               		.loc 1 556 0
 728 0072 BD01      		movw r22,r26
 729 0074 CA01      		movw r24,r20
 730 0076 0E94 0000 		call _port_switch
 731               	.LVL56:
 732               	/* epilogue start */
 557:../../os/rt/src/chschd.c **** }
 733               		.loc 1 557 0
 734 007a DF91      		pop r29
 735 007c CF91      		pop r28
 736 007e 0895      		ret
 737               		.cfi_endproc
 738               	.LFE206:
 740               		.set	__sch_reschedule_ahead,chSchDoPreemption
 741               		.section	.text.chSchRescheduleS,"ax",@progbits
 742               	.global	chSchRescheduleS
 744               	chSchRescheduleS:
 745               	.LFB204:
 458:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 746               		.loc 1 458 0
 747               		.cfi_startproc
 748               	/* prologue: function */
 749               	/* frame size = 0 */
 750               	/* stack size = 0 */
 751               	.L__stack_usage = 0
 752               	.LVL57:
 466:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 753               		.loc 1 466 0
 754 0000 A091 0000 		lds r26,ch0
 755 0004 B091 0000 		lds r27,ch0+1
 756 0008 E091 0000 		lds r30,ch0+5
 757 000c F091 0000 		lds r31,ch0+5+1
 758 0010 1496      		adiw r26,4
 759 0012 9C91      		ld r25,X
 760 0014 8481      		ldd r24,Z+4
 761 0016 8917      		cp r24,r25
 762 0018 00F0      		brlo .L48
 763               	/* epilogue start */
 469:../../os/rt/src/chschd.c **** 
 764               		.loc 1 469 0
 765 001a 0895      		ret
 766               	.L48:
 467:../../os/rt/src/chschd.c ****   }
 767               		.loc 1 467 0
 768 001c 0C94 0000 		jmp __sch_reschedule_ahead
 769               	.LVL58:
 770               		.cfi_endproc
 771               	.LFE204:
 773               		.section	.text.chSchPreemption,"ax",@progbits
 774               	.global	chSchPreemption
 776               	chSchPreemption:
 777               	.LFB213:
 778               		.cfi_startproc
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 783 0000 0C94 0000 		jmp chSchRescheduleS
 784               		.cfi_endproc
 785               	.LFE213:
 787               		.section	.text.chSchDoYieldS,"ax",@progbits
 788               	.global	chSchDoYieldS
 790               	chSchDoYieldS:
 791               	.LFB208:
 558:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_DO_PREEMPTION_HOOKED) */
 559:../../os/rt/src/chschd.c **** 
 560:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_PREEMPTION_HOOKED)
 561:../../os/rt/src/chschd.c **** /**
 562:../../os/rt/src/chschd.c ****  * @brief   All-in-one preemption code.
 563:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 564:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 565:../../os/rt/src/chschd.c ****  *
 566:../../os/rt/src/chschd.c ****  * @special
 567:../../os/rt/src/chschd.c ****  */
 568:../../os/rt/src/chschd.c **** void chSchPreemption(void) {
 569:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 570:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 571:../../os/rt/src/chschd.c ****   tprio_t p1 = firstprio(&oip->rlist.pqueue);
 572:../../os/rt/src/chschd.c ****   tprio_t p2 = tp->hdr.pqueue.prio;
 573:../../os/rt/src/chschd.c **** 
 574:../../os/rt/src/chschd.c ****   /* Note, we are favoring the path where preemption is necessary
 575:../../os/rt/src/chschd.c ****      because higher priority threads are ready.*/
 576:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 577:../../os/rt/src/chschd.c ****   if (tp->ticks > (tslices_t)0) {
 578:../../os/rt/src/chschd.c ****     if (likely(p1 > p2)) {
 579:../../os/rt/src/chschd.c ****       __sch_reschedule_ahead();
 580:../../os/rt/src/chschd.c ****     }
 581:../../os/rt/src/chschd.c ****   }
 582:../../os/rt/src/chschd.c ****   else {
 583:../../os/rt/src/chschd.c ****     if (likely(p1 >= p2)) {
 584:../../os/rt/src/chschd.c ****       __sch_reschedule_behind();
 585:../../os/rt/src/chschd.c ****     }
 586:../../os/rt/src/chschd.c ****   }
 587:../../os/rt/src/chschd.c **** #else /* CH_CFG_TIME_QUANTUM == 0 */
 588:../../os/rt/src/chschd.c ****   if (likely(p1 > p2)) {
 589:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 590:../../os/rt/src/chschd.c ****   }
 591:../../os/rt/src/chschd.c **** #endif /* CH_CFG_TIME_QUANTUM == 0 */
 592:../../os/rt/src/chschd.c **** }
 593:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_PREEMPTION_HOOKED) */
 594:../../os/rt/src/chschd.c **** 
 595:../../os/rt/src/chschd.c **** /**
 596:../../os/rt/src/chschd.c ****  * @brief   Yields the time slot.
 597:../../os/rt/src/chschd.c ****  * @details Yields the CPU control to the next thread in the ready list with
 598:../../os/rt/src/chschd.c ****  *          equal or higher priority, if any.
 599:../../os/rt/src/chschd.c ****  *
 600:../../os/rt/src/chschd.c ****  * @sclass
 601:../../os/rt/src/chschd.c ****  */
 602:../../os/rt/src/chschd.c **** void chSchDoYieldS(void) {
 792               		.loc 1 602 0
 793               		.cfi_startproc
 794               		.loc 1 602 0
 795 0000 CF93      		push r28
 796               	.LCFI19:
 797               		.cfi_def_cfa_offset 3
 798               		.cfi_offset 28, -2
 799 0002 DF93      		push r29
 800               	.LCFI20:
 801               		.cfi_def_cfa_offset 4
 802               		.cfi_offset 29, -3
 803               	/* prologue: function */
 804               	/* frame size = 0 */
 805               	/* stack size = 2 */
 806               	.L__stack_usage = 2
 807               	.LVL59:
 603:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 604:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 808               		.loc 1 604 0
 809 0004 A091 0000 		lds r26,ch0+5
 810 0008 B091 0000 		lds r27,ch0+5+1
 811               	.LVL60:
 605:../../os/rt/src/chschd.c **** 
 606:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 607:../../os/rt/src/chschd.c **** 
 608:../../os/rt/src/chschd.c ****   /* If this function has been called then it is likely there are threads
 609:../../os/rt/src/chschd.c ****      at same priority level.*/
 610:../../os/rt/src/chschd.c ****   if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
 812               		.loc 1 610 0
 813 000c 2091 0000 		lds r18,ch0
 814 0010 3091 0000 		lds r19,ch0+1
 815 0014 E901      		movw r28,r18
 816 0016 9C81      		ldd r25,Y+4
 817 0018 1496      		adiw r26,4
 818 001a 8C91      		ld r24,X
 819 001c 1497      		sbiw r26,4
 820 001e 9817      		cp r25,r24
 821 0020 00F4      		brsh .L54
 822               	/* epilogue start */
 611:../../os/rt/src/chschd.c ****     __sch_reschedule_behind();
 612:../../os/rt/src/chschd.c ****   }
 613:../../os/rt/src/chschd.c **** }
 823               		.loc 1 613 0
 824 0022 DF91      		pop r29
 825 0024 CF91      		pop r28
 826 0026 0895      		ret
 827               	.L54:
 828               	.LVL61:
 829               	.LBB102:
 830               	.LBB103:
 831               	.LBB104:
 832               	.LBB105:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 833               		.loc 2 355 0
 834 0028 E881      		ld r30,Y
 835 002a F981      		ldd r31,Y+1
 836 002c F093 0000 		sts ch0+1,r31
 837 0030 E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 838               		.loc 2 356 0
 839 0034 80E0      		ldi r24,lo8(ch0)
 840 0036 90E0      		ldi r25,hi8(ch0)
 841 0038 9383      		std Z+3,r25
 842 003a 8283      		std Z+2,r24
 843               	.LVL62:
 844               	.LBE105:
 845               	.LBE104:
 134:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 846               		.loc 1 134 0
 847 003c 81E0      		ldi r24,lo8(1)
 848 003e 8F87      		std Y+15,r24
 135:../../os/rt/src/chschd.c **** 
 849               		.loc 1 135 0
 850 0040 3093 0000 		sts ch0+5+1,r19
 851 0044 2093 0000 		sts ch0+5,r18
 852               	.LVL63:
 853               	.LBB106:
 854               	.LBB107:
  77:../../os/rt/src/chschd.c **** 
 855               		.loc 1 77 0
 856 0048 1F96      		adiw r26,15
 857 004a 1C92      		st X,__zero_reg__
 858 004c 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 859               		.loc 1 80 0
 860 004e 1B96      		adiw r26,11
 861 0050 ED91      		ld r30,X+
 862 0052 FC91      		ld r31,X
 863 0054 1C97      		sbiw r26,11+1
 864               	.LVL64:
 865               	.LBB108:
 866               	.LBB109:
 379:../../os/rt/include/chlists.h **** 
 867               		.loc 2 379 0
 868 0056 1496      		adiw r26,4
 869 0058 8C91      		ld r24,X
 870 005a 1497      		sbiw r26,4
 871               	.L52:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 872               		.loc 2 378 0
 873 005c 0190      		ld __tmp_reg__,Z+
 874 005e F081      		ld r31,Z
 875 0060 E02D      		mov r30,__tmp_reg__
 876               	.LVL65:
 379:../../os/rt/include/chlists.h **** 
 877               		.loc 2 379 0
 878 0062 9481      		ldd r25,Z+4
 879 0064 9817      		cp r25,r24
 880 0066 00F4      		brsh .L52
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 881               		.loc 2 382 0
 882 0068 1196      		adiw r26,1
 883 006a FC93      		st X,r31
 884 006c EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 885               		.loc 2 383 0
 886 006e 8281      		ldd r24,Z+2
 887 0070 9381      		ldd r25,Z+3
 888 0072 1396      		adiw r26,2+1
 889 0074 9C93      		st X,r25
 890 0076 8E93      		st -X,r24
 891 0078 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 892               		.loc 2 384 0
 893 007a EC01      		movw r28,r24
 894 007c B983      		std Y+1,r27
 895 007e A883      		st Y,r26
 385:../../os/rt/include/chlists.h **** 
 896               		.loc 2 385 0
 897 0080 B383      		std Z+3,r27
 898 0082 A283      		std Z+2,r26
 899               	.LVL66:
 900               	.LBE109:
 901               	.LBE108:
 902               	.LBE107:
 903               	.LBE106:
 151:../../os/rt/src/chschd.c **** }
 904               		.loc 1 151 0
 905 0084 BD01      		movw r22,r26
 906 0086 C901      		movw r24,r18
 907 0088 0E94 0000 		call _port_switch
 908               	.LVL67:
 909               	/* epilogue start */
 910               	.LBE103:
 911               	.LBE102:
 912               		.loc 1 613 0
 913 008c DF91      		pop r29
 914 008e CF91      		pop r28
 915 0090 0895      		ret
 916               		.cfi_endproc
 917               	.LFE208:
 919               		.section	.text.chSchSelectFirst,"ax",@progbits
 920               	.global	chSchSelectFirst
 922               	chSchSelectFirst:
 923               	.LFB209:
 614:../../os/rt/src/chschd.c **** 
 615:../../os/rt/src/chschd.c **** /**
 616:../../os/rt/src/chschd.c ****  * @brief   Makes runnable the fist thread in the ready list, does not
 617:../../os/rt/src/chschd.c ****  *          reschedule internally.
 618:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list ahead of all
 619:../../os/rt/src/chschd.c ****  *          threads having the same priority.
 620:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 621:../../os/rt/src/chschd.c ****  *          itself.
 622:../../os/rt/src/chschd.c ****  *
 623:../../os/rt/src/chschd.c ****  * @return              The pointer to the thread being switched in.
 624:../../os/rt/src/chschd.c ****  *
 625:../../os/rt/src/chschd.c ****  * @special
 626:../../os/rt/src/chschd.c ****  */
 627:../../os/rt/src/chschd.c **** thread_t *chSchSelectFirst(void) {
 924               		.loc 1 627 0
 925               		.cfi_startproc
 926 0000 CF93      		push r28
 927               	.LCFI21:
 928               		.cfi_def_cfa_offset 3
 929               		.cfi_offset 28, -2
 930 0002 DF93      		push r29
 931               	.LCFI22:
 932               		.cfi_def_cfa_offset 4
 933               		.cfi_offset 29, -3
 934               	/* prologue: function */
 935               	/* frame size = 0 */
 936               	/* stack size = 2 */
 937               	.L__stack_usage = 2
 938               	.LVL68:
 628:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 629:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 939               		.loc 1 629 0
 940 0004 A091 0000 		lds r26,ch0+5
 941 0008 B091 0000 		lds r27,ch0+5+1
 942               	.LVL69:
 943               	.LBB110:
 944               	.LBB111:
 353:../../os/rt/include/chlists.h **** 
 945               		.loc 2 353 0
 946 000c 4091 0000 		lds r20,ch0
 947 0010 5091 0000 		lds r21,ch0+1
 948               	.LVL70:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 949               		.loc 2 355 0
 950 0014 EA01      		movw r28,r20
 951 0016 E881      		ld r30,Y
 952 0018 F981      		ldd r31,Y+1
 953 001a F093 0000 		sts ch0+1,r31
 954 001e E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 955               		.loc 2 356 0
 956 0022 80E0      		ldi r24,lo8(ch0)
 957 0024 90E0      		ldi r25,hi8(ch0)
 958 0026 9383      		std Z+3,r25
 959 0028 8283      		std Z+2,r24
 960               	.LVL71:
 961               	.LBE111:
 962               	.LBE110:
 630:../../os/rt/src/chschd.c ****   thread_t *ntp;
 631:../../os/rt/src/chschd.c **** 
 632:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 633:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 634:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 963               		.loc 1 634 0
 964 002a 81E0      		ldi r24,lo8(1)
 965 002c 8F87      		std Y+15,r24
 635:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 966               		.loc 1 635 0
 967 002e 5093 0000 		sts ch0+5+1,r21
 968 0032 4093 0000 		sts ch0+5,r20
 969               	.LVL72:
 970               	.LBB112:
 971               	.LBB113:
 110:../../os/rt/src/chschd.c **** 
 972               		.loc 1 110 0
 973 0036 1F96      		adiw r26,15
 974 0038 1C92      		st X,__zero_reg__
 975 003a 1F97      		sbiw r26,15
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 976               		.loc 1 113 0
 977 003c 1B96      		adiw r26,11
 978 003e ED91      		ld r30,X+
 979 0040 FC91      		ld r31,X
 980 0042 1C97      		sbiw r26,11+1
 981               	.LVL73:
 982               	.LBB114:
 983               	.LBB115:
 408:../../os/rt/include/chlists.h **** 
 984               		.loc 2 408 0
 985 0044 1496      		adiw r26,4
 986 0046 2C91      		ld r18,X
 987 0048 1497      		sbiw r26,4
 988               	.L56:
 407:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 989               		.loc 2 407 0
 990 004a 0190      		ld __tmp_reg__,Z+
 991 004c F081      		ld r31,Z
 992 004e E02D      		mov r30,__tmp_reg__
 993               	.LVL74:
 408:../../os/rt/include/chlists.h **** 
 994               		.loc 2 408 0
 995 0050 9481      		ldd r25,Z+4
 996 0052 2917      		cp r18,r25
 997 0054 00F0      		brlo .L56
 411:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 998               		.loc 2 411 0
 999 0056 1196      		adiw r26,1
 1000 0058 FC93      		st X,r31
 1001 005a EE93      		st -X,r30
 412:../../os/rt/include/chlists.h ****   p->prev->next = p;
 1002               		.loc 2 412 0
 1003 005c 8281      		ldd r24,Z+2
 1004 005e 9381      		ldd r25,Z+3
 1005 0060 1396      		adiw r26,2+1
 1006 0062 9C93      		st X,r25
 1007 0064 8E93      		st -X,r24
 1008 0066 1297      		sbiw r26,2
 413:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 1009               		.loc 2 413 0
 1010 0068 EC01      		movw r28,r24
 1011 006a B983      		std Y+1,r27
 1012 006c A883      		st Y,r26
 1013               		.loc 2 414 0
 1014 006e B383      		std Z+3,r27
 1015 0070 A283      		std Z+2,r26
 1016               	.LVL75:
 1017               	.LBE115:
 1018               	.LBE114:
 1019               	.LBE113:
 1020               	.LBE112:
 636:../../os/rt/src/chschd.c **** 
 637:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 638:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 639:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 640:../../os/rt/src/chschd.c ****   }
 641:../../os/rt/src/chschd.c **** 
 642:../../os/rt/src/chschd.c ****   /* Placing in ready list ahead of peers.*/
 643:../../os/rt/src/chschd.c ****   (void) __sch_ready_ahead(otp);
 644:../../os/rt/src/chschd.c **** 
 645:../../os/rt/src/chschd.c ****   return ntp;
 646:../../os/rt/src/chschd.c **** }
 1021               		.loc 1 646 0
 1022 0072 CA01      		movw r24,r20
 1023               	/* epilogue start */
 1024 0074 DF91      		pop r29
 1025 0076 CF91      		pop r28
 1026 0078 0895      		ret
 1027               		.cfi_endproc
 1028               	.LFE209:
 1030               		.text
 1031               	.Letext0:
 1032               		.file 4 "/usr/lib/avr/include/stdint.h"
 1033               		.file 5 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 1034               		.file 6 "../../os/rt/include/chearly.h"
 1035               		.file 7 "../../os/rt/include/chobjects.h"
 1036               		.file 8 "../../os/rt/include/chrfcu.h"
 1037               		.file 9 "../../os/rt/include/chdebug.h"
 1038               		.file 10 "../../os/rt/include/chtime.h"
 1039               		.file 11 "../../os/common/ports/AVR/chcore.h"
 1040               		.file 12 "../../os/rt/include/chmtx.h"
 1041               		.file 13 "../../os/rt/include/chsys.h"
 1042               		.file 14 "../../os/rt/include/chregistry.h"
 1043               		.file 15 "../../os/oslib/include/chmemcore.h"
 1044               		.file 16 "../../os/rt/include/chvt.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 chschd.c
     /tmp/ccR4eCc2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccR4eCc2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccR4eCc2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccR4eCc2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccR4eCc2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccR4eCc2.s:12     .text.__sch_wakeup:0000000000000000 __sch_wakeup
     /tmp/ccR4eCc2.s:169    .text.chSchReadyI:0000000000000000 chSchReadyI
     /tmp/ccR4eCc2.s:251    .text.chSchGoSleepS:0000000000000000 chSchGoSleepS
     /tmp/ccR4eCc2.s:320    .text.chSchGoSleepTimeoutS:0000000000000000 chSchGoSleepTimeoutS
     /tmp/ccR4eCc2.s:441    .text.chSchWakeupS:0000000000000000 chSchWakeupS
     /tmp/ccR4eCc2.s:595    .text.chSchIsPreemptionRequired:0000000000000000 chSchIsPreemptionRequired
     /tmp/ccR4eCc2.s:628    .text.chSchDoPreemption:0000000000000000 chSchDoPreemption
     /tmp/ccR4eCc2.s:628    .text.chSchDoPreemption:0000000000000000 __sch_reschedule_ahead
     /tmp/ccR4eCc2.s:744    .text.chSchRescheduleS:0000000000000000 chSchRescheduleS
     /tmp/ccR4eCc2.s:776    .text.chSchPreemption:0000000000000000 chSchPreemption
     /tmp/ccR4eCc2.s:790    .text.chSchDoYieldS:0000000000000000 chSchDoYieldS
     /tmp/ccR4eCc2.s:922    .text.chSchSelectFirst:0000000000000000 chSchSelectFirst

UNDEFINED SYMBOLS
ch0
_port_switch
chVTDoSetI
chVTDoResetI
