   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
<<<<<<< HEAD
  10               		.section	.text.startup.main,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB243:
=======
  10               		.section	.text.vt_cb,"ax",@progbits
  11               	.global	vt_cb
  13               	vt_cb:
  14               	.LFB250:
>>>>>>> 3b427cd72e7bbfdaa7473cbc3f0814c31c805343
  15               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****     ChibiOS - Copyright (C) 2006..2018 Giovanni Di Sirio
   3:main.c        **** 
   4:main.c        ****     Licensed under the Apache License, Version 2.0 (the "License");
   5:main.c        ****     you may not use this file except in compliance with the License.
   6:main.c        ****     You may obtain a copy of the License at
   7:main.c        **** 
   8:main.c        ****         http://www.apache.org/licenses/LICENSE-2.0
   9:main.c        **** 
  10:main.c        ****     Unless required by applicable law or agreed to in writing, software
  11:main.c        ****     distributed under the License is distributed on an "AS IS" BASIS,
  12:main.c        ****     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13:main.c        ****     See the License for the specific language governing permissions and
  14:main.c        ****     limitations under the License.
  15:main.c        **** */
  16:main.c        **** 
  17:main.c        **** #include "ch.h"
  18:main.c        **** #include "hal.h"
  19:main.c        **** 
<<<<<<< HEAD
  20:main.c        **** #define PEDESTRE_LINE_GREEN PAL_LINE(IOPORT2, 3)
  21:main.c        **** #define PEDESTRE_LINE_RED PAL_LINE(IOPORT2, 2)
  22:main.c        **** 
  23:main.c        **** /*
  24:main.c        **** void vt_cb(void *arg)
  25:main.c        **** {
  26:main.c        ****   chSysLockFromISR();
  27:main.c        ****   palTogglePad(IOPORT2, PORTB_LED1);
  28:main.c        ****   chVTSetI((virtual_timer_t *)arg, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, arg);
  29:main.c        ****   chSysUnlockFromISR();
  30:main.c        **** }
  31:main.c        **** */
  32:main.c        **** /*
  33:main.c        ****  * LED blinker thread, times are in milliseconds.
  34:main.c        ****  */
  35:main.c        **** /*
  36:main.c        **** static THD_WORKING_AREA(waThread1, 32);
  37:main.c        **** static THD_FUNCTION(Thread1, arg)
  38:main.c        **** {
  39:main.c        ****   virtual_timer_t vt;
  40:main.c        **** 
  41:main.c        ****   chVTObjectInit(&vt);
  42:main.c        ****   chVTSet(&vt, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, (void *)&vt);
  43:main.c        **** 
  44:main.c        ****   while (1)
  45:main.c        ****   {
  46:main.c        ****   }
  47:main.c        **** }
  48:main.c        **** */
  49:main.c        **** /*
  50:main.c        ****  * Application entry point.
  51:main.c        ****  */
  52:main.c        **** int main(void)
  53:main.c        **** {
  16               		.loc 1 53 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  54:main.c        ****   /*
  55:main.c        ****    * System initializations.
  56:main.c        ****    * - HAL initialization, this also initializes the configured device drivers
  57:main.c        ****    *   and performs the board-specific initializations.
  58:main.c        ****    * - Kernel initialization, the main() function becomes a thread and the
  59:main.c        ****    *   RTOS is active.
  60:main.c        ****    */
  61:main.c        ****   halInit();
  22               		.loc 1 61 0
  23 0000 0E94 0000 		call halInit
  24               	.LVL0:
  62:main.c        ****   chSysInit();
  25               		.loc 1 62 0
  26 0004 0E94 0000 		call chSysInit
  27               	.LVL1:
  63:main.c        **** 
  64:main.c        ****   /* Configuração dos pinos */
  65:main.c        ****   // Semáforo primário: Vermelho, Verde
  66:main.c        ****   palSetPadMode(IOPORT4, 7, PAL_MODE_OUTPUT_PUSHPULL);
  28               		.loc 1 66 0
  29 0008 46E0      		ldi r20,lo8(6)
  30 000a 60E8      		ldi r22,lo8(-128)
  31 000c 89E2      		ldi r24,lo8(41)
  32 000e 90E0      		ldi r25,0
  33 0010 0E94 0000 		call _pal_lld_setgroupmode
  34               	.LVL2:
  67:main.c        ****   palClearPad(IOPORT4, 7);
  35               		.loc 1 67 0
  36 0014 5F98      		cbi 0xb,7
  68:main.c        ****   palSetPadMode(IOPORT4, 6, PAL_MODE_OUTPUT_PUSHPULL);
  37               		.loc 1 68 0
  38 0016 46E0      		ldi r20,lo8(6)
  39 0018 60E4      		ldi r22,lo8(64)
  40 001a 89E2      		ldi r24,lo8(41)
  41 001c 90E0      		ldi r25,0
  42 001e 0E94 0000 		call _pal_lld_setgroupmode
  43               	.LVL3:
  69:main.c        ****   palClearPad(IOPORT4, 6);
  44               		.loc 1 69 0
  45 0022 5E98      		cbi 0xb,6
  70:main.c        **** 
  71:main.c        ****   // Semáforo secundário: Vermelho, Verde
  72:main.c        ****   palSetPadMode(IOPORT2, 1, PAL_MODE_OUTPUT_PUSHPULL);
  46               		.loc 1 72 0
  47 0024 46E0      		ldi r20,lo8(6)
  48 0026 62E0      		ldi r22,lo8(2)
  49 0028 83E2      		ldi r24,lo8(35)
  50 002a 90E0      		ldi r25,0
  51 002c 0E94 0000 		call _pal_lld_setgroupmode
  52               	.LVL4:
  73:main.c        ****   palClearPad(IOPORT2, 1);
  53               		.loc 1 73 0
  54 0030 2998      		cbi 0x5,1
  74:main.c        ****   palSetPadMode(IOPORT2, 0, PAL_MODE_OUTPUT_PUSHPULL);
  55               		.loc 1 74 0
  56 0032 46E0      		ldi r20,lo8(6)
  57 0034 61E0      		ldi r22,lo8(1)
  58 0036 83E2      		ldi r24,lo8(35)
  59 0038 90E0      		ldi r25,0
  60 003a 0E94 0000 		call _pal_lld_setgroupmode
  61               	.LVL5:
  75:main.c        ****   palClearPad(IOPORT2, 0);
  62               		.loc 1 75 0
  63 003e 2898      		cbi 0x5,0
  76:main.c        **** 
  77:main.c        ****   // Pedestre: Vermelho, Verde
  78:main.c        ****   palSetLineMode(PEDESTRE_LINE_GREEN, PAL_MODE_OUTPUT_PUSHPULL);
  64               		.loc 1 78 0
  65 0040 63E0      		ldi r22,lo8(3)
  66 0042 83E2      		ldi r24,lo8(35)
  67 0044 90E0      		ldi r25,0
  68 0046 0E94 0000 		call _pal_lld_setlineid
  69               	.LVL6:
  70 004a 0E94 0000 		call _pal_lld_getpadfromline
  71               	.LVL7:
  72 004e 182F      		mov r17,r24
  73 0050 63E0      		ldi r22,lo8(3)
  74 0052 83E2      		ldi r24,lo8(35)
  75 0054 90E0      		ldi r25,0
  76 0056 0E94 0000 		call _pal_lld_setlineid
  77               	.LVL8:
  78 005a 0E94 0000 		call _pal_lld_getportfromline
  79               	.LVL9:
  80 005e C1E0      		ldi r28,lo8(1)
  81 0060 D0E0      		ldi r29,0
  82 0062 BE01      		movw r22,r28
  83 0064 00C0      		rjmp 2f
  84               		1:
  85 0066 660F      		lsl r22
  86               		2:
  87 0068 1A95      		dec r17
  88 006a 02F4      		brpl 1b
  89 006c 46E0      		ldi r20,lo8(6)
  90 006e 0E94 0000 		call _pal_lld_setgroupmode
  91               	.LVL10:
  79:main.c        ****   palSetLineMode(PEDESTRE_LINE_RED, PAL_MODE_OUTPUT_PUSHPULL);
  92               		.loc 1 79 0
  93 0072 62E0      		ldi r22,lo8(2)
  94 0074 83E2      		ldi r24,lo8(35)
  95 0076 90E0      		ldi r25,0
  96 0078 0E94 0000 		call _pal_lld_setlineid
  97               	.LVL11:
  98 007c 0E94 0000 		call _pal_lld_getpadfromline
  99               	.LVL12:
 100 0080 182F      		mov r17,r24
 101 0082 62E0      		ldi r22,lo8(2)
 102 0084 83E2      		ldi r24,lo8(35)
 103 0086 90E0      		ldi r25,0
 104 0088 0E94 0000 		call _pal_lld_setlineid
 105               	.LVL13:
 106 008c 0E94 0000 		call _pal_lld_getportfromline
 107               	.LVL14:
 108 0090 BE01      		movw r22,r28
 109 0092 00C0      		rjmp 2f
 110               		1:
 111 0094 660F      		lsl r22
 112               		2:
 113 0096 1A95      		dec r17
 114 0098 02F4      		brpl 1b
 115 009a 46E0      		ldi r20,lo8(6)
 116 009c 0E94 0000 		call _pal_lld_setgroupmode
 117               	.LVL15:
  80:main.c        **** 
  81:main.c        ****   // LED Interno:
  82:main.c        ****   palSetPadMode(IOPORT2, PORTB_LED1, PAL_MODE_OUTPUT_PUSHPULL);
 118               		.loc 1 82 0
 119 00a0 46E0      		ldi r20,lo8(6)
 120 00a2 60E2      		ldi r22,lo8(32)
 121 00a4 83E2      		ldi r24,lo8(35)
 122 00a6 90E0      		ldi r25,0
 123 00a8 0E94 0000 		call _pal_lld_setgroupmode
 124               	.LVL16:
  83:main.c        ****   palClearPad(IOPORT2, PORTB_LED1);
 125               		.loc 1 83 0
 126 00ac 2D98      		cbi 0x5,5
  84:main.c        **** 
  85:main.c        ****   /* Configuração dos botões */
  86:main.c        **** 
  87:main.c        ****   /*
  88:main.c        ****    * Starts the LED blinker thread.
  89:main.c        ****    */
  90:main.c        ****   // chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO + 1, Thread1, NULL);
  91:main.c        **** 
  92:main.c        ****   // palSetLine(PEDESTRE_LINE_GREEN);
  93:main.c        ****   palSetLine(PEDESTRE_LINE_RED);
 127               		.loc 1 93 0
 128 00ae 62E0      		ldi r22,lo8(2)
 129 00b0 83E2      		ldi r24,lo8(35)
 130 00b2 90E0      		ldi r25,0
 131 00b4 0E94 0000 		call _pal_lld_setlineid
 132               	.LVL17:
 133 00b8 0E94 0000 		call _pal_lld_getpadfromline
 134               	.LVL18:
 135 00bc 182F      		mov r17,r24
 136 00be 62E0      		ldi r22,lo8(2)
 137 00c0 83E2      		ldi r24,lo8(35)
 138 00c2 90E0      		ldi r25,0
 139 00c4 0E94 0000 		call _pal_lld_setlineid
 140               	.LVL19:
 141 00c8 0E94 0000 		call _pal_lld_getportfromline
 142               	.LVL20:
 143 00cc FC01      		movw r30,r24
 144 00ce 9281      		ldd r25,Z+2
 145 00d0 00C0      		rjmp 2f
 146               		1:
 147 00d2 CC0F      		lsl r28
 148               		2:
 149 00d4 1A95      		dec r17
 150 00d6 02F4      		brpl 1b
 151 00d8 C92B      		or r28,r25
 152 00da C283      		std Z+2,r28
 153               	.L2:
 154 00dc 00C0      		rjmp .L2
 155               		.cfi_endproc
 156               	.LFE243:
 158               		.text
 159               	.Letext0:
 160               		.file 2 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 161               		.file 3 "/usr/lib/avr/include/stdint.h"
 162               		.file 4 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/common/ports/AVR/compilers/
 163               		.file 5 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chearly.h"
 164               		.file 6 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chobjects.h"
 165               		.file 7 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chrfcu.h"
 166               		.file 8 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chdebug.h"
 167               		.file 9 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chtime.h"
 168               		.file 10 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chlists.h"
 169               		.file 11 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/common/ports/AVR/chcore.h"
 170               		.file 12 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chsem.h"
 171               		.file 13 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chmtx.h"
 172               		.file 14 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chsys.h"
 173               		.file 15 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chregistry.h"
 174               		.file 16 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/rt/include/chevents.h"
 175               		.file 17 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/oslib/include/chmemcore.h"
 176               		.file 18 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/include/hal_queues.h"
 177               		.file 19 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/include/hal_pal.h"
 178               		.file 20 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/ports/AVR/MEGA/LLD/GPI
 179               		.file 21 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/include/hal_serial.h"
 180               		.file 22 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/ports/AVR/MEGA/LLD/USA
 181               		.file 23 "/home/givaldo/Documents/ChibiStudio/chibios_stable-21.11.x/os/hal/include/hal.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccpORUXt.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccpORUXt.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccpORUXt.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccpORUXt.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccpORUXt.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccpORUXt.s:13     .text.startup.main:0000000000000000 main
=======
  20:main.c        **** #define LED_PERIODO 10000
  21:main.c        **** #define BUFFER_SIZE 8
  22:main.c        **** 
  23:main.c        **** typedef struct {
  24:main.c        ****     uint8_t events[BUFFER_SIZE];
  25:main.c        ****     uint8_t head;
  26:main.c        ****     uint8_t tail;
  27:main.c        ****     uint8_t size;
  28:main.c        **** } EventBuffer;
  29:main.c        **** 
  30:main.c        **** EventBuffer ev_buffer;
  31:main.c        **** 
  32:main.c        **** void bufferInit(EventBuffer *cb);
  33:main.c        **** bool isBufferEmpty(EventBuffer *buffer);
  34:main.c        **** bool isBufferFull(EventBuffer *buffer);
  35:main.c        **** void bufferPush(EventBuffer *cb, uint8_t event);
  36:main.c        **** uint8_t bufferPop(EventBuffer *cb);
  37:main.c        **** void vt_cb(void *arg);
  38:main.c        **** 
  39:main.c        **** enum {
  40:main.c        ****   SECUNDARIO=1, PEDESTRE, AMB_PRIMARIO, AMB_SECUNDARIO
  41:main.c        **** };
  42:main.c        **** 
  43:main.c        **** /*
  44:main.c        ****  * LED blinker thread, times are in milliseconds.
  45:main.c        ****  */
  46:main.c        **** static THD_WORKING_AREA(waThread1, 32);
  47:main.c        **** static THD_FUNCTION(Thread1, arg)
  48:main.c        **** {
  49:main.c        ****   virtual_timer_t vt;
  50:main.c        **** 
  51:main.c        ****   chVTObjectInit(&vt);
  52:main.c        ****   chVTSet(&vt, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, (void *)&vt);
  53:main.c        **** 
  54:main.c        ****   while (1)
  55:main.c        ****   {
  56:main.c        ****   }
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** /*
  60:main.c        ****  * Application entry point.
  61:main.c        ****  */
  62:main.c        **** int main(void)
  63:main.c        **** {
  64:main.c        ****   bufferInit(&ev_buffer);
  65:main.c        ****   /*
  66:main.c        ****    * System initializations.
  67:main.c        ****    * - HAL initialization, this also initializes the configured device drivers
  68:main.c        ****    *   and performs the board-specific initializations.
  69:main.c        ****    * - Kernel initialization, the main() function becomes a thread and the
  70:main.c        ****    *   RTOS is active.
  71:main.c        ****    */
  72:main.c        ****   halInit();
  73:main.c        ****   chSysInit();
  74:main.c        **** 
  75:main.c        ****   /* Configuração dos pinos */
  76:main.c        ****   // Semáforo primário: Vermelho, Verde
  77:main.c        ****   palSetPadMode(IOPORT4, 7, PAL_MODE_OUTPUT_PUSHPULL);
  78:main.c        ****   palClearPad(IOPORT4, 7);
  79:main.c        ****   palSetPadMode(IOPORT4, 6, PAL_MODE_OUTPUT_PUSHPULL);
  80:main.c        ****   palClearPad(IOPORT4, 6);
  81:main.c        **** 
  82:main.c        ****   // Semáforo secundário: Vermelho, Verde
  83:main.c        ****   palSetPadMode(IOPORT2, 1, PAL_MODE_OUTPUT_PUSHPULL);
  84:main.c        ****   palClearPad(IOPORT2, 1);
  85:main.c        ****   palSetPadMode(IOPORT2, 0, PAL_MODE_OUTPUT_PUSHPULL);
  86:main.c        ****   palClearPad(IOPORT2, 0);
  87:main.c        **** 
  88:main.c        ****   // Pedestre: Vermelho, Verde
  89:main.c        ****   palSetPadMode(IOPORT2, 3, PAL_MODE_OUTPUT_PUSHPULL);
  90:main.c        ****   palClearPad(IOPORT2, 3);
  91:main.c        ****   palSetPadMode(IOPORT2, 2, PAL_MODE_OUTPUT_PUSHPULL);
  92:main.c        ****   palClearPad(IOPORT2, 2);
  93:main.c        **** 
  94:main.c        ****   // LED Interno:
  95:main.c        ****   palSetPadMode(IOPORT2, PORTB_LED1, PAL_MODE_OUTPUT_PUSHPULL);
  96:main.c        ****   palClearPad(IOPORT2, PORTB_LED1);
  97:main.c        **** 
  98:main.c        ****   /* Configuração dos botões */
  99:main.c        **** 
 100:main.c        ****   /*
 101:main.c        ****    * Starts the LED blinker thread.
 102:main.c        ****    */
 103:main.c        ****   chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO + 1, Thread1, NULL);
 104:main.c        **** 
 105:main.c        ****   while (1)
 106:main.c        ****   {
 107:main.c        ****   }
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** void bufferInit(EventBuffer *buffer) {
 111:main.c        ****     buffer->head = 0;
 112:main.c        ****     buffer->tail = 0;
 113:main.c        ****     buffer->size = 0;
 114:main.c        **** }
 115:main.c        **** 
 116:main.c        **** bool isBufferEmpty(EventBuffer *buffer) {
 117:main.c        ****     return buffer->size == 0;
 118:main.c        **** }
 119:main.c        **** 
 120:main.c        **** bool isBufferFull(EventBuffer *buffer) {
 121:main.c        ****     return buffer->size == BUFFER_SIZE;
 122:main.c        **** }
 123:main.c        **** 
 124:main.c        **** void bufferPush(EventBuffer *buffer, uint8_t event) {
 125:main.c        ****     buffer->events[buffer->tail] = event;
 126:main.c        ****     buffer->tail = (buffer->tail + 1) % BUFFER_SIZE;
 127:main.c        ****     buffer->size++;
 128:main.c        **** }
 129:main.c        **** 
 130:main.c        **** uint8_t bufferPop(EventBuffer *buffer) {
 131:main.c        ****     if (isBufferEmpty(buffer)) {
 132:main.c        ****         return false; // Buffer vazio
 133:main.c        ****     }
 134:main.c        **** 
 135:main.c        ****     uint8_t event = buffer->events[buffer->head];
 136:main.c        ****     buffer->head = (buffer->head + 1) % BUFFER_SIZE;
 137:main.c        ****     buffer->size--;
 138:main.c        ****     return event;
 139:main.c        **** }
 140:main.c        **** 
 141:main.c        **** void vt_cb(void *arg) {
  16               		.loc 1 141 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23 0002 1F93      		push r17
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 17, -3
  27 0004 CF93      		push r28
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 28, -4
  31 0006 DF93      		push r29
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 29, -5
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 4 */
  38               	.L__stack_usage = 4
  39 0008 EC01      		movw r28,r24
 142:main.c        ****   chSysLockFromISR();
 143:main.c        ****   palTogglePad(IOPORT2, PORTB_LED1);
  40               		.loc 1 143 0
  41 000a 85B1      		in r24,0x5
  42               	.LVL1:
  43 000c 90E2      		ldi r25,lo8(32)
  44 000e 8927      		eor r24,r25
  45 0010 85B9      		out 0x5,r24
  46               	.LVL2:
  47               	.LBB47:
  48               	.LBB48:
  49               	.LBB49:
  50               	.LBB50:
  51               		.file 2 "../../os/rt/include/chvt.h"
   1:../../os/rt/include/chvt.h **** /*
   2:../../os/rt/include/chvt.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chvt.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chvt.h **** 
   5:../../os/rt/include/chvt.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chvt.h **** 
   7:../../os/rt/include/chvt.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chvt.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chvt.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chvt.h **** 
  11:../../os/rt/include/chvt.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chvt.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chvt.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chvt.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chvt.h **** 
  16:../../os/rt/include/chvt.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chvt.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chvt.h **** */
  19:../../os/rt/include/chvt.h **** 
  20:../../os/rt/include/chvt.h **** /**
  21:../../os/rt/include/chvt.h ****  * @file    rt/include/chvt.h
  22:../../os/rt/include/chvt.h ****  * @brief   Time and Virtual Timers module macros and structures.
  23:../../os/rt/include/chvt.h ****  *
  24:../../os/rt/include/chvt.h ****  * @addtogroup time
  25:../../os/rt/include/chvt.h ****  * @{
  26:../../os/rt/include/chvt.h ****  */
  27:../../os/rt/include/chvt.h **** 
  28:../../os/rt/include/chvt.h **** #ifndef CHVT_H
  29:../../os/rt/include/chvt.h **** #define CHVT_H
  30:../../os/rt/include/chvt.h **** 
  31:../../os/rt/include/chvt.h **** /*===========================================================================*/
  32:../../os/rt/include/chvt.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chvt.h **** /*===========================================================================*/
  34:../../os/rt/include/chvt.h **** 
  35:../../os/rt/include/chvt.h **** /*===========================================================================*/
  36:../../os/rt/include/chvt.h **** /* Module pre-compile time settings.                                         */
  37:../../os/rt/include/chvt.h **** /*===========================================================================*/
  38:../../os/rt/include/chvt.h **** 
  39:../../os/rt/include/chvt.h **** /*===========================================================================*/
  40:../../os/rt/include/chvt.h **** /* Derived constants and error checks.                                       */
  41:../../os/rt/include/chvt.h **** /*===========================================================================*/
  42:../../os/rt/include/chvt.h **** 
  43:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA < 0) || (CH_CFG_ST_TIMEDELTA == 1)
  44:../../os/rt/include/chvt.h **** #error "invalid CH_CFG_ST_TIMEDELTA specified, must "                       \
  45:../../os/rt/include/chvt.h ****        "be zero or greater than one"
  46:../../os/rt/include/chvt.h **** #endif
  47:../../os/rt/include/chvt.h **** 
  48:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA > 0) && (CH_CFG_TIME_QUANTUM > 0)
  49:../../os/rt/include/chvt.h **** #error "CH_CFG_TIME_QUANTUM not supported in tickless mode"
  50:../../os/rt/include/chvt.h **** #endif
  51:../../os/rt/include/chvt.h **** 
  52:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA > 0) && (CH_DBG_THREADS_PROFILING == TRUE)
  53:../../os/rt/include/chvt.h **** #error "CH_DBG_THREADS_PROFILING not supported in tickless mode"
  54:../../os/rt/include/chvt.h **** #endif
  55:../../os/rt/include/chvt.h **** 
  56:../../os/rt/include/chvt.h **** /*===========================================================================*/
  57:../../os/rt/include/chvt.h **** /* Module data structures and types.                                         */
  58:../../os/rt/include/chvt.h **** /*===========================================================================*/
  59:../../os/rt/include/chvt.h **** 
  60:../../os/rt/include/chvt.h **** /*===========================================================================*/
  61:../../os/rt/include/chvt.h **** /* Module macros.                                                            */
  62:../../os/rt/include/chvt.h **** /*===========================================================================*/
  63:../../os/rt/include/chvt.h **** 
  64:../../os/rt/include/chvt.h **** /*===========================================================================*/
  65:../../os/rt/include/chvt.h **** /* External declarations.                                                    */
  66:../../os/rt/include/chvt.h **** /*===========================================================================*/
  67:../../os/rt/include/chvt.h **** 
  68:../../os/rt/include/chvt.h **** /*
  69:../../os/rt/include/chvt.h ****  * Virtual Timers APIs.
  70:../../os/rt/include/chvt.h ****  */
  71:../../os/rt/include/chvt.h **** #ifdef __cplusplus
  72:../../os/rt/include/chvt.h **** extern "C" {
  73:../../os/rt/include/chvt.h **** #endif
  74:../../os/rt/include/chvt.h ****   void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
  75:../../os/rt/include/chvt.h ****                   vtfunc_t vtfunc, void *par);
  76:../../os/rt/include/chvt.h ****   void chVTDoSetContinuousI(virtual_timer_t *vtp, sysinterval_t delay,
  77:../../os/rt/include/chvt.h ****                             vtfunc_t vtfunc, void *par);
  78:../../os/rt/include/chvt.h ****   void chVTDoResetI(virtual_timer_t *vtp);
  79:../../os/rt/include/chvt.h ****   sysinterval_t chVTGetRemainingIntervalI(virtual_timer_t *vtp);
  80:../../os/rt/include/chvt.h ****   void chVTDoTickI(void);
  81:../../os/rt/include/chvt.h **** #if CH_CFG_USE_TIMESTAMP == TRUE
  82:../../os/rt/include/chvt.h ****   systimestamp_t chVTGetTimeStampI(void);
  83:../../os/rt/include/chvt.h ****   void chVTResetTimeStampI(void);
  84:../../os/rt/include/chvt.h **** #endif
  85:../../os/rt/include/chvt.h **** #ifdef __cplusplus
  86:../../os/rt/include/chvt.h **** }
  87:../../os/rt/include/chvt.h **** #endif
  88:../../os/rt/include/chvt.h **** 
  89:../../os/rt/include/chvt.h **** /*===========================================================================*/
  90:../../os/rt/include/chvt.h **** /* Module inline functions.                                                  */
  91:../../os/rt/include/chvt.h **** /*===========================================================================*/
  92:../../os/rt/include/chvt.h **** 
  93:../../os/rt/include/chvt.h **** /**
  94:../../os/rt/include/chvt.h ****  * @brief   Initializes a @p virtual_timer_t object.
  95:../../os/rt/include/chvt.h ****  * @note    Initializing a timer object is not strictly required because
  96:../../os/rt/include/chvt.h ****  *          the function @p chVTSetI() initializes the object too. This
  97:../../os/rt/include/chvt.h ****  *          function is only useful if you need to perform a @p chVTIsArmed()
  98:../../os/rt/include/chvt.h ****  *          check before calling @p chVTSetI().
  99:../../os/rt/include/chvt.h ****  *
 100:../../os/rt/include/chvt.h ****  * @param[out] vtp      the @p virtual_timer_t structure pointer
 101:../../os/rt/include/chvt.h ****  *
 102:../../os/rt/include/chvt.h ****  * @init
 103:../../os/rt/include/chvt.h ****  */
 104:../../os/rt/include/chvt.h **** static inline void chVTObjectInit(virtual_timer_t *vtp) {
 105:../../os/rt/include/chvt.h **** 
 106:../../os/rt/include/chvt.h ****   vtp->dlist.next = NULL;
 107:../../os/rt/include/chvt.h **** }
 108:../../os/rt/include/chvt.h **** 
 109:../../os/rt/include/chvt.h **** /**
 110:../../os/rt/include/chvt.h ****  * @brief   Current system time.
 111:../../os/rt/include/chvt.h ****  * @details Returns the number of system ticks since the @p chSysInit()
 112:../../os/rt/include/chvt.h ****  *          invocation.
 113:../../os/rt/include/chvt.h ****  * @note    The counter can reach its maximum and then restart from zero.
 114:../../os/rt/include/chvt.h ****  * @note    This function can be called from any context but its atomicity
 115:../../os/rt/include/chvt.h ****  *          is not guaranteed on architectures whose word size is less than
 116:../../os/rt/include/chvt.h ****  *          @p systime_t size.
 117:../../os/rt/include/chvt.h ****  *
 118:../../os/rt/include/chvt.h ****  * @return              The system time in ticks.
 119:../../os/rt/include/chvt.h ****  *
 120:../../os/rt/include/chvt.h ****  * @xclass
 121:../../os/rt/include/chvt.h ****  */
 122:../../os/rt/include/chvt.h **** static inline systime_t chVTGetSystemTimeX(void) {
 123:../../os/rt/include/chvt.h **** 
 124:../../os/rt/include/chvt.h **** #if CH_CFG_ST_TIMEDELTA == 0
 125:../../os/rt/include/chvt.h ****   return currcore->vtlist.systime;
 126:../../os/rt/include/chvt.h **** #else /* CH_CFG_ST_TIMEDELTA > 0 */
 127:../../os/rt/include/chvt.h ****   return port_timer_get_time();
 128:../../os/rt/include/chvt.h **** #endif /* CH_CFG_ST_TIMEDELTA > 0 */
 129:../../os/rt/include/chvt.h **** }
 130:../../os/rt/include/chvt.h **** 
 131:../../os/rt/include/chvt.h **** /**
 132:../../os/rt/include/chvt.h ****  * @brief   Current system time.
 133:../../os/rt/include/chvt.h ****  * @details Returns the number of system ticks since the @p chSysInit()
 134:../../os/rt/include/chvt.h ****  *          invocation.
 135:../../os/rt/include/chvt.h ****  * @note    The counter can reach its maximum and then restart from zero.
 136:../../os/rt/include/chvt.h ****  *
 137:../../os/rt/include/chvt.h ****  * @return              The system time in ticks.
 138:../../os/rt/include/chvt.h ****  *
 139:../../os/rt/include/chvt.h ****  * @api
 140:../../os/rt/include/chvt.h ****  */
 141:../../os/rt/include/chvt.h **** static inline systime_t chVTGetSystemTime(void) {
 142:../../os/rt/include/chvt.h ****   systime_t systime;
 143:../../os/rt/include/chvt.h **** 
 144:../../os/rt/include/chvt.h ****   chSysLock();
 145:../../os/rt/include/chvt.h ****   systime = chVTGetSystemTimeX();
 146:../../os/rt/include/chvt.h ****   chSysUnlock();
 147:../../os/rt/include/chvt.h **** 
 148:../../os/rt/include/chvt.h ****   return systime;
 149:../../os/rt/include/chvt.h **** }
 150:../../os/rt/include/chvt.h **** 
 151:../../os/rt/include/chvt.h **** /**
 152:../../os/rt/include/chvt.h ****  * @brief   Returns the elapsed time since the specified start time.
 153:../../os/rt/include/chvt.h ****  *
 154:../../os/rt/include/chvt.h ****  * @param[in] start     start time
 155:../../os/rt/include/chvt.h ****  * @return              The elapsed time.
 156:../../os/rt/include/chvt.h ****  *
 157:../../os/rt/include/chvt.h ****  * @xclass
 158:../../os/rt/include/chvt.h ****  */
 159:../../os/rt/include/chvt.h **** static inline sysinterval_t chVTTimeElapsedSinceX(systime_t start) {
 160:../../os/rt/include/chvt.h **** 
 161:../../os/rt/include/chvt.h ****   return chTimeDiffX(start, chVTGetSystemTimeX());
 162:../../os/rt/include/chvt.h **** }
 163:../../os/rt/include/chvt.h **** 
 164:../../os/rt/include/chvt.h **** /**
 165:../../os/rt/include/chvt.h ****  * @brief   Checks if the current system time is within the specified time
 166:../../os/rt/include/chvt.h ****  *          window.
 167:../../os/rt/include/chvt.h ****  * @note    When start==end then the function returns always false because the
 168:../../os/rt/include/chvt.h ****  *          time window has zero size.
 169:../../os/rt/include/chvt.h ****  *
 170:../../os/rt/include/chvt.h ****  * @param[in] start     the start of the time window (inclusive)
 171:../../os/rt/include/chvt.h ****  * @param[in] end       the end of the time window (non inclusive)
 172:../../os/rt/include/chvt.h ****  * @retval true         current time within the specified time window.
 173:../../os/rt/include/chvt.h ****  * @retval false        current time not within the specified time window.
 174:../../os/rt/include/chvt.h ****  *
 175:../../os/rt/include/chvt.h ****  * @xclass
 176:../../os/rt/include/chvt.h ****  */
 177:../../os/rt/include/chvt.h **** static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
 178:../../os/rt/include/chvt.h **** 
 179:../../os/rt/include/chvt.h ****   return chTimeIsInRangeX(chVTGetSystemTimeX(), start, end);
 180:../../os/rt/include/chvt.h **** }
 181:../../os/rt/include/chvt.h **** 
 182:../../os/rt/include/chvt.h **** /**
 183:../../os/rt/include/chvt.h ****  * @brief   Checks if the current system time is within the specified time
 184:../../os/rt/include/chvt.h ****  *          window.
 185:../../os/rt/include/chvt.h ****  * @note    When start==end then the function returns always false because the
 186:../../os/rt/include/chvt.h ****  *          time window has zero size.
 187:../../os/rt/include/chvt.h ****  *
 188:../../os/rt/include/chvt.h ****  * @param[in] start     the start of the time window (inclusive)
 189:../../os/rt/include/chvt.h ****  * @param[in] end       the end of the time window (non inclusive)
 190:../../os/rt/include/chvt.h ****  * @retval true         current time within the specified time window.
 191:../../os/rt/include/chvt.h ****  * @retval false        current time not within the specified time window.
 192:../../os/rt/include/chvt.h ****  *
 193:../../os/rt/include/chvt.h ****  * @api
 194:../../os/rt/include/chvt.h ****  */
 195:../../os/rt/include/chvt.h **** static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 196:../../os/rt/include/chvt.h **** 
 197:../../os/rt/include/chvt.h ****   return chTimeIsInRangeX(chVTGetSystemTime(), start, end);
 198:../../os/rt/include/chvt.h **** }
 199:../../os/rt/include/chvt.h **** 
 200:../../os/rt/include/chvt.h **** /**
 201:../../os/rt/include/chvt.h ****  * @brief   Returns the time interval until the next timer event.
 202:../../os/rt/include/chvt.h ****  * @note    The return value is not perfectly accurate and can report values
 203:../../os/rt/include/chvt.h ****  *          in excess of @p CH_CFG_ST_TIMEDELTA ticks.
 204:../../os/rt/include/chvt.h ****  * @note    The interval returned by this function is only meaningful if
 205:../../os/rt/include/chvt.h ****  *          more timers are not added to the list until the returned time.
 206:../../os/rt/include/chvt.h ****  *
 207:../../os/rt/include/chvt.h ****  * @param[out] timep    pointer to a variable that will contain the time
 208:../../os/rt/include/chvt.h ****  *                      interval until the next timer elapses. This pointer
 209:../../os/rt/include/chvt.h ****  *                      can be @p NULL if the information is not required.
 210:../../os/rt/include/chvt.h ****  * @return              The time, in ticks, until next time event.
 211:../../os/rt/include/chvt.h ****  * @retval false        if the timers list is empty.
 212:../../os/rt/include/chvt.h ****  * @retval true         if the timers list contains at least one timer.
 213:../../os/rt/include/chvt.h ****  *
 214:../../os/rt/include/chvt.h ****  * @iclass
 215:../../os/rt/include/chvt.h ****  */
 216:../../os/rt/include/chvt.h **** static inline bool chVTGetTimersStateI(sysinterval_t *timep) {
 217:../../os/rt/include/chvt.h ****   virtual_timers_list_t *vtlp = &currcore->vtlist;
 218:../../os/rt/include/chvt.h ****   ch_delta_list_t *dlp = &vtlp->dlist;
 219:../../os/rt/include/chvt.h **** 
 220:../../os/rt/include/chvt.h ****   chDbgCheckClassI();
 221:../../os/rt/include/chvt.h **** 
 222:../../os/rt/include/chvt.h ****   if (dlp == dlp->next) {
 223:../../os/rt/include/chvt.h ****     return false;
 224:../../os/rt/include/chvt.h ****   }
 225:../../os/rt/include/chvt.h **** 
 226:../../os/rt/include/chvt.h ****   if (timep != NULL) {
 227:../../os/rt/include/chvt.h **** #if CH_CFG_ST_TIMEDELTA == 0
 228:../../os/rt/include/chvt.h ****     *timep = dlp->next->delta;
 229:../../os/rt/include/chvt.h **** #else
 230:../../os/rt/include/chvt.h ****     *timep = (dlp->next->delta + (sysinterval_t)CH_CFG_ST_TIMEDELTA) -
 231:../../os/rt/include/chvt.h ****              chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
 232:../../os/rt/include/chvt.h **** #endif
 233:../../os/rt/include/chvt.h ****   }
 234:../../os/rt/include/chvt.h **** 
 235:../../os/rt/include/chvt.h ****   return true;
 236:../../os/rt/include/chvt.h **** }
 237:../../os/rt/include/chvt.h **** 
 238:../../os/rt/include/chvt.h **** /**
 239:../../os/rt/include/chvt.h ****  * @brief   Returns @p true if the specified timer is armed.
 240:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 241:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 242:../../os/rt/include/chvt.h ****  *
 243:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 244:../../os/rt/include/chvt.h ****  * @return              true if the timer is armed.
 245:../../os/rt/include/chvt.h ****  *
 246:../../os/rt/include/chvt.h ****  * @iclass
 247:../../os/rt/include/chvt.h ****  */
 248:../../os/rt/include/chvt.h **** static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 249:../../os/rt/include/chvt.h **** 
 250:../../os/rt/include/chvt.h ****   chDbgCheckClassI();
 251:../../os/rt/include/chvt.h **** 
 252:../../os/rt/include/chvt.h ****   return (bool)(vtp->dlist.next != NULL);
 253:../../os/rt/include/chvt.h **** }
 254:../../os/rt/include/chvt.h **** 
 255:../../os/rt/include/chvt.h **** /**
 256:../../os/rt/include/chvt.h ****  * @brief   Returns @p true if the specified timer is armed.
 257:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 258:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 259:../../os/rt/include/chvt.h ****  *
 260:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 261:../../os/rt/include/chvt.h ****  * @return              true if the timer is armed.
 262:../../os/rt/include/chvt.h ****  *
 263:../../os/rt/include/chvt.h ****  * @api
 264:../../os/rt/include/chvt.h ****  */
 265:../../os/rt/include/chvt.h **** static inline bool chVTIsArmed(const virtual_timer_t *vtp) {
 266:../../os/rt/include/chvt.h ****   bool b;
 267:../../os/rt/include/chvt.h **** 
 268:../../os/rt/include/chvt.h ****   chSysLock();
 269:../../os/rt/include/chvt.h ****   b = chVTIsArmedI(vtp);
 270:../../os/rt/include/chvt.h ****   chSysUnlock();
 271:../../os/rt/include/chvt.h **** 
 272:../../os/rt/include/chvt.h ****   return b;
 273:../../os/rt/include/chvt.h **** }
 274:../../os/rt/include/chvt.h **** 
 275:../../os/rt/include/chvt.h **** /**
 276:../../os/rt/include/chvt.h ****  * @brief   Disables a Virtual Timer.
 277:../../os/rt/include/chvt.h ****  * @note    The timer is first checked and disabled only if armed.
 278:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 279:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 280:../../os/rt/include/chvt.h ****  *
 281:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 282:../../os/rt/include/chvt.h ****  *
 283:../../os/rt/include/chvt.h ****  * @iclass
 284:../../os/rt/include/chvt.h ****  */
 285:../../os/rt/include/chvt.h **** static inline void chVTResetI(virtual_timer_t *vtp) {
 286:../../os/rt/include/chvt.h **** 
 287:../../os/rt/include/chvt.h ****   if (chVTIsArmedI(vtp)) {
  52               		.loc 2 287 0
  53 0012 8881      		ld r24,Y
  54 0014 9981      		ldd r25,Y+1
  55 0016 892B      		or r24,r25
  56 0018 01F0      		breq .L2
 288:../../os/rt/include/chvt.h ****     chVTDoResetI(vtp);
  57               		.loc 2 288 0
  58 001a CE01      		movw r24,r28
  59 001c 0E94 0000 		call chVTDoResetI
  60               	.LVL3:
  61               	.L2:
  62               	.LBE50:
  63               	.LBE49:
 289:../../os/rt/include/chvt.h ****   }
 290:../../os/rt/include/chvt.h **** }
 291:../../os/rt/include/chvt.h **** 
 292:../../os/rt/include/chvt.h **** /**
 293:../../os/rt/include/chvt.h ****  * @brief   Disables a Virtual Timer.
 294:../../os/rt/include/chvt.h ****  * @note    The timer is first checked and disabled only if armed.
 295:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 296:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 297:../../os/rt/include/chvt.h ****  *
 298:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 299:../../os/rt/include/chvt.h ****  *
 300:../../os/rt/include/chvt.h ****  * @api
 301:../../os/rt/include/chvt.h ****  */
 302:../../os/rt/include/chvt.h **** static inline void chVTReset(virtual_timer_t *vtp) {
 303:../../os/rt/include/chvt.h **** 
 304:../../os/rt/include/chvt.h ****   chSysLock();
 305:../../os/rt/include/chvt.h ****   chVTResetI(vtp);
 306:../../os/rt/include/chvt.h ****   chSysUnlock();
 307:../../os/rt/include/chvt.h **** }
 308:../../os/rt/include/chvt.h **** 
 309:../../os/rt/include/chvt.h **** /**
 310:../../os/rt/include/chvt.h ****  * @brief   Enables a one-shot virtual timer.
 311:../../os/rt/include/chvt.h ****  * @details If the virtual timer was already enabled then it is re-enabled
 312:../../os/rt/include/chvt.h ****  *          using the new parameters.
 313:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 314:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 315:../../os/rt/include/chvt.h ****  *
 316:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 317:../../os/rt/include/chvt.h ****  * @param[in] delay     the number of ticks before the operation timeouts, the
 318:../../os/rt/include/chvt.h ****  *                      special values are handled as follow:
 319:../../os/rt/include/chvt.h ****  *                      - @a TIME_INFINITE is allowed but interpreted as a
 320:../../os/rt/include/chvt.h ****  *                        normal time specification.
 321:../../os/rt/include/chvt.h ****  *                      - @a TIME_IMMEDIATE this value is not allowed.
 322:../../os/rt/include/chvt.h ****  *                      .
 323:../../os/rt/include/chvt.h ****  * @param[in] vtfunc    the timer callback function. After invoking the
 324:../../os/rt/include/chvt.h ****  *                      callback the timer is disabled and the structure can
 325:../../os/rt/include/chvt.h ****  *                      be disposed or reused.
 326:../../os/rt/include/chvt.h ****  * @param[in] par       a parameter that will be passed to the callback
 327:../../os/rt/include/chvt.h ****  *                      function
 328:../../os/rt/include/chvt.h ****  *
 329:../../os/rt/include/chvt.h ****  * @iclass
 330:../../os/rt/include/chvt.h ****  */
 331:../../os/rt/include/chvt.h **** static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
 332:../../os/rt/include/chvt.h ****                             vtfunc_t vtfunc, void *par) {
 333:../../os/rt/include/chvt.h **** 
 334:../../os/rt/include/chvt.h ****   chVTResetI(vtp);
 335:../../os/rt/include/chvt.h ****   chVTDoSetI(vtp, delay, vtfunc, par);
  64               		.loc 2 335 0
  65 0020 8E01      		movw r16,r28
  66 0022 20E0      		ldi r18,lo8(gs(vt_cb))
  67 0024 30E0      		ldi r19,hi8(gs(vt_cb))
  68 0026 48E2      		ldi r20,lo8(40)
  69 0028 51E3      		ldi r21,lo8(49)
  70 002a 61E0      		ldi r22,lo8(1)
  71 002c 70E0      		ldi r23,0
  72 002e CE01      		movw r24,r28
  73 0030 0E94 0000 		call chVTDoSetI
  74               	.LVL4:
  75               	/* epilogue start */
  76               	.LBE48:
  77               	.LBE47:
 144:main.c        ****   chVTSetI((virtual_timer_t *)arg, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, arg);
 145:main.c        ****   chSysUnlockFromISR();
 146:main.c        **** }...
  78               		.loc 1 146 0
  79 0034 DF91      		pop r29
  80 0036 CF91      		pop r28
  81               	.LVL5:
  82 0038 1F91      		pop r17
  83 003a 0F91      		pop r16
  84               	.LVL6:
  85 003c 0895      		ret
  86               		.cfi_endproc
  87               	.LFE250:
  89               		.section	.text.Thread1,"ax",@progbits
  91               	Thread1:
  92               	.LFB243:
  48:main.c        **** {
  93               		.loc 1 48 0
  94               		.cfi_startproc
  95               	.LVL7:
  96 0000 CF93      		push r28
  97               	.LCFI4:
  98               		.cfi_def_cfa_offset 3
  99               		.cfi_offset 28, -2
 100 0002 DF93      		push r29
 101               	.LCFI5:
 102               		.cfi_def_cfa_offset 4
 103               		.cfi_offset 29, -3
 104 0004 CDB7      		in r28,__SP_L__
 105 0006 DEB7      		in r29,__SP_H__
 106               	.LCFI6:
 107               		.cfi_def_cfa_register 28
 108 0008 6097      		sbiw r28,16
 109               	.LCFI7:
 110               		.cfi_def_cfa_offset 20
 111 000a 0FB6      		in __tmp_reg__,__SREG__
 112 000c F894      		cli
 113 000e DEBF      		out __SP_H__,r29
 114 0010 0FBE      		out __SREG__,__tmp_reg__
 115 0012 CDBF      		out __SP_L__,r28
 116               	/* prologue: function */
 117               	/* frame size = 16 */
 118               	/* stack size = 18 */
 119               	.L__stack_usage = 18
 120               	.LVL8:
 121               	.LBB66:
 122               	.LBB67:
 106:../../os/rt/include/chvt.h **** }
 123               		.loc 2 106 0
 124 0014 1A82      		std Y+2,__zero_reg__
 125 0016 1982      		std Y+1,__zero_reg__
 126               	.LVL9:
 127               	.LBE67:
 128               	.LBE66:
 129               	.LBB68:
 130               	.LBB69:
 131               	.LBB70:
 132               	.LBB71:
 133               		.file 3 "../../os/common/ports/AVR/chcore.h"
   1:../../os/common/ports/AVR/chcore.h **** /*
   2:../../os/common/ports/AVR/chcore.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/common/ports/AVR/chcore.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/common/ports/AVR/chcore.h **** 
   5:../../os/common/ports/AVR/chcore.h ****     This file is part of ChibiOS.
   6:../../os/common/ports/AVR/chcore.h **** 
   7:../../os/common/ports/AVR/chcore.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/common/ports/AVR/chcore.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/common/ports/AVR/chcore.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/common/ports/AVR/chcore.h **** 
  11:../../os/common/ports/AVR/chcore.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/common/ports/AVR/chcore.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/common/ports/AVR/chcore.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/common/ports/AVR/chcore.h ****     GNU General Public License for more details.
  15:../../os/common/ports/AVR/chcore.h **** 
  16:../../os/common/ports/AVR/chcore.h ****     You should have received a copy of the GNU General Public License
  17:../../os/common/ports/AVR/chcore.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/common/ports/AVR/chcore.h **** */
  19:../../os/common/ports/AVR/chcore.h **** 
  20:../../os/common/ports/AVR/chcore.h **** /**
  21:../../os/common/ports/AVR/chcore.h ****  * @file    chcore.h
  22:../../os/common/ports/AVR/chcore.h ****  * @brief   AVR port macros and structures.
  23:../../os/common/ports/AVR/chcore.h ****  *
  24:../../os/common/ports/AVR/chcore.h ****  * @addtogroup AVR_CORE
  25:../../os/common/ports/AVR/chcore.h ****  * @{
  26:../../os/common/ports/AVR/chcore.h ****  */
  27:../../os/common/ports/AVR/chcore.h **** 
  28:../../os/common/ports/AVR/chcore.h **** #ifndef CHCORE_H
  29:../../os/common/ports/AVR/chcore.h **** #define CHCORE_H
  30:../../os/common/ports/AVR/chcore.h **** 
  31:../../os/common/ports/AVR/chcore.h **** #include <avr/io.h>
  32:../../os/common/ports/AVR/chcore.h **** #include <avr/interrupt.h>
  33:../../os/common/ports/AVR/chcore.h **** 
  34:../../os/common/ports/AVR/chcore.h **** extern bool __avr_in_isr;
  35:../../os/common/ports/AVR/chcore.h **** 
  36:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  37:../../os/common/ports/AVR/chcore.h **** /* Module constants.                                                         */
  38:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  39:../../os/common/ports/AVR/chcore.h **** 
  40:../../os/common/ports/AVR/chcore.h **** /**
  41:../../os/common/ports/AVR/chcore.h ****  * @name    Port Capabilities and Constants
  42:../../os/common/ports/AVR/chcore.h ****  * @{
  43:../../os/common/ports/AVR/chcore.h ****  */
  44:../../os/common/ports/AVR/chcore.h **** /**
  45:../../os/common/ports/AVR/chcore.h ****  * @brief   This port supports a realtime counter.
  46:../../os/common/ports/AVR/chcore.h ****  */
  47:../../os/common/ports/AVR/chcore.h **** #define PORT_SUPPORTS_RT                FALSE
  48:../../os/common/ports/AVR/chcore.h **** 
  49:../../os/common/ports/AVR/chcore.h **** /**
  50:../../os/common/ports/AVR/chcore.h ****  * @brief   Natural alignment constant.
  51:../../os/common/ports/AVR/chcore.h ****  * @note    It is the minimum alignment for pointer-size variables.
  52:../../os/common/ports/AVR/chcore.h ****  */
  53:../../os/common/ports/AVR/chcore.h **** #define PORT_NATURAL_ALIGN              1U
  54:../../os/common/ports/AVR/chcore.h **** 
  55:../../os/common/ports/AVR/chcore.h **** /**
  56:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack alignment constant.
  57:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment required for the stack pointer.
  58:../../os/common/ports/AVR/chcore.h ****  */
  59:../../os/common/ports/AVR/chcore.h **** #define PORT_STACK_ALIGN                1U
  60:../../os/common/ports/AVR/chcore.h **** 
  61:../../os/common/ports/AVR/chcore.h **** /**
  62:../../os/common/ports/AVR/chcore.h ****  * @brief   Working Areas alignment constant.
  63:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment to be enforced for thread working areas.
  64:../../os/common/ports/AVR/chcore.h ****  */
  65:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA_ALIGN         1U
  66:../../os/common/ports/AVR/chcore.h **** /** @} */
  67:../../os/common/ports/AVR/chcore.h **** 
  68:../../os/common/ports/AVR/chcore.h **** /**
  69:../../os/common/ports/AVR/chcore.h ****  * @name    Architecture and Compiler
  70:../../os/common/ports/AVR/chcore.h ****  * @{
  71:../../os/common/ports/AVR/chcore.h ****  */
  72:../../os/common/ports/AVR/chcore.h **** /**
  73:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining an AVR architecture.
  74:../../os/common/ports/AVR/chcore.h ****  */
  75:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR
  76:../../os/common/ports/AVR/chcore.h **** 
  77:../../os/common/ports/AVR/chcore.h **** /**
  78:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining the specific AVR architecture.
  79:../../os/common/ports/AVR/chcore.h ****  */
  80:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR_MEGAAVR
  81:../../os/common/ports/AVR/chcore.h **** 
  82:../../os/common/ports/AVR/chcore.h **** /**
  83:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the implemented architecture.
  84:../../os/common/ports/AVR/chcore.h ****  */
  85:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_NAME          "AVR"
  86:../../os/common/ports/AVR/chcore.h **** 
  87:../../os/common/ports/AVR/chcore.h **** /**
  88:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the architecture variant.
  89:../../os/common/ports/AVR/chcore.h ****  */
  90:../../os/common/ports/AVR/chcore.h **** #define PORT_CORE_VARIANT_NAME          "MegaAVR"
  91:../../os/common/ports/AVR/chcore.h **** 
  92:../../os/common/ports/AVR/chcore.h **** /**
  93:../../os/common/ports/AVR/chcore.h ****  * @brief   Compiler name and version.
  94:../../os/common/ports/AVR/chcore.h ****  */
  95:../../os/common/ports/AVR/chcore.h **** #if defined(__GNUC__) || defined(__DOXYGEN__)
  96:../../os/common/ports/AVR/chcore.h **** #define PORT_COMPILER_NAME              "GCC " __VERSION__
  97:../../os/common/ports/AVR/chcore.h **** 
  98:../../os/common/ports/AVR/chcore.h **** #else
  99:../../os/common/ports/AVR/chcore.h **** #error "unsupported compiler"
 100:../../os/common/ports/AVR/chcore.h **** #endif
 101:../../os/common/ports/AVR/chcore.h **** 
 102:../../os/common/ports/AVR/chcore.h **** /**
 103:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-specific information string.
 104:../../os/common/ports/AVR/chcore.h ****  */
 105:../../os/common/ports/AVR/chcore.h **** #define PORT_INFO                       "None"
 106:../../os/common/ports/AVR/chcore.h **** /** @} */
 107:../../os/common/ports/AVR/chcore.h **** 
 108:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 109:../../os/common/ports/AVR/chcore.h **** /* Module pre-compile time settings.                                         */
 110:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 111:../../os/common/ports/AVR/chcore.h **** 
 112:../../os/common/ports/AVR/chcore.h **** /**
 113:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack size for the system idle thread.
 114:../../os/common/ports/AVR/chcore.h ****  * @details This size depends on the idle thread implementation, usually
 115:../../os/common/ports/AVR/chcore.h ****  *          the idle thread should take no more space than those reserved
 116:../../os/common/ports/AVR/chcore.h ****  *          by @p PORT_INT_REQUIRED_STACK.
 117:../../os/common/ports/AVR/chcore.h ****  */
 118:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_IDLE_THREAD_STACK_SIZE) || defined(__DOXYGEN__)
 119:../../os/common/ports/AVR/chcore.h **** #define PORT_IDLE_THREAD_STACK_SIZE     8
 120:../../os/common/ports/AVR/chcore.h **** #endif
 121:../../os/common/ports/AVR/chcore.h **** 
 122:../../os/common/ports/AVR/chcore.h **** /**
 123:../../os/common/ports/AVR/chcore.h ****  * @brief   Per-thread stack overhead for interrupts servicing.
 124:../../os/common/ports/AVR/chcore.h ****  * @details This constant is used in the calculation of the correct working
 125:../../os/common/ports/AVR/chcore.h ****  *          area size.
 126:../../os/common/ports/AVR/chcore.h ****  */
 127:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_INT_REQUIRED_STACK) || defined(__DOXYGEN__)
 128:../../os/common/ports/AVR/chcore.h **** #define PORT_INT_REQUIRED_STACK         32
 129:../../os/common/ports/AVR/chcore.h **** #endif
 130:../../os/common/ports/AVR/chcore.h **** 
 131:../../os/common/ports/AVR/chcore.h **** /**
 132:../../os/common/ports/AVR/chcore.h ****  * @brief   Enables a "wait for interrupt" instruction in the idle loop.
 133:../../os/common/ports/AVR/chcore.h ****  */
 134:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_AVR_WFI_SLEEP_IDLE) || defined(__DOXYGEN__)
 135:../../os/common/ports/AVR/chcore.h **** #define PORT_AVR_WFI_SLEEP_IDLE      FALSE
 136:../../os/common/ports/AVR/chcore.h **** #endif
 137:../../os/common/ports/AVR/chcore.h **** 
 138:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 139:../../os/common/ports/AVR/chcore.h **** /* Derived constants and error checks.                                       */
 140:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 141:../../os/common/ports/AVR/chcore.h **** 
 142:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 143:../../os/common/ports/AVR/chcore.h **** /* Module data structures and types.                                         */
 144:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 145:../../os/common/ports/AVR/chcore.h **** 
 146:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 147:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 148:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 149:../../os/common/ports/AVR/chcore.h **** 
 150:../../os/common/ports/AVR/chcore.h **** /**
 151:../../os/common/ports/AVR/chcore.h ****  * @brief   Type of stack and memory alignment enforcement.
 152:../../os/common/ports/AVR/chcore.h ****  * @note    In this architecture the stack alignment is enforced to 8 bits.
 153:../../os/common/ports/AVR/chcore.h ****  */
 154:../../os/common/ports/AVR/chcore.h **** typedef uint8_t stkalign_t;
 155:../../os/common/ports/AVR/chcore.h **** 
 156:../../os/common/ports/AVR/chcore.h **** /**
 157:../../os/common/ports/AVR/chcore.h ****  * @brief   Interrupt saved context.
 158:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the stack frame saved during a
 159:../../os/common/ports/AVR/chcore.h ****  *          preemption-capable interrupt handler.
 160:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 161:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 162:../../os/common/ports/AVR/chcore.h ****  */
 163:../../os/common/ports/AVR/chcore.h **** struct port_extctx {
 164:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 165:../../os/common/ports/AVR/chcore.h ****   uint8_t       r31;
 166:../../os/common/ports/AVR/chcore.h ****   uint8_t       r30;
 167:../../os/common/ports/AVR/chcore.h ****   uint8_t       r27;
 168:../../os/common/ports/AVR/chcore.h ****   uint8_t       r26;
 169:../../os/common/ports/AVR/chcore.h ****   uint8_t       r25;
 170:../../os/common/ports/AVR/chcore.h ****   uint8_t       r24;
 171:../../os/common/ports/AVR/chcore.h ****   uint8_t       r23;
 172:../../os/common/ports/AVR/chcore.h ****   uint8_t       r22;
 173:../../os/common/ports/AVR/chcore.h ****   uint8_t       r21;
 174:../../os/common/ports/AVR/chcore.h ****   uint8_t       r20;
 175:../../os/common/ports/AVR/chcore.h ****   uint8_t       r19;
 176:../../os/common/ports/AVR/chcore.h ****   uint8_t       r18;
 177:../../os/common/ports/AVR/chcore.h ****   uint8_t       sr;
 178:../../os/common/ports/AVR/chcore.h ****   uint8_t       r1;
 179:../../os/common/ports/AVR/chcore.h ****   uint8_t       r0;
 180:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 181:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 182:../../os/common/ports/AVR/chcore.h **** #endif
 183:../../os/common/ports/AVR/chcore.h ****   uint16_t      pc;
 184:../../os/common/ports/AVR/chcore.h **** };
 185:../../os/common/ports/AVR/chcore.h **** 
 186:../../os/common/ports/AVR/chcore.h **** /**
 187:../../os/common/ports/AVR/chcore.h ****  * @brief   System saved context.
 188:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the inner stack frame during a context
 189:../../os/common/ports/AVR/chcore.h ****  *          switching.
 190:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 191:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 192:../../os/common/ports/AVR/chcore.h ****  * @note    LR is stored in the caller context so it is not present in this
 193:../../os/common/ports/AVR/chcore.h ****  *          structure.
 194:../../os/common/ports/AVR/chcore.h ****  */
 195:../../os/common/ports/AVR/chcore.h **** struct port_intctx {
 196:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 197:../../os/common/ports/AVR/chcore.h ****   uint8_t       r29;
 198:../../os/common/ports/AVR/chcore.h ****   uint8_t       r28;
 199:../../os/common/ports/AVR/chcore.h ****   uint8_t       r17;
 200:../../os/common/ports/AVR/chcore.h ****   uint8_t       r16;
 201:../../os/common/ports/AVR/chcore.h ****   uint8_t       r15;
 202:../../os/common/ports/AVR/chcore.h ****   uint8_t       r14;
 203:../../os/common/ports/AVR/chcore.h ****   uint8_t       r13;
 204:../../os/common/ports/AVR/chcore.h ****   uint8_t       r12;
 205:../../os/common/ports/AVR/chcore.h ****   uint8_t       r11;
 206:../../os/common/ports/AVR/chcore.h ****   uint8_t       r10;
 207:../../os/common/ports/AVR/chcore.h ****   uint8_t       r9;
 208:../../os/common/ports/AVR/chcore.h ****   uint8_t       r8;
 209:../../os/common/ports/AVR/chcore.h ****   uint8_t       r7;
 210:../../os/common/ports/AVR/chcore.h ****   uint8_t       r6;
 211:../../os/common/ports/AVR/chcore.h ****   uint8_t       r5;
 212:../../os/common/ports/AVR/chcore.h ****   uint8_t       r4;
 213:../../os/common/ports/AVR/chcore.h ****   uint8_t       r3;
 214:../../os/common/ports/AVR/chcore.h ****   uint8_t       r2;
 215:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 216:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 217:../../os/common/ports/AVR/chcore.h **** #endif
 218:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcl;
 219:../../os/common/ports/AVR/chcore.h ****   uint8_t       pch;
 220:../../os/common/ports/AVR/chcore.h **** };
 221:../../os/common/ports/AVR/chcore.h **** 
 222:../../os/common/ports/AVR/chcore.h **** /**
 223:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p thread_t structure.
 224:../../os/common/ports/AVR/chcore.h ****  * @details This structure usually contains just the saved stack pointer
 225:../../os/common/ports/AVR/chcore.h ****  *          defined as a pointer to a @p port_intctx structure.
 226:../../os/common/ports/AVR/chcore.h ****  */
 227:../../os/common/ports/AVR/chcore.h **** struct port_context {
 228:../../os/common/ports/AVR/chcore.h ****   struct port_intctx *sp;
 229:../../os/common/ports/AVR/chcore.h **** };
 230:../../os/common/ports/AVR/chcore.h **** 
 231:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 232:../../os/common/ports/AVR/chcore.h **** 
 233:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 234:../../os/common/ports/AVR/chcore.h **** /* Module macros.                                                            */
 235:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 236:../../os/common/ports/AVR/chcore.h **** 
 237:../../os/common/ports/AVR/chcore.h **** /**
 238:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p chThdCreateI() API.
 239:../../os/common/ports/AVR/chcore.h ****  * @details This code usually setup the context switching frame represented
 240:../../os/common/ports/AVR/chcore.h ****  *          by an @p port_intctx structure.
 241:../../os/common/ports/AVR/chcore.h ****  */
 242:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__) || defined(__DOXYGEN__)
 243:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 244:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 245:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 246:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 247:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 248:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 249:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 250:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcx = (uint8_t)0;                                             \
 251:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 252:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 253:../../os/common/ports/AVR/chcore.h **** }
 254:../../os/common/ports/AVR/chcore.h **** #else /* !__AVR_3_BYTE_PC__ */
 255:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 256:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 257:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 258:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 259:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 260:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 261:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 262:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 263:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 264:../../os/common/ports/AVR/chcore.h **** }
 265:../../os/common/ports/AVR/chcore.h **** #endif /* !__AVR_3_BYTE_PC__ */
 266:../../os/common/ports/AVR/chcore.h **** 
 267:../../os/common/ports/AVR/chcore.h **** /**
 268:../../os/common/ports/AVR/chcore.h ****  * @brief   Computes the thread working area global size.
 269:../../os/common/ports/AVR/chcore.h ****  * @note    There is no need to perform alignments in this macro.
 270:../../os/common/ports/AVR/chcore.h ****  */
 271:../../os/common/ports/AVR/chcore.h **** #define PORT_WA_SIZE(n) ((sizeof(struct port_intctx) - 1) +                \
 272:../../os/common/ports/AVR/chcore.h ****                          (sizeof(struct port_extctx) - 1) +                \
 273:../../os/common/ports/AVR/chcore.h ****                          ((size_t)(n)) + ((size_t)(PORT_INT_REQUIRED_STACK)))
 274:../../os/common/ports/AVR/chcore.h **** 
 275:../../os/common/ports/AVR/chcore.h **** /**
 276:../../os/common/ports/AVR/chcore.h ****  * @brief   Static working area allocation.
 277:../../os/common/ports/AVR/chcore.h ****  * @details This macro is used to allocate a static thread working area
 278:../../os/common/ports/AVR/chcore.h ****  *          aligned as both position and size.
 279:../../os/common/ports/AVR/chcore.h ****  *
 280:../../os/common/ports/AVR/chcore.h ****  * @param[in] s         the name to be assigned to the stack array
 281:../../os/common/ports/AVR/chcore.h ****  * @param[in] n         the stack size to be assigned to the thread
 282:../../os/common/ports/AVR/chcore.h ****  */
 283:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA(s, n)                                             \
 284:../../os/common/ports/AVR/chcore.h ****   stkalign_t s[THD_WORKING_AREA_SIZE(n) / sizeof (stkalign_t)]
 285:../../os/common/ports/AVR/chcore.h **** 
 286:../../os/common/ports/AVR/chcore.h **** /**
 287:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 288:../../os/common/ports/AVR/chcore.h ****  */
 289:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_PRIORITY(n) false
 290:../../os/common/ports/AVR/chcore.h **** 
 291:../../os/common/ports/AVR/chcore.h **** /**
 292:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 293:../../os/common/ports/AVR/chcore.h ****  */
 294:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_KERNEL_PRIORITY(n) false
 295:../../os/common/ports/AVR/chcore.h **** 
 296:../../os/common/ports/AVR/chcore.h **** /**
 297:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ prologue code.
 298:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the start of all IRQ handlers
 299:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 300:../../os/common/ports/AVR/chcore.h ****  * @note    This code tricks the compiler to save all the specified registers
 301:../../os/common/ports/AVR/chcore.h ****  *          by "touching" them.
 302:../../os/common/ports/AVR/chcore.h ****  */
 303:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_PROLOGUE() {                                               \
 304:../../os/common/ports/AVR/chcore.h ****   asm ("" : : : "r18", "r19", "r20", "r21", "r22", "r23", "r24",            \
 305:../../os/common/ports/AVR/chcore.h ****                 "r25", "r26", "r27", "r30", "r31");                         \
 306:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 307:../../os/common/ports/AVR/chcore.h **** }
 308:../../os/common/ports/AVR/chcore.h **** 
 309:../../os/common/ports/AVR/chcore.h **** /**
 310:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ epilogue code.
 311:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the end of all IRQ handlers
 312:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 313:../../os/common/ports/AVR/chcore.h ****  */
 314:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_EPILOGUE() {                                               \
 315:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = false;                                                     \
 316:../../os/common/ports/AVR/chcore.h ****   __dbg_check_lock();                                                       \
 317:../../os/common/ports/AVR/chcore.h ****   if (chSchIsPreemptionRequired())                                          \
 318:../../os/common/ports/AVR/chcore.h ****     chSchDoPreemption();                                                    \
 319:../../os/common/ports/AVR/chcore.h ****   __dbg_check_unlock();                                                     \
 320:../../os/common/ports/AVR/chcore.h **** }
 321:../../os/common/ports/AVR/chcore.h **** 
 322:../../os/common/ports/AVR/chcore.h **** /**
 323:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ handler function declaration.
 324:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 325:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 326:../../os/common/ports/AVR/chcore.h ****  */
 327:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_HANDLER(id) ISR(id)
 328:../../os/common/ports/AVR/chcore.h **** 
 329:../../os/common/ports/AVR/chcore.h **** /**
 330:../../os/common/ports/AVR/chcore.h ****  * @brief   Fast IRQ handler function declaration.
 331:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 332:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 333:../../os/common/ports/AVR/chcore.h ****  */
 334:../../os/common/ports/AVR/chcore.h **** #define PORT_FAST_IRQ_HANDLER(id) ISR(id)
 335:../../os/common/ports/AVR/chcore.h **** 
 336:../../os/common/ports/AVR/chcore.h **** /**
 337:../../os/common/ports/AVR/chcore.h ****  * @brief   Performs a context switch between two threads.
 338:../../os/common/ports/AVR/chcore.h ****  * @details This is the most critical code in any port, this function
 339:../../os/common/ports/AVR/chcore.h ****  *          is responsible for the context switch between 2 threads.
 340:../../os/common/ports/AVR/chcore.h ****  * @note    The implementation of this code affects <b>directly</b> the context
 341:../../os/common/ports/AVR/chcore.h ****  *          switch performance so optimize here as much as you can.
 342:../../os/common/ports/AVR/chcore.h ****  *
 343:../../os/common/ports/AVR/chcore.h ****  * @param[in] ntp       the thread to be switched in
 344:../../os/common/ports/AVR/chcore.h ****  * @param[in] otp       the thread to be switched out
 345:../../os/common/ports/AVR/chcore.h ****  */
 346:../../os/common/ports/AVR/chcore.h **** #define port_switch(ntp, otp) {                                             \
 347:../../os/common/ports/AVR/chcore.h ****   _port_switch(ntp, otp);                                                   \
 348:../../os/common/ports/AVR/chcore.h ****   asm volatile ("" : : : "memory");                                         \
 349:../../os/common/ports/AVR/chcore.h **** }
 350:../../os/common/ports/AVR/chcore.h **** 
 351:../../os/common/ports/AVR/chcore.h **** 
 352:../../os/common/ports/AVR/chcore.h **** /**
 353:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-related initialization code.
 354:../../os/common/ports/AVR/chcore.h ****  * @note    This function is empty in this port.
 355:../../os/common/ports/AVR/chcore.h ****  */
 356:../../os/common/ports/AVR/chcore.h **** #define port_init(oip) {                                                    \
 357:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 358:../../os/common/ports/AVR/chcore.h **** }
 359:../../os/common/ports/AVR/chcore.h **** 
 360:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 361:../../os/common/ports/AVR/chcore.h **** /* External declarations.                                                    */
 362:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 363:../../os/common/ports/AVR/chcore.h **** 
 364:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 365:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 366:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 367:../../os/common/ports/AVR/chcore.h **** 
 368:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 369:../../os/common/ports/AVR/chcore.h **** extern "C" {
 370:../../os/common/ports/AVR/chcore.h **** #endif
 371:../../os/common/ports/AVR/chcore.h ****   void _port_switch(thread_t *ntp, thread_t *otp);
 372:../../os/common/ports/AVR/chcore.h ****   void _port_thread_start(void);
 373:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 374:../../os/common/ports/AVR/chcore.h **** }
 375:../../os/common/ports/AVR/chcore.h **** #endif
 376:../../os/common/ports/AVR/chcore.h **** 
 377:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 378:../../os/common/ports/AVR/chcore.h **** 
 379:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 380:../../os/common/ports/AVR/chcore.h **** /* Module inline functions.                                                  */
 381:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 382:../../os/common/ports/AVR/chcore.h **** 
 383:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 384:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 385:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 386:../../os/common/ports/AVR/chcore.h **** 
 387:../../os/common/ports/AVR/chcore.h **** /**
 388:../../os/common/ports/AVR/chcore.h ****  * @brief   Returns a word encoding the current interrupts status.
 389:../../os/common/ports/AVR/chcore.h ****  *
 390:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupts status.
 391:../../os/common/ports/AVR/chcore.h ****  */
 392:../../os/common/ports/AVR/chcore.h **** static inline syssts_t port_get_irq_status(void) {
 393:../../os/common/ports/AVR/chcore.h **** 
 394:../../os/common/ports/AVR/chcore.h ****   return SREG;
 395:../../os/common/ports/AVR/chcore.h **** }
 396:../../os/common/ports/AVR/chcore.h **** 
 397:../../os/common/ports/AVR/chcore.h **** /**
 398:../../os/common/ports/AVR/chcore.h ****  * @brief   Checks the interrupt status.
 399:../../os/common/ports/AVR/chcore.h ****  *
 400:../../os/common/ports/AVR/chcore.h ****  * @param[in] sts       the interrupt status word
 401:../../os/common/ports/AVR/chcore.h ****  *
 402:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupt status.
 403:../../os/common/ports/AVR/chcore.h ****  * @retval false        the word specified a disabled interrupts status.
 404:../../os/common/ports/AVR/chcore.h ****  * @retval true         the word specified an enabled interrupts status.
 405:../../os/common/ports/AVR/chcore.h ****  */
 406:../../os/common/ports/AVR/chcore.h **** static inline bool port_irq_enabled(syssts_t sts) {
 407:../../os/common/ports/AVR/chcore.h **** 
 408:../../os/common/ports/AVR/chcore.h ****   return (bool)((sts & 0x80) != 0);
 409:../../os/common/ports/AVR/chcore.h **** }
 410:../../os/common/ports/AVR/chcore.h **** 
 411:../../os/common/ports/AVR/chcore.h **** /**
 412:../../os/common/ports/AVR/chcore.h ****  * @brief   Determines the current execution context.
 413:../../os/common/ports/AVR/chcore.h ****  *
 414:../../os/common/ports/AVR/chcore.h ****  * @return              The execution context.
 415:../../os/common/ports/AVR/chcore.h ****  * @retval false        not running in ISR mode.
 416:../../os/common/ports/AVR/chcore.h ****  * @retval true         running in ISR mode.
 417:../../os/common/ports/AVR/chcore.h ****  */
 418:../../os/common/ports/AVR/chcore.h **** static inline bool port_is_isr_context(void) {
 419:../../os/common/ports/AVR/chcore.h **** 
 420:../../os/common/ports/AVR/chcore.h ****   return __avr_in_isr;
 421:../../os/common/ports/AVR/chcore.h **** }
 422:../../os/common/ports/AVR/chcore.h **** 
 423:../../os/common/ports/AVR/chcore.h **** /**
 424:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-lock action.
 425:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just disables interrupts but may perform more
 426:../../os/common/ports/AVR/chcore.h ****  *          actions.
 427:../../os/common/ports/AVR/chcore.h ****  */
 428:../../os/common/ports/AVR/chcore.h **** static inline void port_lock(void) {
 429:../../os/common/ports/AVR/chcore.h **** 
 430:../../os/common/ports/AVR/chcore.h ****   asm volatile ("cli" : : : "memory");
 134               		.loc 3 430 0
 135               	/* #APP */
 136               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 137 0018 F894      		cli
 138               	 ;  0 "" 2
 139               	.LVL10:
 140               	/* #NOAPP */
 141               	.LBE71:
 142               	.LBE70:
 143               	.LBE69:
 144               	.LBB72:
 145               	.LBB73:
 146               	.LBB74:
 147               	.LBB75:
 287:../../os/rt/include/chvt.h ****     chVTDoResetI(vtp);
 148               		.loc 2 287 0
 149 001a 8981      		ldd r24,Y+1
 150 001c 9A81      		ldd r25,Y+2
 151               	.LVL11:
 152 001e 892B      		or r24,r25
 153 0020 01F0      		breq .L13
 288:../../os/rt/include/chvt.h ****   }
 154               		.loc 2 288 0
 155 0022 CE01      		movw r24,r28
 156 0024 0196      		adiw r24,1
 157 0026 7C01      		movw r14,r24
 158 0028 0E94 0000 		call chVTDoResetI
 159               	.LVL12:
 160               	.L8:
 161               	.LBE75:
 162               	.LBE74:
 163               		.loc 2 335 0
 164 002c 8701      		movw r16,r14
 165 002e 20E0      		ldi r18,lo8(gs(vt_cb))
 166 0030 30E0      		ldi r19,hi8(gs(vt_cb))
 167 0032 48E2      		ldi r20,lo8(40)
 168 0034 51E3      		ldi r21,lo8(49)
 169 0036 61E0      		ldi r22,lo8(1)
 170 0038 70E0      		ldi r23,0
 171 003a C701      		movw r24,r14
 172 003c 0E94 0000 		call chVTDoSetI
 173               	.LVL13:
 174               	.LBE73:
 175               	.LBE72:
 176               	.LBB76:
 177               	.LBB77:
 178               	.LBB78:
 179               	.LBB79:
 431:../../os/common/ports/AVR/chcore.h **** }
 432:../../os/common/ports/AVR/chcore.h **** 
 433:../../os/common/ports/AVR/chcore.h **** /**
 434:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-unlock action.
 435:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just enables interrupts but may perform more
 436:../../os/common/ports/AVR/chcore.h ****  *          actions.
 437:../../os/common/ports/AVR/chcore.h ****  */
 438:../../os/common/ports/AVR/chcore.h **** static inline void port_unlock(void) {
 439:../../os/common/ports/AVR/chcore.h **** 
 440:../../os/common/ports/AVR/chcore.h ****   asm volatile ("sei" : : : "memory");
 180               		.loc 3 440 0
 181               	/* #APP */
 182               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 183 0040 7894      		sei
 184               	 ;  0 "" 2
 185               	/* #NOAPP */
 186               	.L9:
 187 0042 00C0      		rjmp .L9
 188               	.LVL14:
 189               	.L13:
 190 0044 CE01      		movw r24,r28
 191 0046 0196      		adiw r24,1
 192 0048 7C01      		movw r14,r24
 193 004a 00C0      		rjmp .L8
 194               	.LBE79:
 195               	.LBE78:
 196               	.LBE77:
 197               	.LBE76:
 198               	.LBE68:
 199               		.cfi_endproc
 200               	.LFE243:
 202               		.section	.text.startup.main,"ax",@progbits
 203               	.global	main
 205               	main:
 206               	.LFB244:
  63:main.c        **** {
 207               		.loc 1 63 0
 208               		.cfi_startproc
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213               	.LVL15:
 214               	.LBB80:
 215               	.LBB81:
 111:main.c        ****     buffer->head = 0;
 216               		.loc 1 111 0
 217 0000 1092 0000 		sts ev_buffer+8,__zero_reg__
 112:main.c        ****     buffer->tail = 0;
 218               		.loc 1 112 0
 219 0004 1092 0000 		sts ev_buffer+9,__zero_reg__
 113:main.c        ****     buffer->size = 0;
 220               		.loc 1 113 0
 221 0008 1092 0000 		sts ev_buffer+10,__zero_reg__
 222               	.LVL16:
 223               	.LBE81:
 224               	.LBE80:
  72:main.c        ****   halInit();
 225               		.loc 1 72 0
 226 000c 0E94 0000 		call halInit
 227               	.LVL17:
  73:main.c        ****   chSysInit();
 228               		.loc 1 73 0
 229 0010 0E94 0000 		call chSysInit
 230               	.LVL18:
  77:main.c        ****   palSetPadMode(IOPORT4, 7, PAL_MODE_OUTPUT_PUSHPULL);
 231               		.loc 1 77 0
 232 0014 46E0      		ldi r20,lo8(6)
 233 0016 60E8      		ldi r22,lo8(-128)
 234 0018 89E2      		ldi r24,lo8(41)
 235 001a 90E0      		ldi r25,0
 236 001c 0E94 0000 		call _pal_lld_setgroupmode
 237               	.LVL19:
  78:main.c        ****   palClearPad(IOPORT4, 7);
 238               		.loc 1 78 0
 239 0020 5F98      		cbi 0xb,7
  79:main.c        ****   palSetPadMode(IOPORT4, 6, PAL_MODE_OUTPUT_PUSHPULL);
 240               		.loc 1 79 0
 241 0022 46E0      		ldi r20,lo8(6)
 242 0024 60E4      		ldi r22,lo8(64)
 243 0026 89E2      		ldi r24,lo8(41)
 244 0028 90E0      		ldi r25,0
 245 002a 0E94 0000 		call _pal_lld_setgroupmode
 246               	.LVL20:
  80:main.c        ****   palClearPad(IOPORT4, 6);
 247               		.loc 1 80 0
 248 002e 5E98      		cbi 0xb,6
  83:main.c        ****   palSetPadMode(IOPORT2, 1, PAL_MODE_OUTPUT_PUSHPULL);
 249               		.loc 1 83 0
 250 0030 46E0      		ldi r20,lo8(6)
 251 0032 62E0      		ldi r22,lo8(2)
 252 0034 83E2      		ldi r24,lo8(35)
 253 0036 90E0      		ldi r25,0
 254 0038 0E94 0000 		call _pal_lld_setgroupmode
 255               	.LVL21:
  84:main.c        ****   palClearPad(IOPORT2, 1);
 256               		.loc 1 84 0
 257 003c 2998      		cbi 0x5,1
  85:main.c        ****   palSetPadMode(IOPORT2, 0, PAL_MODE_OUTPUT_PUSHPULL);
 258               		.loc 1 85 0
 259 003e 46E0      		ldi r20,lo8(6)
 260 0040 61E0      		ldi r22,lo8(1)
 261 0042 83E2      		ldi r24,lo8(35)
 262 0044 90E0      		ldi r25,0
 263 0046 0E94 0000 		call _pal_lld_setgroupmode
 264               	.LVL22:
  86:main.c        ****   palClearPad(IOPORT2, 0);
 265               		.loc 1 86 0
 266 004a 2898      		cbi 0x5,0
  89:main.c        ****   palSetPadMode(IOPORT2, 3, PAL_MODE_OUTPUT_PUSHPULL);
 267               		.loc 1 89 0
 268 004c 46E0      		ldi r20,lo8(6)
 269 004e 68E0      		ldi r22,lo8(8)
 270 0050 83E2      		ldi r24,lo8(35)
 271 0052 90E0      		ldi r25,0
 272 0054 0E94 0000 		call _pal_lld_setgroupmode
 273               	.LVL23:
  90:main.c        ****   palClearPad(IOPORT2, 3);
 274               		.loc 1 90 0
 275 0058 2B98      		cbi 0x5,3
  91:main.c        ****   palSetPadMode(IOPORT2, 2, PAL_MODE_OUTPUT_PUSHPULL);
 276               		.loc 1 91 0
 277 005a 46E0      		ldi r20,lo8(6)
 278 005c 64E0      		ldi r22,lo8(4)
 279 005e 83E2      		ldi r24,lo8(35)
 280 0060 90E0      		ldi r25,0
 281 0062 0E94 0000 		call _pal_lld_setgroupmode
 282               	.LVL24:
  92:main.c        ****   palClearPad(IOPORT2, 2);
 283               		.loc 1 92 0
 284 0066 2A98      		cbi 0x5,2
  95:main.c        ****   palSetPadMode(IOPORT2, PORTB_LED1, PAL_MODE_OUTPUT_PUSHPULL);
 285               		.loc 1 95 0
 286 0068 46E0      		ldi r20,lo8(6)
 287 006a 60E2      		ldi r22,lo8(32)
 288 006c 83E2      		ldi r24,lo8(35)
 289 006e 90E0      		ldi r25,0
 290 0070 0E94 0000 		call _pal_lld_setgroupmode
 291               	.LVL25:
  96:main.c        ****   palClearPad(IOPORT2, PORTB_LED1);
 292               		.loc 1 96 0
 293 0074 2D98      		cbi 0x5,5
 103:main.c        ****   chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO + 1, Thread1, NULL);
 294               		.loc 1 103 0
 295 0076 10E0      		ldi r17,0
 296 0078 00E0      		ldi r16,0
 297 007a 20E0      		ldi r18,lo8(gs(Thread1))
 298 007c 30E0      		ldi r19,hi8(gs(Thread1))
 299 007e 41E8      		ldi r20,lo8(-127)
 300 0080 63E8      		ldi r22,lo8(-125)
 301 0082 70E0      		ldi r23,0
 302 0084 80E0      		ldi r24,lo8(waThread1)
 303 0086 90E0      		ldi r25,hi8(waThread1)
 304 0088 0E94 0000 		call chThdCreateStatic
 305               	.LVL26:
 306               	.L15:
 307 008c 00C0      		rjmp .L15
 308               		.cfi_endproc
 309               	.LFE244:
 311               		.section	.text.bufferInit,"ax",@progbits
 312               	.global	bufferInit
 314               	bufferInit:
 315               	.LFB245:
 110:main.c        **** void bufferInit(EventBuffer *buffer) {
 316               		.loc 1 110 0
 317               		.cfi_startproc
 318               	.LVL27:
 319               	/* prologue: function */
 320               	/* frame size = 0 */
 321               	/* stack size = 0 */
 322               	.L__stack_usage = 0
 323 0000 FC01      		movw r30,r24
 111:main.c        ****     buffer->head = 0;
 324               		.loc 1 111 0
 325 0002 1086      		std Z+8,__zero_reg__
 112:main.c        ****     buffer->tail = 0;
 326               		.loc 1 112 0
 327 0004 1186      		std Z+9,__zero_reg__
 113:main.c        ****     buffer->size = 0;
 328               		.loc 1 113 0
 329 0006 1286      		std Z+10,__zero_reg__
 330               	/* epilogue start */
 114:main.c        **** }
 331               		.loc 1 114 0
 332 0008 0895      		ret
 333               		.cfi_endproc
 334               	.LFE245:
 336               		.section	.text.isBufferEmpty,"ax",@progbits
 337               	.global	isBufferEmpty
 339               	isBufferEmpty:
 340               	.LFB246:
 116:main.c        **** bool isBufferEmpty(EventBuffer *buffer) {
 341               		.loc 1 116 0
 342               		.cfi_startproc
 343               	.LVL28:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
 117:main.c        ****     return buffer->size == 0;
 348               		.loc 1 117 0
 349 0000 21E0      		ldi r18,lo8(1)
 350 0002 FC01      		movw r30,r24
 351 0004 8285      		ldd r24,Z+10
 352               	.LVL29:
 353 0006 8111      		cpse r24,__zero_reg__
 354 0008 20E0      		ldi r18,0
 355               	.L18:
 118:main.c        **** }
 356               		.loc 1 118 0
 357 000a 822F      		mov r24,r18
 358               	/* epilogue start */
 359 000c 0895      		ret
 360               		.cfi_endproc
 361               	.LFE246:
 363               		.section	.text.isBufferFull,"ax",@progbits
 364               	.global	isBufferFull
 366               	isBufferFull:
 367               	.LFB247:
 120:main.c        **** bool isBufferFull(EventBuffer *buffer) {
 368               		.loc 1 120 0
 369               		.cfi_startproc
 370               	.LVL30:
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 0 */
 374               	.L__stack_usage = 0
 121:main.c        ****     return buffer->size == BUFFER_SIZE;
 375               		.loc 1 121 0
 376 0000 21E0      		ldi r18,lo8(1)
 377 0002 FC01      		movw r30,r24
 378 0004 8285      		ldd r24,Z+10
 379               	.LVL31:
 380 0006 8830      		cpi r24,lo8(8)
 381 0008 01F0      		breq .L23
 382 000a 20E0      		ldi r18,0
 383               	.L23:
 122:main.c        **** }
 384               		.loc 1 122 0
 385 000c 822F      		mov r24,r18
 386               	/* epilogue start */
 387 000e 0895      		ret
 388               		.cfi_endproc
 389               	.LFE247:
 391               		.section	.text.bufferPush,"ax",@progbits
 392               	.global	bufferPush
 394               	bufferPush:
 395               	.LFB248:
 124:main.c        **** void bufferPush(EventBuffer *buffer, uint8_t event) {
 396               		.loc 1 124 0
 397               		.cfi_startproc
 398               	.LVL32:
 399               	/* prologue: function */
 400               	/* frame size = 0 */
 401               	/* stack size = 0 */
 402               	.L__stack_usage = 0
 403 0000 FC01      		movw r30,r24
 125:main.c        ****     buffer->events[buffer->tail] = event;
 404               		.loc 1 125 0
 405 0002 2185      		ldd r18,Z+9
 406 0004 30E0      		ldi r19,0
 407 0006 DC01      		movw r26,r24
 408 0008 A20F      		add r26,r18
 409 000a B31F      		adc r27,r19
 410 000c 6C93      		st X,r22
 126:main.c        ****     buffer->tail = (buffer->tail + 1) % BUFFER_SIZE;
 411               		.loc 1 126 0
 412 000e 2F5F      		subi r18,-1
 413 0010 3F4F      		sbci r19,-1
 414 0012 2770      		andi r18,7
 415 0014 3327      		clr r19
 416 0016 2187      		std Z+9,r18
 127:main.c        ****     buffer->size++;
 417               		.loc 1 127 0
 418 0018 8285      		ldd r24,Z+10
 419               	.LVL33:
 420 001a 8F5F      		subi r24,lo8(-(1))
 421 001c 8287      		std Z+10,r24
 422               	/* epilogue start */
 128:main.c        **** }
 423               		.loc 1 128 0
 424 001e 0895      		ret
 425               		.cfi_endproc
 426               	.LFE248:
 428               		.section	.text.bufferPop,"ax",@progbits
 429               	.global	bufferPop
 431               	bufferPop:
 432               	.LFB249:
 130:main.c        **** uint8_t bufferPop(EventBuffer *buffer) {
 433               		.loc 1 130 0
 434               		.cfi_startproc
 435               	.LVL34:
 436               	/* prologue: function */
 437               	/* frame size = 0 */
 438               	/* stack size = 0 */
 439               	.L__stack_usage = 0
 440 0000 FC01      		movw r30,r24
 441               	.LVL35:
 442               	.LBB82:
 443               	.LBB83:
 117:main.c        ****     return buffer->size == 0;
 444               		.loc 1 117 0
 445 0002 8285      		ldd r24,Z+10
 446               	.LVL36:
 447               	.LBE83:
 448               	.LBE82:
 131:main.c        ****     if (isBufferEmpty(buffer)) {
 449               		.loc 1 131 0
 450 0004 8823      		tst r24
 451 0006 01F0      		breq .L28
 135:main.c        ****     uint8_t event = buffer->events[buffer->head];
 452               		.loc 1 135 0
 453 0008 2085      		ldd r18,Z+8
 454 000a 30E0      		ldi r19,0
 455 000c DF01      		movw r26,r30
 456 000e A20F      		add r26,r18
 457 0010 B31F      		adc r27,r19
 458 0012 4C91      		ld r20,X
 459               	.LVL37:
 136:main.c        ****     buffer->head = (buffer->head + 1) % BUFFER_SIZE;
 460               		.loc 1 136 0
 461 0014 2F5F      		subi r18,-1
 462 0016 3F4F      		sbci r19,-1
 463 0018 2770      		andi r18,7
 464 001a 3327      		clr r19
 465 001c 2087      		std Z+8,r18
 137:main.c        ****     buffer->size--;
 466               		.loc 1 137 0
 467 001e 9FEF      		ldi r25,lo8(-1)
 468 0020 980F      		add r25,r24
 469 0022 9287      		std Z+10,r25
 138:main.c        ****     return event;
 470               		.loc 1 138 0
 471 0024 842F      		mov r24,r20
 472               	.LVL38:
 473               	.L28:
 474               	/* epilogue start */
 139:main.c        **** }
 475               		.loc 1 139 0
 476 0026 0895      		ret
 477               		.cfi_endproc
 478               	.LFE249:
 480               		.section	.bss.waThread1,"aw",@nobits
 483               	waThread1:
 484 0000 0000 0000 		.zero	131
 484      0000 0000 
 484      0000 0000 
 484      0000 0000 
 484      0000 0000 
 485               		.comm	ev_buffer,11,1
 486               		.text
 487               	.Letext0:
 488               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 489               		.file 5 "/usr/lib/avr/include/stdint.h"
 490               		.file 6 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 491               		.file 7 "../../os/rt/include/chearly.h"
 492               		.file 8 "../../os/rt/include/chobjects.h"
 493               		.file 9 "../../os/rt/include/chrfcu.h"
 494               		.file 10 "../../os/rt/include/chdebug.h"
 495               		.file 11 "../../os/rt/include/chtime.h"
 496               		.file 12 "../../os/rt/include/chlists.h"
 497               		.file 13 "../../os/rt/include/chsem.h"
 498               		.file 14 "../../os/rt/include/chmtx.h"
 499               		.file 15 "../../os/rt/include/chsys.h"
 500               		.file 16 "../../os/rt/include/chregistry.h"
 501               		.file 17 "../../os/rt/include/chevents.h"
 502               		.file 18 "../../os/oslib/include/chmemcore.h"
 503               		.file 19 "../../os/hal/include/hal_queues.h"
 504               		.file 20 "../../os/hal/ports/AVR/MEGA/LLD/GPIOv1/hal_pal_lld.h"
 505               		.file 21 "../../os/hal/include/hal_serial.h"
 506               		.file 22 "../../os/hal/ports/AVR/MEGA/LLD/USARTv1/hal_serial_lld.h"
 507               		.file 23 "../../os/hal/include/hal.h"
 508               		.file 24 "../../os/rt/include/chthreads.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccqgDFdN.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqgDFdN.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqgDFdN.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqgDFdN.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqgDFdN.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqgDFdN.s:13     .text.vt_cb:0000000000000000 vt_cb
     /tmp/ccqgDFdN.s:91     .text.Thread1:0000000000000000 Thread1
     /tmp/ccqgDFdN.s:205    .text.startup.main:0000000000000000 main
                            *COM*:000000000000000b ev_buffer
     /tmp/ccqgDFdN.s:483    .bss.waThread1:0000000000000000 waThread1
     /tmp/ccqgDFdN.s:314    .text.bufferInit:0000000000000000 bufferInit
     /tmp/ccqgDFdN.s:339    .text.isBufferEmpty:0000000000000000 isBufferEmpty
     /tmp/ccqgDFdN.s:366    .text.isBufferFull:0000000000000000 isBufferFull
     /tmp/ccqgDFdN.s:394    .text.bufferPush:0000000000000000 bufferPush
     /tmp/ccqgDFdN.s:431    .text.bufferPop:0000000000000000 bufferPop
>>>>>>> 3b427cd72e7bbfdaa7473cbc3f0814c31c805343

UNDEFINED SYMBOLS
halInit
chSysInit
_pal_lld_setgroupmode
_pal_lld_setlineid
_pal_lld_getpadfromline
_pal_lld_getportfromline
