   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.vt_cb,"ax",@progbits
  11               	.global	vt_cb
  13               	vt_cb:
  14               	.LFB249:
  15               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****     ChibiOS - Copyright (C) 2006..2018 Giovanni Di Sirio
   3:main.c        **** 
   4:main.c        ****     Licensed under the Apache License, Version 2.0 (the "License");
   5:main.c        ****     you may not use this file except in compliance with the License.
   6:main.c        ****     You may obtain a copy of the License at
   7:main.c        **** 
   8:main.c        ****         http://www.apache.org/licenses/LICENSE-2.0
   9:main.c        **** 
  10:main.c        ****     Unless required by applicable law or agreed to in writing, software
  11:main.c        ****     distributed under the License is distributed on an "AS IS" BASIS,
  12:main.c        ****     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13:main.c        ****     See the License for the specific language governing permissions and
  14:main.c        ****     limitations under the License.
  15:main.c        **** */
  16:main.c        **** 
  17:main.c        **** #include "ch.h"
  18:main.c        **** #include "hal.h"
  19:main.c        **** 
  20:main.c        **** #define LED_PERIODO 10000
  21:main.c        **** #define BUFFER_SIZE 8
  22:main.c        **** #define QUEUE_SIZE 128
  23:main.c        **** 
  24:main.c        **** /* Definições de pinos*/
  25:main.c        **** // LEDS
  26:main.c        **** #define PEDESTRE_VERDE PAL_LINE(IOPORT2, 3)
  27:main.c        **** #define PEDESTRE_VERMELHO PAL_LINE(IOPORT2, 2)
  28:main.c        **** #define PRIMARIO_VERDE PAL_LINE(IOPORT4, 7)
  29:main.c        **** #define PRIMARIO_AMARELO PAL_LINE(IOPORT4, 4)
  30:main.c        **** #define PRIMARIO_VERMELHO PAL_LINE(IOPORT4, 6)
  31:main.c        **** #define SECUNDARIO_VERDE PAL_LINE(IOPORT2, 1)
  32:main.c        **** #define SECUNDARIO_AMARELO PAL_LINE(IOPORT4, 5)
  33:main.c        **** #define SECUNDARIO_VERMELHO PAL_LINE(IOPORT2, 0)
  34:main.c        **** 
  35:main.c        **** // Botões
  36:main.c        **** #define AMB_PRIM PAL_LINE(IOPORT3, 3)
  37:main.c        **** #define AMB_SEC PAL_LINE(IOPORT3, 5)
  38:main.c        **** #define SEC_FLAG PAL_LINE(IOPORT3, 4)
  39:main.c        **** #define PED_FLAG PAL_LINE(IOPORT3, 2)
  40:main.c        **** 
  41:main.c        **** // Buffer
  42:main.c        **** static msg_t queue[QUEUE_SIZE], *rdp, *wrp;
  43:main.c        **** static size_t qsize;
  44:main.c        **** static mutex_t qmtx;
  45:main.c        **** static condition_variable_t qempty;
  46:main.c        **** static condition_variable_t qfull;
  47:main.c        **** 
  48:main.c        **** 
  49:main.c        **** typedef struct
  50:main.c        **** {
  51:main.c        ****   uint8_t events[BUFFER_SIZE];
  52:main.c        ****   uint8_t head;
  53:main.c        ****   uint8_t tail;
  54:main.c        ****   uint8_t size;
  55:main.c        **** } EventBuffer;
  56:main.c        **** 
  57:main.c        **** EventBuffer ev_buffer;
  58:main.c        **** 
  59:main.c        **** void queueInit(void);
  60:main.c        **** void enqueue(msg_t msg);
  61:main.c        **** msg_t dequeue(void);
  62:main.c        **** void bufferPush(EventBuffer *cb, uint8_t event);
  63:main.c        **** uint8_t bufferPop(EventBuffer *cb);
  64:main.c        **** uint8_t button_check(ioline_t line);
  65:main.c        **** void vt_cb(void *arg);
  66:main.c        **** 
  67:main.c        **** enum
  68:main.c        **** {
  69:main.c        ****   SECUNDARIO = 1,
  70:main.c        ****   PEDESTRE,
  71:main.c        ****   AMB_PRIMARIO,
  72:main.c        ****   AMB_SECUNDARIO
  73:main.c        **** };
  74:main.c        **** 
  75:main.c        **** /*
  76:main.c        ****  * LED blinker thread, times are in milliseconds.
  77:main.c        ****  */
  78:main.c        **** 
  79:main.c        **** static THD_WORKING_AREA(waThread1, 32);
  80:main.c        **** static THD_FUNCTION(Thread1, arg)
  81:main.c        **** {
  82:main.c        ****   virtual_timer_t vt;
  83:main.c        **** 
  84:main.c        ****   chVTObjectInit(&vt);
  85:main.c        ****   chVTSet(&vt, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, (void *)&vt);
  86:main.c        **** 
  87:main.c        ****   msg_t ev;
  88:main.c        ****   while (1)
  89:main.c        ****   {
  90:main.c        ****     ev = dequeue();
  91:main.c        ****     if (ev == AMB_PRIMARIO){
  92:main.c        ****       palSetLine(PRIMARIO_VERDE);
  93:main.c        ****     } else if (ev == AMB_SECUNDARIO){
  94:main.c        ****       palToggleLine(SECUNDARIO_VERDE);
  95:main.c        ****     } else if (ev == SECUNDARIO){
  96:main.c        ****       palSetLine(SECUNDARIO_VERMELHO);
  97:main.c        ****     } else if (ev == PEDESTRE){
  98:main.c        ****       palSetLine(PEDESTRE_VERDE);
  99:main.c        ****     }
 100:main.c        ****     chThdSleepMilliseconds(100);
 101:main.c        ****   }
 102:main.c        **** }
 103:main.c        **** 
 104:main.c        **** /*
 105:main.c        ****  * Application entry point.
 106:main.c        ****  */
 107:main.c        **** int main(void)
 108:main.c        **** {
 109:main.c        ****   queueInit();
 110:main.c        ****   /*
 111:main.c        ****    * System initializations.
 112:main.c        ****    * - HAL initialization, this also initializes the configured device drivers
 113:main.c        ****    *   and performs the board-specific initializations.
 114:main.c        ****    * - Kernel initialization, the main() function becomes a thread and the
 115:main.c        ****    *   RTOS is active.
 116:main.c        ****    */
 117:main.c        ****   halInit();
 118:main.c        ****   chSysInit();
 119:main.c        **** 
 120:main.c        ****   /* Configuração dos botões */
 121:main.c        ****   palSetLineMode(PED_FLAG, PAL_MODE_INPUT_PULLUP);
 122:main.c        ****   palSetLineMode(SEC_FLAG, PAL_MODE_INPUT_PULLUP);
 123:main.c        ****   palSetLineMode(AMB_PRIM, PAL_MODE_INPUT_PULLUP);
 124:main.c        ****   palSetLineMode(AMB_SEC, PAL_MODE_INPUT_PULLUP);
 125:main.c        **** 
 126:main.c        ****   // Pedestre
 127:main.c        ****   palSetLineMode(PEDESTRE_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
 128:main.c        ****   palClearLine(PEDESTRE_VERDE);
 129:main.c        ****   palSetLineMode(PEDESTRE_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 130:main.c        ****   palClearLine(PEDESTRE_VERMELHO);
 131:main.c        **** 
 132:main.c        ****   // Primário
 133:main.c        ****   palSetLineMode(PRIMARIO_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
 134:main.c        ****   palClearLine(PRIMARIO_VERDE);
 135:main.c        ****   palSetLineMode(PRIMARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
 136:main.c        ****   palClearLine(PRIMARIO_AMARELO);
 137:main.c        ****   palSetLineMode(PRIMARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 138:main.c        ****   palClearLine(PRIMARIO_VERMELHO);
 139:main.c        **** 
 140:main.c        ****   // Secundário
 141:main.c        ****   palSetLineMode(SECUNDARIO_VERDE, PAL_MODE_OUTPUT_PUSHPULL);
 142:main.c        ****   palClearLine(SECUNDARIO_VERDE);
 143:main.c        ****   palSetLineMode(SECUNDARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
 144:main.c        ****   palClearLine(SECUNDARIO_AMARELO);
 145:main.c        ****   palSetLineMode(SECUNDARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 146:main.c        ****   palClearLine(SECUNDARIO_VERMELHO);
 147:main.c        **** 
 148:main.c        ****   /*
 149:main.c        ****    * Starts the LED blinker thread.
 150:main.c        ****    */
 151:main.c        ****   chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 152:main.c        **** 
 153:main.c        ****   while (1)
 154:main.c        ****   {
 155:main.c        ****     if (button_check(AMB_SEC))
 156:main.c        ****     {
 157:main.c        ****       enqueue(AMB_SECUNDARIO);
 158:main.c        ****     }
 159:main.c        ****     else if (palReadLine(AMB_PRIM) == PAL_LOW)
 160:main.c        ****     {
 161:main.c        ****       enqueue(AMB_PRIMARIO);
 162:main.c        ****     }
 163:main.c        ****     else if (palReadLine(SEC_FLAG) == PAL_LOW)
 164:main.c        ****     {
 165:main.c        ****       enqueue(SECUNDARIO);
 166:main.c        ****     }
 167:main.c        ****     else if (palReadLine(PED_FLAG) == PAL_LOW)
 168:main.c        ****     {
 169:main.c        ****       enqueue(PEDESTRE);
 170:main.c        ****     }
 171:main.c        ****     /* Debouncing. */
 172:main.c        ****     chThdSleepMilliseconds(50);
 173:main.c        ****   }
 174:main.c        **** }
 175:main.c        **** 
 176:main.c        **** /*
 177:main.c        ****  * Synchronized queue initialization.
 178:main.c        ****  */
 179:main.c        **** void queueInit(void) {
 180:main.c        ****  
 181:main.c        ****   chMtxObjectInit(&qmtx);
 182:main.c        ****   chCondObjectInit(&qempty);
 183:main.c        ****   chCondObjectInit(&qfull);
 184:main.c        ****  
 185:main.c        ****   rdp = wrp = &queue[0];
 186:main.c        ****   qsize = 0;
 187:main.c        **** }
 188:main.c        **** 
 189:main.c        **** /*
 190:main.c        ****  * Writes a message into the queue, if the queue is full waits
 191:main.c        ****  * for a free slot.
 192:main.c        ****  */
 193:main.c        **** void enqueue(msg_t msg) {
 194:main.c        ****  
 195:main.c        ****   /* Entering monitor.*/
 196:main.c        ****   chMtxLock(&qmtx);
 197:main.c        ****  
 198:main.c        ****   /* Waiting for space in the queue.*/
 199:main.c        ****   while (qsize >= QUEUE_SIZE)
 200:main.c        ****     chCondWait(&qfull);
 201:main.c        ****  
 202:main.c        ****   /* Writing the message in the queue.*/  
 203:main.c        ****   *wrp = msg;
 204:main.c        ****   if (++wrp >= &queue[QUEUE_SIZE])
 205:main.c        ****     wrp = &queue[0];
 206:main.c        ****   qsize++;
 207:main.c        ****  
 208:main.c        ****   /* Signaling that there is at least a message.*/
 209:main.c        ****   chCondSignal(&qempty);
 210:main.c        ****  
 211:main.c        ****   /* Leaving monitor.*/
 212:main.c        ****   chMtxUnlock(&qmtx);
 213:main.c        **** }
 214:main.c        **** 
 215:main.c        **** /*
 216:main.c        ****  * Reads a message from the queue, if the queue is empty waits
 217:main.c        ****  * for a message.
 218:main.c        ****  */
 219:main.c        **** msg_t dequeue(void) {
 220:main.c        ****   msg_t msg;
 221:main.c        ****  
 222:main.c        ****   /* Entering monitor.*/
 223:main.c        ****   chMtxLock(&qmtx);
 224:main.c        ****  
 225:main.c        ****   /* Waiting for messages in the queue.*/
 226:main.c        ****   while (qsize == 0)
 227:main.c        ****     chCondWait(&qempty);
 228:main.c        ****  
 229:main.c        ****   /* Reading the message from the queue.*/  
 230:main.c        ****   msg = *rdp;
 231:main.c        ****   if (++rdp >= &queue[QUEUE_SIZE])
 232:main.c        ****     rdp = &queue[0];
 233:main.c        ****   qsize--;
 234:main.c        ****  
 235:main.c        ****   /* Signaling that there is at least one free slot.*/
 236:main.c        ****   chCondSignal(&qfull);
 237:main.c        ****  
 238:main.c        ****   /* Leaving monitor.*/
 239:main.c        ****   chMtxUnlock(&qmtx);
 240:main.c        ****  
 241:main.c        ****   return msg;
 242:main.c        **** }
 243:main.c        **** 
 244:main.c        **** uint8_t button_check(ioline_t line) {
 245:main.c        ****   static uint8_t x, w, old_x;
 246:main.c        ****   x = palReadLine(line);
 247:main.c        ****   w = x^old_x;
 248:main.c        ****   old_x = x;
 249:main.c        ****   return w &! x;
 250:main.c        **** }
 251:main.c        **** 
 252:main.c        **** void vt_cb(void *arg)
 253:main.c        **** {
  16               		.loc 1 253 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23 0002 1F93      		push r17
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 17, -3
  27 0004 CF93      		push r28
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 28, -4
  31 0006 DF93      		push r29
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 29, -5
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 4 */
  38               	.L__stack_usage = 4
  39 0008 EC01      		movw r28,r24
 254:main.c        ****   chSysLockFromISR();
 255:main.c        ****   palTogglePad(IOPORT2, PORTB_LED1);
  40               		.loc 1 255 0
  41 000a 85B1      		in r24,0x5
  42               	.LVL1:
  43 000c 90E2      		ldi r25,lo8(32)
  44 000e 8927      		eor r24,r25
  45 0010 85B9      		out 0x5,r24
  46               	.LVL2:
  47               	.LBB43:
  48               	.LBB44:
  49               	.LBB45:
  50               	.LBB46:
  51               		.file 2 "../../os/rt/include/chvt.h"
   1:../../os/rt/include/chvt.h **** /*
   2:../../os/rt/include/chvt.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chvt.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chvt.h **** 
   5:../../os/rt/include/chvt.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chvt.h **** 
   7:../../os/rt/include/chvt.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chvt.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chvt.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chvt.h **** 
  11:../../os/rt/include/chvt.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chvt.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chvt.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chvt.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chvt.h **** 
  16:../../os/rt/include/chvt.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chvt.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chvt.h **** */
  19:../../os/rt/include/chvt.h **** 
  20:../../os/rt/include/chvt.h **** /**
  21:../../os/rt/include/chvt.h ****  * @file    rt/include/chvt.h
  22:../../os/rt/include/chvt.h ****  * @brief   Time and Virtual Timers module macros and structures.
  23:../../os/rt/include/chvt.h ****  *
  24:../../os/rt/include/chvt.h ****  * @addtogroup time
  25:../../os/rt/include/chvt.h ****  * @{
  26:../../os/rt/include/chvt.h ****  */
  27:../../os/rt/include/chvt.h **** 
  28:../../os/rt/include/chvt.h **** #ifndef CHVT_H
  29:../../os/rt/include/chvt.h **** #define CHVT_H
  30:../../os/rt/include/chvt.h **** 
  31:../../os/rt/include/chvt.h **** /*===========================================================================*/
  32:../../os/rt/include/chvt.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chvt.h **** /*===========================================================================*/
  34:../../os/rt/include/chvt.h **** 
  35:../../os/rt/include/chvt.h **** /*===========================================================================*/
  36:../../os/rt/include/chvt.h **** /* Module pre-compile time settings.                                         */
  37:../../os/rt/include/chvt.h **** /*===========================================================================*/
  38:../../os/rt/include/chvt.h **** 
  39:../../os/rt/include/chvt.h **** /*===========================================================================*/
  40:../../os/rt/include/chvt.h **** /* Derived constants and error checks.                                       */
  41:../../os/rt/include/chvt.h **** /*===========================================================================*/
  42:../../os/rt/include/chvt.h **** 
  43:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA < 0) || (CH_CFG_ST_TIMEDELTA == 1)
  44:../../os/rt/include/chvt.h **** #error "invalid CH_CFG_ST_TIMEDELTA specified, must "                       \
  45:../../os/rt/include/chvt.h ****        "be zero or greater than one"
  46:../../os/rt/include/chvt.h **** #endif
  47:../../os/rt/include/chvt.h **** 
  48:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA > 0) && (CH_CFG_TIME_QUANTUM > 0)
  49:../../os/rt/include/chvt.h **** #error "CH_CFG_TIME_QUANTUM not supported in tickless mode"
  50:../../os/rt/include/chvt.h **** #endif
  51:../../os/rt/include/chvt.h **** 
  52:../../os/rt/include/chvt.h **** #if (CH_CFG_ST_TIMEDELTA > 0) && (CH_DBG_THREADS_PROFILING == TRUE)
  53:../../os/rt/include/chvt.h **** #error "CH_DBG_THREADS_PROFILING not supported in tickless mode"
  54:../../os/rt/include/chvt.h **** #endif
  55:../../os/rt/include/chvt.h **** 
  56:../../os/rt/include/chvt.h **** /*===========================================================================*/
  57:../../os/rt/include/chvt.h **** /* Module data structures and types.                                         */
  58:../../os/rt/include/chvt.h **** /*===========================================================================*/
  59:../../os/rt/include/chvt.h **** 
  60:../../os/rt/include/chvt.h **** /*===========================================================================*/
  61:../../os/rt/include/chvt.h **** /* Module macros.                                                            */
  62:../../os/rt/include/chvt.h **** /*===========================================================================*/
  63:../../os/rt/include/chvt.h **** 
  64:../../os/rt/include/chvt.h **** /*===========================================================================*/
  65:../../os/rt/include/chvt.h **** /* External declarations.                                                    */
  66:../../os/rt/include/chvt.h **** /*===========================================================================*/
  67:../../os/rt/include/chvt.h **** 
  68:../../os/rt/include/chvt.h **** /*
  69:../../os/rt/include/chvt.h ****  * Virtual Timers APIs.
  70:../../os/rt/include/chvt.h ****  */
  71:../../os/rt/include/chvt.h **** #ifdef __cplusplus
  72:../../os/rt/include/chvt.h **** extern "C" {
  73:../../os/rt/include/chvt.h **** #endif
  74:../../os/rt/include/chvt.h ****   void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
  75:../../os/rt/include/chvt.h ****                   vtfunc_t vtfunc, void *par);
  76:../../os/rt/include/chvt.h ****   void chVTDoSetContinuousI(virtual_timer_t *vtp, sysinterval_t delay,
  77:../../os/rt/include/chvt.h ****                             vtfunc_t vtfunc, void *par);
  78:../../os/rt/include/chvt.h ****   void chVTDoResetI(virtual_timer_t *vtp);
  79:../../os/rt/include/chvt.h ****   sysinterval_t chVTGetRemainingIntervalI(virtual_timer_t *vtp);
  80:../../os/rt/include/chvt.h ****   void chVTDoTickI(void);
  81:../../os/rt/include/chvt.h **** #if CH_CFG_USE_TIMESTAMP == TRUE
  82:../../os/rt/include/chvt.h ****   systimestamp_t chVTGetTimeStampI(void);
  83:../../os/rt/include/chvt.h ****   void chVTResetTimeStampI(void);
  84:../../os/rt/include/chvt.h **** #endif
  85:../../os/rt/include/chvt.h **** #ifdef __cplusplus
  86:../../os/rt/include/chvt.h **** }
  87:../../os/rt/include/chvt.h **** #endif
  88:../../os/rt/include/chvt.h **** 
  89:../../os/rt/include/chvt.h **** /*===========================================================================*/
  90:../../os/rt/include/chvt.h **** /* Module inline functions.                                                  */
  91:../../os/rt/include/chvt.h **** /*===========================================================================*/
  92:../../os/rt/include/chvt.h **** 
  93:../../os/rt/include/chvt.h **** /**
  94:../../os/rt/include/chvt.h ****  * @brief   Initializes a @p virtual_timer_t object.
  95:../../os/rt/include/chvt.h ****  * @note    Initializing a timer object is not strictly required because
  96:../../os/rt/include/chvt.h ****  *          the function @p chVTSetI() initializes the object too. This
  97:../../os/rt/include/chvt.h ****  *          function is only useful if you need to perform a @p chVTIsArmed()
  98:../../os/rt/include/chvt.h ****  *          check before calling @p chVTSetI().
  99:../../os/rt/include/chvt.h ****  *
 100:../../os/rt/include/chvt.h ****  * @param[out] vtp      the @p virtual_timer_t structure pointer
 101:../../os/rt/include/chvt.h ****  *
 102:../../os/rt/include/chvt.h ****  * @init
 103:../../os/rt/include/chvt.h ****  */
 104:../../os/rt/include/chvt.h **** static inline void chVTObjectInit(virtual_timer_t *vtp) {
 105:../../os/rt/include/chvt.h **** 
 106:../../os/rt/include/chvt.h ****   vtp->dlist.next = NULL;
 107:../../os/rt/include/chvt.h **** }
 108:../../os/rt/include/chvt.h **** 
 109:../../os/rt/include/chvt.h **** /**
 110:../../os/rt/include/chvt.h ****  * @brief   Current system time.
 111:../../os/rt/include/chvt.h ****  * @details Returns the number of system ticks since the @p chSysInit()
 112:../../os/rt/include/chvt.h ****  *          invocation.
 113:../../os/rt/include/chvt.h ****  * @note    The counter can reach its maximum and then restart from zero.
 114:../../os/rt/include/chvt.h ****  * @note    This function can be called from any context but its atomicity
 115:../../os/rt/include/chvt.h ****  *          is not guaranteed on architectures whose word size is less than
 116:../../os/rt/include/chvt.h ****  *          @p systime_t size.
 117:../../os/rt/include/chvt.h ****  *
 118:../../os/rt/include/chvt.h ****  * @return              The system time in ticks.
 119:../../os/rt/include/chvt.h ****  *
 120:../../os/rt/include/chvt.h ****  * @xclass
 121:../../os/rt/include/chvt.h ****  */
 122:../../os/rt/include/chvt.h **** static inline systime_t chVTGetSystemTimeX(void) {
 123:../../os/rt/include/chvt.h **** 
 124:../../os/rt/include/chvt.h **** #if CH_CFG_ST_TIMEDELTA == 0
 125:../../os/rt/include/chvt.h ****   return currcore->vtlist.systime;
 126:../../os/rt/include/chvt.h **** #else /* CH_CFG_ST_TIMEDELTA > 0 */
 127:../../os/rt/include/chvt.h ****   return port_timer_get_time();
 128:../../os/rt/include/chvt.h **** #endif /* CH_CFG_ST_TIMEDELTA > 0 */
 129:../../os/rt/include/chvt.h **** }
 130:../../os/rt/include/chvt.h **** 
 131:../../os/rt/include/chvt.h **** /**
 132:../../os/rt/include/chvt.h ****  * @brief   Current system time.
 133:../../os/rt/include/chvt.h ****  * @details Returns the number of system ticks since the @p chSysInit()
 134:../../os/rt/include/chvt.h ****  *          invocation.
 135:../../os/rt/include/chvt.h ****  * @note    The counter can reach its maximum and then restart from zero.
 136:../../os/rt/include/chvt.h ****  *
 137:../../os/rt/include/chvt.h ****  * @return              The system time in ticks.
 138:../../os/rt/include/chvt.h ****  *
 139:../../os/rt/include/chvt.h ****  * @api
 140:../../os/rt/include/chvt.h ****  */
 141:../../os/rt/include/chvt.h **** static inline systime_t chVTGetSystemTime(void) {
 142:../../os/rt/include/chvt.h ****   systime_t systime;
 143:../../os/rt/include/chvt.h **** 
 144:../../os/rt/include/chvt.h ****   chSysLock();
 145:../../os/rt/include/chvt.h ****   systime = chVTGetSystemTimeX();
 146:../../os/rt/include/chvt.h ****   chSysUnlock();
 147:../../os/rt/include/chvt.h **** 
 148:../../os/rt/include/chvt.h ****   return systime;
 149:../../os/rt/include/chvt.h **** }
 150:../../os/rt/include/chvt.h **** 
 151:../../os/rt/include/chvt.h **** /**
 152:../../os/rt/include/chvt.h ****  * @brief   Returns the elapsed time since the specified start time.
 153:../../os/rt/include/chvt.h ****  *
 154:../../os/rt/include/chvt.h ****  * @param[in] start     start time
 155:../../os/rt/include/chvt.h ****  * @return              The elapsed time.
 156:../../os/rt/include/chvt.h ****  *
 157:../../os/rt/include/chvt.h ****  * @xclass
 158:../../os/rt/include/chvt.h ****  */
 159:../../os/rt/include/chvt.h **** static inline sysinterval_t chVTTimeElapsedSinceX(systime_t start) {
 160:../../os/rt/include/chvt.h **** 
 161:../../os/rt/include/chvt.h ****   return chTimeDiffX(start, chVTGetSystemTimeX());
 162:../../os/rt/include/chvt.h **** }
 163:../../os/rt/include/chvt.h **** 
 164:../../os/rt/include/chvt.h **** /**
 165:../../os/rt/include/chvt.h ****  * @brief   Checks if the current system time is within the specified time
 166:../../os/rt/include/chvt.h ****  *          window.
 167:../../os/rt/include/chvt.h ****  * @note    When start==end then the function returns always false because the
 168:../../os/rt/include/chvt.h ****  *          time window has zero size.
 169:../../os/rt/include/chvt.h ****  *
 170:../../os/rt/include/chvt.h ****  * @param[in] start     the start of the time window (inclusive)
 171:../../os/rt/include/chvt.h ****  * @param[in] end       the end of the time window (non inclusive)
 172:../../os/rt/include/chvt.h ****  * @retval true         current time within the specified time window.
 173:../../os/rt/include/chvt.h ****  * @retval false        current time not within the specified time window.
 174:../../os/rt/include/chvt.h ****  *
 175:../../os/rt/include/chvt.h ****  * @xclass
 176:../../os/rt/include/chvt.h ****  */
 177:../../os/rt/include/chvt.h **** static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
 178:../../os/rt/include/chvt.h **** 
 179:../../os/rt/include/chvt.h ****   return chTimeIsInRangeX(chVTGetSystemTimeX(), start, end);
 180:../../os/rt/include/chvt.h **** }
 181:../../os/rt/include/chvt.h **** 
 182:../../os/rt/include/chvt.h **** /**
 183:../../os/rt/include/chvt.h ****  * @brief   Checks if the current system time is within the specified time
 184:../../os/rt/include/chvt.h ****  *          window.
 185:../../os/rt/include/chvt.h ****  * @note    When start==end then the function returns always false because the
 186:../../os/rt/include/chvt.h ****  *          time window has zero size.
 187:../../os/rt/include/chvt.h ****  *
 188:../../os/rt/include/chvt.h ****  * @param[in] start     the start of the time window (inclusive)
 189:../../os/rt/include/chvt.h ****  * @param[in] end       the end of the time window (non inclusive)
 190:../../os/rt/include/chvt.h ****  * @retval true         current time within the specified time window.
 191:../../os/rt/include/chvt.h ****  * @retval false        current time not within the specified time window.
 192:../../os/rt/include/chvt.h ****  *
 193:../../os/rt/include/chvt.h ****  * @api
 194:../../os/rt/include/chvt.h ****  */
 195:../../os/rt/include/chvt.h **** static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 196:../../os/rt/include/chvt.h **** 
 197:../../os/rt/include/chvt.h ****   return chTimeIsInRangeX(chVTGetSystemTime(), start, end);
 198:../../os/rt/include/chvt.h **** }
 199:../../os/rt/include/chvt.h **** 
 200:../../os/rt/include/chvt.h **** /**
 201:../../os/rt/include/chvt.h ****  * @brief   Returns the time interval until the next timer event.
 202:../../os/rt/include/chvt.h ****  * @note    The return value is not perfectly accurate and can report values
 203:../../os/rt/include/chvt.h ****  *          in excess of @p CH_CFG_ST_TIMEDELTA ticks.
 204:../../os/rt/include/chvt.h ****  * @note    The interval returned by this function is only meaningful if
 205:../../os/rt/include/chvt.h ****  *          more timers are not added to the list until the returned time.
 206:../../os/rt/include/chvt.h ****  *
 207:../../os/rt/include/chvt.h ****  * @param[out] timep    pointer to a variable that will contain the time
 208:../../os/rt/include/chvt.h ****  *                      interval until the next timer elapses. This pointer
 209:../../os/rt/include/chvt.h ****  *                      can be @p NULL if the information is not required.
 210:../../os/rt/include/chvt.h ****  * @return              The time, in ticks, until next time event.
 211:../../os/rt/include/chvt.h ****  * @retval false        if the timers list is empty.
 212:../../os/rt/include/chvt.h ****  * @retval true         if the timers list contains at least one timer.
 213:../../os/rt/include/chvt.h ****  *
 214:../../os/rt/include/chvt.h ****  * @iclass
 215:../../os/rt/include/chvt.h ****  */
 216:../../os/rt/include/chvt.h **** static inline bool chVTGetTimersStateI(sysinterval_t *timep) {
 217:../../os/rt/include/chvt.h ****   virtual_timers_list_t *vtlp = &currcore->vtlist;
 218:../../os/rt/include/chvt.h ****   ch_delta_list_t *dlp = &vtlp->dlist;
 219:../../os/rt/include/chvt.h **** 
 220:../../os/rt/include/chvt.h ****   chDbgCheckClassI();
 221:../../os/rt/include/chvt.h **** 
 222:../../os/rt/include/chvt.h ****   if (dlp == dlp->next) {
 223:../../os/rt/include/chvt.h ****     return false;
 224:../../os/rt/include/chvt.h ****   }
 225:../../os/rt/include/chvt.h **** 
 226:../../os/rt/include/chvt.h ****   if (timep != NULL) {
 227:../../os/rt/include/chvt.h **** #if CH_CFG_ST_TIMEDELTA == 0
 228:../../os/rt/include/chvt.h ****     *timep = dlp->next->delta;
 229:../../os/rt/include/chvt.h **** #else
 230:../../os/rt/include/chvt.h ****     *timep = (dlp->next->delta + (sysinterval_t)CH_CFG_ST_TIMEDELTA) -
 231:../../os/rt/include/chvt.h ****              chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
 232:../../os/rt/include/chvt.h **** #endif
 233:../../os/rt/include/chvt.h ****   }
 234:../../os/rt/include/chvt.h **** 
 235:../../os/rt/include/chvt.h ****   return true;
 236:../../os/rt/include/chvt.h **** }
 237:../../os/rt/include/chvt.h **** 
 238:../../os/rt/include/chvt.h **** /**
 239:../../os/rt/include/chvt.h ****  * @brief   Returns @p true if the specified timer is armed.
 240:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 241:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 242:../../os/rt/include/chvt.h ****  *
 243:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 244:../../os/rt/include/chvt.h ****  * @return              true if the timer is armed.
 245:../../os/rt/include/chvt.h ****  *
 246:../../os/rt/include/chvt.h ****  * @iclass
 247:../../os/rt/include/chvt.h ****  */
 248:../../os/rt/include/chvt.h **** static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 249:../../os/rt/include/chvt.h **** 
 250:../../os/rt/include/chvt.h ****   chDbgCheckClassI();
 251:../../os/rt/include/chvt.h **** 
 252:../../os/rt/include/chvt.h ****   return (bool)(vtp->dlist.next != NULL);
 253:../../os/rt/include/chvt.h **** }
 254:../../os/rt/include/chvt.h **** 
 255:../../os/rt/include/chvt.h **** /**
 256:../../os/rt/include/chvt.h ****  * @brief   Returns @p true if the specified timer is armed.
 257:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 258:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 259:../../os/rt/include/chvt.h ****  *
 260:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 261:../../os/rt/include/chvt.h ****  * @return              true if the timer is armed.
 262:../../os/rt/include/chvt.h ****  *
 263:../../os/rt/include/chvt.h ****  * @api
 264:../../os/rt/include/chvt.h ****  */
 265:../../os/rt/include/chvt.h **** static inline bool chVTIsArmed(const virtual_timer_t *vtp) {
 266:../../os/rt/include/chvt.h ****   bool b;
 267:../../os/rt/include/chvt.h **** 
 268:../../os/rt/include/chvt.h ****   chSysLock();
 269:../../os/rt/include/chvt.h ****   b = chVTIsArmedI(vtp);
 270:../../os/rt/include/chvt.h ****   chSysUnlock();
 271:../../os/rt/include/chvt.h **** 
 272:../../os/rt/include/chvt.h ****   return b;
 273:../../os/rt/include/chvt.h **** }
 274:../../os/rt/include/chvt.h **** 
 275:../../os/rt/include/chvt.h **** /**
 276:../../os/rt/include/chvt.h ****  * @brief   Disables a Virtual Timer.
 277:../../os/rt/include/chvt.h ****  * @note    The timer is first checked and disabled only if armed.
 278:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 279:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 280:../../os/rt/include/chvt.h ****  *
 281:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 282:../../os/rt/include/chvt.h ****  *
 283:../../os/rt/include/chvt.h ****  * @iclass
 284:../../os/rt/include/chvt.h ****  */
 285:../../os/rt/include/chvt.h **** static inline void chVTResetI(virtual_timer_t *vtp) {
 286:../../os/rt/include/chvt.h **** 
 287:../../os/rt/include/chvt.h ****   if (chVTIsArmedI(vtp)) {
  52               		.loc 2 287 0
  53 0012 8881      		ld r24,Y
  54 0014 9981      		ldd r25,Y+1
  55 0016 892B      		or r24,r25
  56 0018 01F0      		breq .L2
 288:../../os/rt/include/chvt.h ****     chVTDoResetI(vtp);
  57               		.loc 2 288 0
  58 001a CE01      		movw r24,r28
  59 001c 0E94 0000 		call chVTDoResetI
  60               	.LVL3:
  61               	.L2:
  62               	.LBE46:
  63               	.LBE45:
 289:../../os/rt/include/chvt.h ****   }
 290:../../os/rt/include/chvt.h **** }
 291:../../os/rt/include/chvt.h **** 
 292:../../os/rt/include/chvt.h **** /**
 293:../../os/rt/include/chvt.h ****  * @brief   Disables a Virtual Timer.
 294:../../os/rt/include/chvt.h ****  * @note    The timer is first checked and disabled only if armed.
 295:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 296:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 297:../../os/rt/include/chvt.h ****  *
 298:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 299:../../os/rt/include/chvt.h ****  *
 300:../../os/rt/include/chvt.h ****  * @api
 301:../../os/rt/include/chvt.h ****  */
 302:../../os/rt/include/chvt.h **** static inline void chVTReset(virtual_timer_t *vtp) {
 303:../../os/rt/include/chvt.h **** 
 304:../../os/rt/include/chvt.h ****   chSysLock();
 305:../../os/rt/include/chvt.h ****   chVTResetI(vtp);
 306:../../os/rt/include/chvt.h ****   chSysUnlock();
 307:../../os/rt/include/chvt.h **** }
 308:../../os/rt/include/chvt.h **** 
 309:../../os/rt/include/chvt.h **** /**
 310:../../os/rt/include/chvt.h ****  * @brief   Enables a one-shot virtual timer.
 311:../../os/rt/include/chvt.h ****  * @details If the virtual timer was already enabled then it is re-enabled
 312:../../os/rt/include/chvt.h ****  *          using the new parameters.
 313:../../os/rt/include/chvt.h ****  * @pre     The timer must have been initialized using @p chVTObjectInit()
 314:../../os/rt/include/chvt.h ****  *          or @p chVTDoSetI().
 315:../../os/rt/include/chvt.h ****  *
 316:../../os/rt/include/chvt.h ****  * @param[in] vtp       the @p virtual_timer_t structure pointer
 317:../../os/rt/include/chvt.h ****  * @param[in] delay     the number of ticks before the operation timeouts, the
 318:../../os/rt/include/chvt.h ****  *                      special values are handled as follow:
 319:../../os/rt/include/chvt.h ****  *                      - @a TIME_INFINITE is allowed but interpreted as a
 320:../../os/rt/include/chvt.h ****  *                        normal time specification.
 321:../../os/rt/include/chvt.h ****  *                      - @a TIME_IMMEDIATE this value is not allowed.
 322:../../os/rt/include/chvt.h ****  *                      .
 323:../../os/rt/include/chvt.h ****  * @param[in] vtfunc    the timer callback function. After invoking the
 324:../../os/rt/include/chvt.h ****  *                      callback the timer is disabled and the structure can
 325:../../os/rt/include/chvt.h ****  *                      be disposed or reused.
 326:../../os/rt/include/chvt.h ****  * @param[in] par       a parameter that will be passed to the callback
 327:../../os/rt/include/chvt.h ****  *                      function
 328:../../os/rt/include/chvt.h ****  *
 329:../../os/rt/include/chvt.h ****  * @iclass
 330:../../os/rt/include/chvt.h ****  */
 331:../../os/rt/include/chvt.h **** static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
 332:../../os/rt/include/chvt.h ****                             vtfunc_t vtfunc, void *par) {
 333:../../os/rt/include/chvt.h **** 
 334:../../os/rt/include/chvt.h ****   chVTResetI(vtp);
 335:../../os/rt/include/chvt.h ****   chVTDoSetI(vtp, delay, vtfunc, par);
  64               		.loc 2 335 0
  65 0020 8E01      		movw r16,r28
  66 0022 20E0      		ldi r18,lo8(gs(vt_cb))
  67 0024 30E0      		ldi r19,hi8(gs(vt_cb))
  68 0026 48E2      		ldi r20,lo8(40)
  69 0028 51E3      		ldi r21,lo8(49)
  70 002a 61E0      		ldi r22,lo8(1)
  71 002c 70E0      		ldi r23,0
  72 002e CE01      		movw r24,r28
  73 0030 0E94 0000 		call chVTDoSetI
  74               	.LVL4:
  75               	/* epilogue start */
  76               	.LBE44:
  77               	.LBE43:
 256:main.c        ****   chVTSetI((virtual_timer_t *)arg, TIME_MS2I(LED_PERIODO / 2), (vtfunc_t)vt_cb, arg);
 257:main.c        ****   chSysUnlockFromISR();
 258:main.c        **** }
  78               		.loc 1 258 0
  79 0034 DF91      		pop r29
  80 0036 CF91      		pop r28
  81               	.LVL5:
  82 0038 1F91      		pop r17
  83 003a 0F91      		pop r16
  84               	.LVL6:
  85 003c 0895      		ret
  86               		.cfi_endproc
  87               	.LFE249:
  89               		.section	.text.queueInit,"ax",@progbits
  90               	.global	queueInit
  92               	queueInit:
  93               	.LFB245:
 179:main.c        ****  
  94               		.loc 1 179 0
  95               		.cfi_startproc
  96               	/* prologue: function */
  97               	/* frame size = 0 */
  98               	/* stack size = 0 */
  99               	.L__stack_usage = 0
 181:main.c        ****   chCondObjectInit(&qempty);
 100               		.loc 1 181 0
 101 0000 80E0      		ldi r24,lo8(qmtx)
 102 0002 90E0      		ldi r25,hi8(qmtx)
 103 0004 0E94 0000 		call chMtxObjectInit
 104               	.LVL7:
 182:main.c        ****   chCondObjectInit(&qfull);
 105               		.loc 1 182 0
 106 0008 80E0      		ldi r24,lo8(qempty)
 107 000a 90E0      		ldi r25,hi8(qempty)
 108 000c 0E94 0000 		call chCondObjectInit
 109               	.LVL8:
 183:main.c        ****  
 110               		.loc 1 183 0
 111 0010 80E0      		ldi r24,lo8(qfull)
 112 0012 90E0      		ldi r25,hi8(qfull)
 113 0014 0E94 0000 		call chCondObjectInit
 114               	.LVL9:
 185:main.c        ****   qsize = 0;
 115               		.loc 1 185 0
 116 0018 80E0      		ldi r24,lo8(queue)
 117 001a 90E0      		ldi r25,hi8(queue)
 118 001c 9093 0000 		sts wrp+1,r25
 119 0020 8093 0000 		sts wrp,r24
 120 0024 9093 0000 		sts rdp+1,r25
 121 0028 8093 0000 		sts rdp,r24
 186:main.c        **** }
 122               		.loc 1 186 0
 123 002c 1092 0000 		sts qsize+1,__zero_reg__
 124 0030 1092 0000 		sts qsize,__zero_reg__
 125               	/* epilogue start */
 187:main.c        **** 
 126               		.loc 1 187 0
 127 0034 0895      		ret
 128               		.cfi_endproc
 129               	.LFE245:
 131               		.section	.text.enqueue,"ax",@progbits
 132               	.global	enqueue
 134               	enqueue:
 135               	.LFB246:
 193:main.c        ****  
 136               		.loc 1 193 0
 137               		.cfi_startproc
 138               	.LVL10:
 139 0000 CF93      		push r28
 140               	.LCFI4:
 141               		.cfi_def_cfa_offset 3
 142               		.cfi_offset 28, -2
 143 0002 DF93      		push r29
 144               	.LCFI5:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 29, -3
 147               	/* prologue: function */
 148               	/* frame size = 0 */
 149               	/* stack size = 2 */
 150               	.L__stack_usage = 2
 151 0004 EC01      		movw r28,r24
 196:main.c        ****  
 152               		.loc 1 196 0
 153 0006 80E0      		ldi r24,lo8(qmtx)
 154 0008 90E0      		ldi r25,hi8(qmtx)
 155               	.LVL11:
 156 000a 0E94 0000 		call chMtxLock
 157               	.LVL12:
 199:main.c        ****     chCondWait(&qfull);
 158               		.loc 1 199 0
 159 000e 8091 0000 		lds r24,qsize
 160 0012 9091 0000 		lds r25,qsize+1
 161 0016 8038      		cpi r24,-128
 162 0018 9105      		cpc r25,__zero_reg__
 163 001a 00F0      		brlo .L9
 164               	.L10:
 200:main.c        ****  
 165               		.loc 1 200 0
 166 001c 80E0      		ldi r24,lo8(qfull)
 167 001e 90E0      		ldi r25,hi8(qfull)
 168 0020 0E94 0000 		call chCondWait
 169               	.LVL13:
 199:main.c        ****     chCondWait(&qfull);
 170               		.loc 1 199 0
 171 0024 8091 0000 		lds r24,qsize
 172 0028 9091 0000 		lds r25,qsize+1
 173 002c 8038      		cpi r24,-128
 174 002e 9105      		cpc r25,__zero_reg__
 175 0030 00F4      		brsh .L10
 176               	.L9:
 203:main.c        ****   if (++wrp >= &queue[QUEUE_SIZE])
 177               		.loc 1 203 0
 178 0032 E091 0000 		lds r30,wrp
 179 0036 F091 0000 		lds r31,wrp+1
 180 003a C193      		st Z+,r28
 181 003c D193      		st Z+,r29
 204:main.c        ****     wrp = &queue[0];
 182               		.loc 1 204 0
 183 003e 20E0      		ldi r18,hi8(queue+256)
 184 0040 E030      		cpi r30,lo8(queue+256)
 185 0042 F207      		cpc r31,r18
 186 0044 00F0      		brlo .L14
 205:main.c        ****   qsize++;
 187               		.loc 1 205 0
 188 0046 20E0      		ldi r18,lo8(queue)
 189 0048 30E0      		ldi r19,hi8(queue)
 190 004a 3093 0000 		sts wrp+1,r19
 191 004e 2093 0000 		sts wrp,r18
 192               	.L12:
 206:main.c        ****  
 193               		.loc 1 206 0
 194 0052 0196      		adiw r24,1
 195 0054 9093 0000 		sts qsize+1,r25
 196 0058 8093 0000 		sts qsize,r24
 209:main.c        ****  
 197               		.loc 1 209 0
 198 005c 80E0      		ldi r24,lo8(qempty)
 199 005e 90E0      		ldi r25,hi8(qempty)
 200 0060 0E94 0000 		call chCondSignal
 201               	.LVL14:
 212:main.c        **** }
 202               		.loc 1 212 0
 203 0064 80E0      		ldi r24,lo8(qmtx)
 204 0066 90E0      		ldi r25,hi8(qmtx)
 205               	/* epilogue start */
 213:main.c        **** 
 206               		.loc 1 213 0
 207 0068 DF91      		pop r29
 208 006a CF91      		pop r28
 209               	.LVL15:
 212:main.c        **** }
 210               		.loc 1 212 0
 211 006c 0C94 0000 		jmp chMtxUnlock
 212               	.LVL16:
 213               	.L14:
 204:main.c        ****     wrp = &queue[0];
 214               		.loc 1 204 0
 215 0070 F093 0000 		sts wrp+1,r31
 216 0074 E093 0000 		sts wrp,r30
 217 0078 00C0      		rjmp .L12
 218               		.cfi_endproc
 219               	.LFE246:
 221               		.section	.text.dequeue,"ax",@progbits
 222               	.global	dequeue
 224               	dequeue:
 225               	.LFB247:
 219:main.c        ****   msg_t msg;
 226               		.loc 1 219 0
 227               		.cfi_startproc
 228 0000 CF93      		push r28
 229               	.LCFI6:
 230               		.cfi_def_cfa_offset 3
 231               		.cfi_offset 28, -2
 232 0002 DF93      		push r29
 233               	.LCFI7:
 234               		.cfi_def_cfa_offset 4
 235               		.cfi_offset 29, -3
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 2 */
 239               	.L__stack_usage = 2
 223:main.c        ****  
 240               		.loc 1 223 0
 241 0004 80E0      		ldi r24,lo8(qmtx)
 242 0006 90E0      		ldi r25,hi8(qmtx)
 243 0008 0E94 0000 		call chMtxLock
 244               	.LVL17:
 226:main.c        ****     chCondWait(&qempty);
 245               		.loc 1 226 0
 246 000c 8091 0000 		lds r24,qsize
 247 0010 9091 0000 		lds r25,qsize+1
 248 0014 0097      		sbiw r24,0
 249 0016 01F4      		brne .L16
 250               	.L17:
 227:main.c        ****  
 251               		.loc 1 227 0
 252 0018 80E0      		ldi r24,lo8(qempty)
 253 001a 90E0      		ldi r25,hi8(qempty)
 254 001c 0E94 0000 		call chCondWait
 255               	.LVL18:
 226:main.c        ****     chCondWait(&qempty);
 256               		.loc 1 226 0
 257 0020 8091 0000 		lds r24,qsize
 258 0024 9091 0000 		lds r25,qsize+1
 259 0028 0097      		sbiw r24,0
 260 002a 01F0      		breq .L17
 261               	.L16:
 230:main.c        ****   if (++rdp >= &queue[QUEUE_SIZE])
 262               		.loc 1 230 0
 263 002c E091 0000 		lds r30,rdp
 264 0030 F091 0000 		lds r31,rdp+1
 265 0034 C191      		ld r28,Z+
 266 0036 D191      		ld r29,Z+
 267               	.LVL19:
 231:main.c        ****     rdp = &queue[0];
 268               		.loc 1 231 0
 269 0038 20E0      		ldi r18,hi8(queue+256)
 270 003a E030      		cpi r30,lo8(queue+256)
 271 003c F207      		cpc r31,r18
 272 003e 00F0      		brlo .L22
 232:main.c        ****   qsize--;
 273               		.loc 1 232 0
 274 0040 20E0      		ldi r18,lo8(queue)
 275 0042 30E0      		ldi r19,hi8(queue)
 276 0044 3093 0000 		sts rdp+1,r19
 277 0048 2093 0000 		sts rdp,r18
 278               	.L19:
 233:main.c        ****  
 279               		.loc 1 233 0
 280 004c 0197      		sbiw r24,1
 281 004e 9093 0000 		sts qsize+1,r25
 282 0052 8093 0000 		sts qsize,r24
 236:main.c        ****  
 283               		.loc 1 236 0
 284 0056 80E0      		ldi r24,lo8(qfull)
 285 0058 90E0      		ldi r25,hi8(qfull)
 286 005a 0E94 0000 		call chCondSignal
 287               	.LVL20:
 239:main.c        ****  
 288               		.loc 1 239 0
 289 005e 80E0      		ldi r24,lo8(qmtx)
 290 0060 90E0      		ldi r25,hi8(qmtx)
 291 0062 0E94 0000 		call chMtxUnlock
 292               	.LVL21:
 242:main.c        **** 
 293               		.loc 1 242 0
 294 0066 CE01      		movw r24,r28
 295               	/* epilogue start */
 296 0068 DF91      		pop r29
 297 006a CF91      		pop r28
 298               	.LVL22:
 299 006c 0895      		ret
 300               	.LVL23:
 301               	.L22:
 231:main.c        ****     rdp = &queue[0];
 302               		.loc 1 231 0
 303 006e F093 0000 		sts rdp+1,r31
 304 0072 E093 0000 		sts rdp,r30
 305 0076 00C0      		rjmp .L19
 306               		.cfi_endproc
 307               	.LFE247:
 309               		.section	.text.Thread1,"ax",@progbits
 311               	Thread1:
 312               	.LFB243:
  81:main.c        ****   virtual_timer_t vt;
 313               		.loc 1 81 0
 314               		.cfi_startproc
 315               	.LVL24:
 316 0000 CF93      		push r28
 317               	.LCFI8:
 318               		.cfi_def_cfa_offset 3
 319               		.cfi_offset 28, -2
 320 0002 DF93      		push r29
 321               	.LCFI9:
 322               		.cfi_def_cfa_offset 4
 323               		.cfi_offset 29, -3
 324 0004 CDB7      		in r28,__SP_L__
 325 0006 DEB7      		in r29,__SP_H__
 326               	.LCFI10:
 327               		.cfi_def_cfa_register 28
 328 0008 6097      		sbiw r28,16
 329               	.LCFI11:
 330               		.cfi_def_cfa_offset 20
 331 000a 0FB6      		in __tmp_reg__,__SREG__
 332 000c F894      		cli
 333 000e DEBF      		out __SP_H__,r29
 334 0010 0FBE      		out __SREG__,__tmp_reg__
 335 0012 CDBF      		out __SP_L__,r28
 336               	/* prologue: function */
 337               	/* frame size = 16 */
 338               	/* stack size = 18 */
 339               	.L__stack_usage = 18
 340               	.LVL25:
 341               	.LBB62:
 342               	.LBB63:
 106:../../os/rt/include/chvt.h **** }
 343               		.loc 2 106 0
 344 0014 1A82      		std Y+2,__zero_reg__
 345 0016 1982      		std Y+1,__zero_reg__
 346               	.LVL26:
 347               	.LBE63:
 348               	.LBE62:
 349               	.LBB64:
 350               	.LBB65:
 351               	.LBB66:
 352               	.LBB67:
 353               		.file 3 "../../os/common/ports/AVR/chcore.h"
   1:../../os/common/ports/AVR/chcore.h **** /*
   2:../../os/common/ports/AVR/chcore.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/common/ports/AVR/chcore.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/common/ports/AVR/chcore.h **** 
   5:../../os/common/ports/AVR/chcore.h ****     This file is part of ChibiOS.
   6:../../os/common/ports/AVR/chcore.h **** 
   7:../../os/common/ports/AVR/chcore.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/common/ports/AVR/chcore.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/common/ports/AVR/chcore.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/common/ports/AVR/chcore.h **** 
  11:../../os/common/ports/AVR/chcore.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/common/ports/AVR/chcore.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/common/ports/AVR/chcore.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/common/ports/AVR/chcore.h ****     GNU General Public License for more details.
  15:../../os/common/ports/AVR/chcore.h **** 
  16:../../os/common/ports/AVR/chcore.h ****     You should have received a copy of the GNU General Public License
  17:../../os/common/ports/AVR/chcore.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/common/ports/AVR/chcore.h **** */
  19:../../os/common/ports/AVR/chcore.h **** 
  20:../../os/common/ports/AVR/chcore.h **** /**
  21:../../os/common/ports/AVR/chcore.h ****  * @file    chcore.h
  22:../../os/common/ports/AVR/chcore.h ****  * @brief   AVR port macros and structures.
  23:../../os/common/ports/AVR/chcore.h ****  *
  24:../../os/common/ports/AVR/chcore.h ****  * @addtogroup AVR_CORE
  25:../../os/common/ports/AVR/chcore.h ****  * @{
  26:../../os/common/ports/AVR/chcore.h ****  */
  27:../../os/common/ports/AVR/chcore.h **** 
  28:../../os/common/ports/AVR/chcore.h **** #ifndef CHCORE_H
  29:../../os/common/ports/AVR/chcore.h **** #define CHCORE_H
  30:../../os/common/ports/AVR/chcore.h **** 
  31:../../os/common/ports/AVR/chcore.h **** #include <avr/io.h>
  32:../../os/common/ports/AVR/chcore.h **** #include <avr/interrupt.h>
  33:../../os/common/ports/AVR/chcore.h **** 
  34:../../os/common/ports/AVR/chcore.h **** extern bool __avr_in_isr;
  35:../../os/common/ports/AVR/chcore.h **** 
  36:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  37:../../os/common/ports/AVR/chcore.h **** /* Module constants.                                                         */
  38:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  39:../../os/common/ports/AVR/chcore.h **** 
  40:../../os/common/ports/AVR/chcore.h **** /**
  41:../../os/common/ports/AVR/chcore.h ****  * @name    Port Capabilities and Constants
  42:../../os/common/ports/AVR/chcore.h ****  * @{
  43:../../os/common/ports/AVR/chcore.h ****  */
  44:../../os/common/ports/AVR/chcore.h **** /**
  45:../../os/common/ports/AVR/chcore.h ****  * @brief   This port supports a realtime counter.
  46:../../os/common/ports/AVR/chcore.h ****  */
  47:../../os/common/ports/AVR/chcore.h **** #define PORT_SUPPORTS_RT                FALSE
  48:../../os/common/ports/AVR/chcore.h **** 
  49:../../os/common/ports/AVR/chcore.h **** /**
  50:../../os/common/ports/AVR/chcore.h ****  * @brief   Natural alignment constant.
  51:../../os/common/ports/AVR/chcore.h ****  * @note    It is the minimum alignment for pointer-size variables.
  52:../../os/common/ports/AVR/chcore.h ****  */
  53:../../os/common/ports/AVR/chcore.h **** #define PORT_NATURAL_ALIGN              1U
  54:../../os/common/ports/AVR/chcore.h **** 
  55:../../os/common/ports/AVR/chcore.h **** /**
  56:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack alignment constant.
  57:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment required for the stack pointer.
  58:../../os/common/ports/AVR/chcore.h ****  */
  59:../../os/common/ports/AVR/chcore.h **** #define PORT_STACK_ALIGN                1U
  60:../../os/common/ports/AVR/chcore.h **** 
  61:../../os/common/ports/AVR/chcore.h **** /**
  62:../../os/common/ports/AVR/chcore.h ****  * @brief   Working Areas alignment constant.
  63:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment to be enforced for thread working areas.
  64:../../os/common/ports/AVR/chcore.h ****  */
  65:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA_ALIGN         1U
  66:../../os/common/ports/AVR/chcore.h **** /** @} */
  67:../../os/common/ports/AVR/chcore.h **** 
  68:../../os/common/ports/AVR/chcore.h **** /**
  69:../../os/common/ports/AVR/chcore.h ****  * @name    Architecture and Compiler
  70:../../os/common/ports/AVR/chcore.h ****  * @{
  71:../../os/common/ports/AVR/chcore.h ****  */
  72:../../os/common/ports/AVR/chcore.h **** /**
  73:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining an AVR architecture.
  74:../../os/common/ports/AVR/chcore.h ****  */
  75:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR
  76:../../os/common/ports/AVR/chcore.h **** 
  77:../../os/common/ports/AVR/chcore.h **** /**
  78:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining the specific AVR architecture.
  79:../../os/common/ports/AVR/chcore.h ****  */
  80:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR_MEGAAVR
  81:../../os/common/ports/AVR/chcore.h **** 
  82:../../os/common/ports/AVR/chcore.h **** /**
  83:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the implemented architecture.
  84:../../os/common/ports/AVR/chcore.h ****  */
  85:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_NAME          "AVR"
  86:../../os/common/ports/AVR/chcore.h **** 
  87:../../os/common/ports/AVR/chcore.h **** /**
  88:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the architecture variant.
  89:../../os/common/ports/AVR/chcore.h ****  */
  90:../../os/common/ports/AVR/chcore.h **** #define PORT_CORE_VARIANT_NAME          "MegaAVR"
  91:../../os/common/ports/AVR/chcore.h **** 
  92:../../os/common/ports/AVR/chcore.h **** /**
  93:../../os/common/ports/AVR/chcore.h ****  * @brief   Compiler name and version.
  94:../../os/common/ports/AVR/chcore.h ****  */
  95:../../os/common/ports/AVR/chcore.h **** #if defined(__GNUC__) || defined(__DOXYGEN__)
  96:../../os/common/ports/AVR/chcore.h **** #define PORT_COMPILER_NAME              "GCC " __VERSION__
  97:../../os/common/ports/AVR/chcore.h **** 
  98:../../os/common/ports/AVR/chcore.h **** #else
  99:../../os/common/ports/AVR/chcore.h **** #error "unsupported compiler"
 100:../../os/common/ports/AVR/chcore.h **** #endif
 101:../../os/common/ports/AVR/chcore.h **** 
 102:../../os/common/ports/AVR/chcore.h **** /**
 103:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-specific information string.
 104:../../os/common/ports/AVR/chcore.h ****  */
 105:../../os/common/ports/AVR/chcore.h **** #define PORT_INFO                       "None"
 106:../../os/common/ports/AVR/chcore.h **** /** @} */
 107:../../os/common/ports/AVR/chcore.h **** 
 108:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 109:../../os/common/ports/AVR/chcore.h **** /* Module pre-compile time settings.                                         */
 110:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 111:../../os/common/ports/AVR/chcore.h **** 
 112:../../os/common/ports/AVR/chcore.h **** /**
 113:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack size for the system idle thread.
 114:../../os/common/ports/AVR/chcore.h ****  * @details This size depends on the idle thread implementation, usually
 115:../../os/common/ports/AVR/chcore.h ****  *          the idle thread should take no more space than those reserved
 116:../../os/common/ports/AVR/chcore.h ****  *          by @p PORT_INT_REQUIRED_STACK.
 117:../../os/common/ports/AVR/chcore.h ****  */
 118:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_IDLE_THREAD_STACK_SIZE) || defined(__DOXYGEN__)
 119:../../os/common/ports/AVR/chcore.h **** #define PORT_IDLE_THREAD_STACK_SIZE     8
 120:../../os/common/ports/AVR/chcore.h **** #endif
 121:../../os/common/ports/AVR/chcore.h **** 
 122:../../os/common/ports/AVR/chcore.h **** /**
 123:../../os/common/ports/AVR/chcore.h ****  * @brief   Per-thread stack overhead for interrupts servicing.
 124:../../os/common/ports/AVR/chcore.h ****  * @details This constant is used in the calculation of the correct working
 125:../../os/common/ports/AVR/chcore.h ****  *          area size.
 126:../../os/common/ports/AVR/chcore.h ****  */
 127:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_INT_REQUIRED_STACK) || defined(__DOXYGEN__)
 128:../../os/common/ports/AVR/chcore.h **** #define PORT_INT_REQUIRED_STACK         32
 129:../../os/common/ports/AVR/chcore.h **** #endif
 130:../../os/common/ports/AVR/chcore.h **** 
 131:../../os/common/ports/AVR/chcore.h **** /**
 132:../../os/common/ports/AVR/chcore.h ****  * @brief   Enables a "wait for interrupt" instruction in the idle loop.
 133:../../os/common/ports/AVR/chcore.h ****  */
 134:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_AVR_WFI_SLEEP_IDLE) || defined(__DOXYGEN__)
 135:../../os/common/ports/AVR/chcore.h **** #define PORT_AVR_WFI_SLEEP_IDLE      FALSE
 136:../../os/common/ports/AVR/chcore.h **** #endif
 137:../../os/common/ports/AVR/chcore.h **** 
 138:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 139:../../os/common/ports/AVR/chcore.h **** /* Derived constants and error checks.                                       */
 140:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 141:../../os/common/ports/AVR/chcore.h **** 
 142:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 143:../../os/common/ports/AVR/chcore.h **** /* Module data structures and types.                                         */
 144:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 145:../../os/common/ports/AVR/chcore.h **** 
 146:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 147:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 148:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 149:../../os/common/ports/AVR/chcore.h **** 
 150:../../os/common/ports/AVR/chcore.h **** /**
 151:../../os/common/ports/AVR/chcore.h ****  * @brief   Type of stack and memory alignment enforcement.
 152:../../os/common/ports/AVR/chcore.h ****  * @note    In this architecture the stack alignment is enforced to 8 bits.
 153:../../os/common/ports/AVR/chcore.h ****  */
 154:../../os/common/ports/AVR/chcore.h **** typedef uint8_t stkalign_t;
 155:../../os/common/ports/AVR/chcore.h **** 
 156:../../os/common/ports/AVR/chcore.h **** /**
 157:../../os/common/ports/AVR/chcore.h ****  * @brief   Interrupt saved context.
 158:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the stack frame saved during a
 159:../../os/common/ports/AVR/chcore.h ****  *          preemption-capable interrupt handler.
 160:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 161:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 162:../../os/common/ports/AVR/chcore.h ****  */
 163:../../os/common/ports/AVR/chcore.h **** struct port_extctx {
 164:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 165:../../os/common/ports/AVR/chcore.h ****   uint8_t       r31;
 166:../../os/common/ports/AVR/chcore.h ****   uint8_t       r30;
 167:../../os/common/ports/AVR/chcore.h ****   uint8_t       r27;
 168:../../os/common/ports/AVR/chcore.h ****   uint8_t       r26;
 169:../../os/common/ports/AVR/chcore.h ****   uint8_t       r25;
 170:../../os/common/ports/AVR/chcore.h ****   uint8_t       r24;
 171:../../os/common/ports/AVR/chcore.h ****   uint8_t       r23;
 172:../../os/common/ports/AVR/chcore.h ****   uint8_t       r22;
 173:../../os/common/ports/AVR/chcore.h ****   uint8_t       r21;
 174:../../os/common/ports/AVR/chcore.h ****   uint8_t       r20;
 175:../../os/common/ports/AVR/chcore.h ****   uint8_t       r19;
 176:../../os/common/ports/AVR/chcore.h ****   uint8_t       r18;
 177:../../os/common/ports/AVR/chcore.h ****   uint8_t       sr;
 178:../../os/common/ports/AVR/chcore.h ****   uint8_t       r1;
 179:../../os/common/ports/AVR/chcore.h ****   uint8_t       r0;
 180:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 181:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 182:../../os/common/ports/AVR/chcore.h **** #endif
 183:../../os/common/ports/AVR/chcore.h ****   uint16_t      pc;
 184:../../os/common/ports/AVR/chcore.h **** };
 185:../../os/common/ports/AVR/chcore.h **** 
 186:../../os/common/ports/AVR/chcore.h **** /**
 187:../../os/common/ports/AVR/chcore.h ****  * @brief   System saved context.
 188:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the inner stack frame during a context
 189:../../os/common/ports/AVR/chcore.h ****  *          switching.
 190:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 191:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 192:../../os/common/ports/AVR/chcore.h ****  * @note    LR is stored in the caller context so it is not present in this
 193:../../os/common/ports/AVR/chcore.h ****  *          structure.
 194:../../os/common/ports/AVR/chcore.h ****  */
 195:../../os/common/ports/AVR/chcore.h **** struct port_intctx {
 196:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 197:../../os/common/ports/AVR/chcore.h ****   uint8_t       r29;
 198:../../os/common/ports/AVR/chcore.h ****   uint8_t       r28;
 199:../../os/common/ports/AVR/chcore.h ****   uint8_t       r17;
 200:../../os/common/ports/AVR/chcore.h ****   uint8_t       r16;
 201:../../os/common/ports/AVR/chcore.h ****   uint8_t       r15;
 202:../../os/common/ports/AVR/chcore.h ****   uint8_t       r14;
 203:../../os/common/ports/AVR/chcore.h ****   uint8_t       r13;
 204:../../os/common/ports/AVR/chcore.h ****   uint8_t       r12;
 205:../../os/common/ports/AVR/chcore.h ****   uint8_t       r11;
 206:../../os/common/ports/AVR/chcore.h ****   uint8_t       r10;
 207:../../os/common/ports/AVR/chcore.h ****   uint8_t       r9;
 208:../../os/common/ports/AVR/chcore.h ****   uint8_t       r8;
 209:../../os/common/ports/AVR/chcore.h ****   uint8_t       r7;
 210:../../os/common/ports/AVR/chcore.h ****   uint8_t       r6;
 211:../../os/common/ports/AVR/chcore.h ****   uint8_t       r5;
 212:../../os/common/ports/AVR/chcore.h ****   uint8_t       r4;
 213:../../os/common/ports/AVR/chcore.h ****   uint8_t       r3;
 214:../../os/common/ports/AVR/chcore.h ****   uint8_t       r2;
 215:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 216:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 217:../../os/common/ports/AVR/chcore.h **** #endif
 218:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcl;
 219:../../os/common/ports/AVR/chcore.h ****   uint8_t       pch;
 220:../../os/common/ports/AVR/chcore.h **** };
 221:../../os/common/ports/AVR/chcore.h **** 
 222:../../os/common/ports/AVR/chcore.h **** /**
 223:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p thread_t structure.
 224:../../os/common/ports/AVR/chcore.h ****  * @details This structure usually contains just the saved stack pointer
 225:../../os/common/ports/AVR/chcore.h ****  *          defined as a pointer to a @p port_intctx structure.
 226:../../os/common/ports/AVR/chcore.h ****  */
 227:../../os/common/ports/AVR/chcore.h **** struct port_context {
 228:../../os/common/ports/AVR/chcore.h ****   struct port_intctx *sp;
 229:../../os/common/ports/AVR/chcore.h **** };
 230:../../os/common/ports/AVR/chcore.h **** 
 231:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 232:../../os/common/ports/AVR/chcore.h **** 
 233:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 234:../../os/common/ports/AVR/chcore.h **** /* Module macros.                                                            */
 235:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 236:../../os/common/ports/AVR/chcore.h **** 
 237:../../os/common/ports/AVR/chcore.h **** /**
 238:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p chThdCreateI() API.
 239:../../os/common/ports/AVR/chcore.h ****  * @details This code usually setup the context switching frame represented
 240:../../os/common/ports/AVR/chcore.h ****  *          by an @p port_intctx structure.
 241:../../os/common/ports/AVR/chcore.h ****  */
 242:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__) || defined(__DOXYGEN__)
 243:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 244:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 245:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 246:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 247:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 248:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 249:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 250:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcx = (uint8_t)0;                                             \
 251:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 252:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 253:../../os/common/ports/AVR/chcore.h **** }
 254:../../os/common/ports/AVR/chcore.h **** #else /* !__AVR_3_BYTE_PC__ */
 255:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 256:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 257:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 258:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 259:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 260:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 261:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 262:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 263:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 264:../../os/common/ports/AVR/chcore.h **** }
 265:../../os/common/ports/AVR/chcore.h **** #endif /* !__AVR_3_BYTE_PC__ */
 266:../../os/common/ports/AVR/chcore.h **** 
 267:../../os/common/ports/AVR/chcore.h **** /**
 268:../../os/common/ports/AVR/chcore.h ****  * @brief   Computes the thread working area global size.
 269:../../os/common/ports/AVR/chcore.h ****  * @note    There is no need to perform alignments in this macro.
 270:../../os/common/ports/AVR/chcore.h ****  */
 271:../../os/common/ports/AVR/chcore.h **** #define PORT_WA_SIZE(n) ((sizeof(struct port_intctx) - 1) +                \
 272:../../os/common/ports/AVR/chcore.h ****                          (sizeof(struct port_extctx) - 1) +                \
 273:../../os/common/ports/AVR/chcore.h ****                          ((size_t)(n)) + ((size_t)(PORT_INT_REQUIRED_STACK)))
 274:../../os/common/ports/AVR/chcore.h **** 
 275:../../os/common/ports/AVR/chcore.h **** /**
 276:../../os/common/ports/AVR/chcore.h ****  * @brief   Static working area allocation.
 277:../../os/common/ports/AVR/chcore.h ****  * @details This macro is used to allocate a static thread working area
 278:../../os/common/ports/AVR/chcore.h ****  *          aligned as both position and size.
 279:../../os/common/ports/AVR/chcore.h ****  *
 280:../../os/common/ports/AVR/chcore.h ****  * @param[in] s         the name to be assigned to the stack array
 281:../../os/common/ports/AVR/chcore.h ****  * @param[in] n         the stack size to be assigned to the thread
 282:../../os/common/ports/AVR/chcore.h ****  */
 283:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA(s, n)                                             \
 284:../../os/common/ports/AVR/chcore.h ****   stkalign_t s[THD_WORKING_AREA_SIZE(n) / sizeof (stkalign_t)]
 285:../../os/common/ports/AVR/chcore.h **** 
 286:../../os/common/ports/AVR/chcore.h **** /**
 287:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 288:../../os/common/ports/AVR/chcore.h ****  */
 289:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_PRIORITY(n) false
 290:../../os/common/ports/AVR/chcore.h **** 
 291:../../os/common/ports/AVR/chcore.h **** /**
 292:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 293:../../os/common/ports/AVR/chcore.h ****  */
 294:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_KERNEL_PRIORITY(n) false
 295:../../os/common/ports/AVR/chcore.h **** 
 296:../../os/common/ports/AVR/chcore.h **** /**
 297:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ prologue code.
 298:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the start of all IRQ handlers
 299:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 300:../../os/common/ports/AVR/chcore.h ****  * @note    This code tricks the compiler to save all the specified registers
 301:../../os/common/ports/AVR/chcore.h ****  *          by "touching" them.
 302:../../os/common/ports/AVR/chcore.h ****  */
 303:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_PROLOGUE() {                                               \
 304:../../os/common/ports/AVR/chcore.h ****   asm ("" : : : "r18", "r19", "r20", "r21", "r22", "r23", "r24",            \
 305:../../os/common/ports/AVR/chcore.h ****                 "r25", "r26", "r27", "r30", "r31");                         \
 306:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 307:../../os/common/ports/AVR/chcore.h **** }
 308:../../os/common/ports/AVR/chcore.h **** 
 309:../../os/common/ports/AVR/chcore.h **** /**
 310:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ epilogue code.
 311:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the end of all IRQ handlers
 312:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 313:../../os/common/ports/AVR/chcore.h ****  */
 314:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_EPILOGUE() {                                               \
 315:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = false;                                                     \
 316:../../os/common/ports/AVR/chcore.h ****   __dbg_check_lock();                                                       \
 317:../../os/common/ports/AVR/chcore.h ****   if (chSchIsPreemptionRequired())                                          \
 318:../../os/common/ports/AVR/chcore.h ****     chSchDoPreemption();                                                    \
 319:../../os/common/ports/AVR/chcore.h ****   __dbg_check_unlock();                                                     \
 320:../../os/common/ports/AVR/chcore.h **** }
 321:../../os/common/ports/AVR/chcore.h **** 
 322:../../os/common/ports/AVR/chcore.h **** /**
 323:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ handler function declaration.
 324:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 325:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 326:../../os/common/ports/AVR/chcore.h ****  */
 327:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_HANDLER(id) ISR(id)
 328:../../os/common/ports/AVR/chcore.h **** 
 329:../../os/common/ports/AVR/chcore.h **** /**
 330:../../os/common/ports/AVR/chcore.h ****  * @brief   Fast IRQ handler function declaration.
 331:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 332:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 333:../../os/common/ports/AVR/chcore.h ****  */
 334:../../os/common/ports/AVR/chcore.h **** #define PORT_FAST_IRQ_HANDLER(id) ISR(id)
 335:../../os/common/ports/AVR/chcore.h **** 
 336:../../os/common/ports/AVR/chcore.h **** /**
 337:../../os/common/ports/AVR/chcore.h ****  * @brief   Performs a context switch between two threads.
 338:../../os/common/ports/AVR/chcore.h ****  * @details This is the most critical code in any port, this function
 339:../../os/common/ports/AVR/chcore.h ****  *          is responsible for the context switch between 2 threads.
 340:../../os/common/ports/AVR/chcore.h ****  * @note    The implementation of this code affects <b>directly</b> the context
 341:../../os/common/ports/AVR/chcore.h ****  *          switch performance so optimize here as much as you can.
 342:../../os/common/ports/AVR/chcore.h ****  *
 343:../../os/common/ports/AVR/chcore.h ****  * @param[in] ntp       the thread to be switched in
 344:../../os/common/ports/AVR/chcore.h ****  * @param[in] otp       the thread to be switched out
 345:../../os/common/ports/AVR/chcore.h ****  */
 346:../../os/common/ports/AVR/chcore.h **** #define port_switch(ntp, otp) {                                             \
 347:../../os/common/ports/AVR/chcore.h ****   _port_switch(ntp, otp);                                                   \
 348:../../os/common/ports/AVR/chcore.h ****   asm volatile ("" : : : "memory");                                         \
 349:../../os/common/ports/AVR/chcore.h **** }
 350:../../os/common/ports/AVR/chcore.h **** 
 351:../../os/common/ports/AVR/chcore.h **** 
 352:../../os/common/ports/AVR/chcore.h **** /**
 353:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-related initialization code.
 354:../../os/common/ports/AVR/chcore.h ****  * @note    This function is empty in this port.
 355:../../os/common/ports/AVR/chcore.h ****  */
 356:../../os/common/ports/AVR/chcore.h **** #define port_init(oip) {                                                    \
 357:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 358:../../os/common/ports/AVR/chcore.h **** }
 359:../../os/common/ports/AVR/chcore.h **** 
 360:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 361:../../os/common/ports/AVR/chcore.h **** /* External declarations.                                                    */
 362:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 363:../../os/common/ports/AVR/chcore.h **** 
 364:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 365:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 366:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 367:../../os/common/ports/AVR/chcore.h **** 
 368:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 369:../../os/common/ports/AVR/chcore.h **** extern "C" {
 370:../../os/common/ports/AVR/chcore.h **** #endif
 371:../../os/common/ports/AVR/chcore.h ****   void _port_switch(thread_t *ntp, thread_t *otp);
 372:../../os/common/ports/AVR/chcore.h ****   void _port_thread_start(void);
 373:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 374:../../os/common/ports/AVR/chcore.h **** }
 375:../../os/common/ports/AVR/chcore.h **** #endif
 376:../../os/common/ports/AVR/chcore.h **** 
 377:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 378:../../os/common/ports/AVR/chcore.h **** 
 379:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 380:../../os/common/ports/AVR/chcore.h **** /* Module inline functions.                                                  */
 381:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 382:../../os/common/ports/AVR/chcore.h **** 
 383:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 384:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 385:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 386:../../os/common/ports/AVR/chcore.h **** 
 387:../../os/common/ports/AVR/chcore.h **** /**
 388:../../os/common/ports/AVR/chcore.h ****  * @brief   Returns a word encoding the current interrupts status.
 389:../../os/common/ports/AVR/chcore.h ****  *
 390:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupts status.
 391:../../os/common/ports/AVR/chcore.h ****  */
 392:../../os/common/ports/AVR/chcore.h **** static inline syssts_t port_get_irq_status(void) {
 393:../../os/common/ports/AVR/chcore.h **** 
 394:../../os/common/ports/AVR/chcore.h ****   return SREG;
 395:../../os/common/ports/AVR/chcore.h **** }
 396:../../os/common/ports/AVR/chcore.h **** 
 397:../../os/common/ports/AVR/chcore.h **** /**
 398:../../os/common/ports/AVR/chcore.h ****  * @brief   Checks the interrupt status.
 399:../../os/common/ports/AVR/chcore.h ****  *
 400:../../os/common/ports/AVR/chcore.h ****  * @param[in] sts       the interrupt status word
 401:../../os/common/ports/AVR/chcore.h ****  *
 402:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupt status.
 403:../../os/common/ports/AVR/chcore.h ****  * @retval false        the word specified a disabled interrupts status.
 404:../../os/common/ports/AVR/chcore.h ****  * @retval true         the word specified an enabled interrupts status.
 405:../../os/common/ports/AVR/chcore.h ****  */
 406:../../os/common/ports/AVR/chcore.h **** static inline bool port_irq_enabled(syssts_t sts) {
 407:../../os/common/ports/AVR/chcore.h **** 
 408:../../os/common/ports/AVR/chcore.h ****   return (bool)((sts & 0x80) != 0);
 409:../../os/common/ports/AVR/chcore.h **** }
 410:../../os/common/ports/AVR/chcore.h **** 
 411:../../os/common/ports/AVR/chcore.h **** /**
 412:../../os/common/ports/AVR/chcore.h ****  * @brief   Determines the current execution context.
 413:../../os/common/ports/AVR/chcore.h ****  *
 414:../../os/common/ports/AVR/chcore.h ****  * @return              The execution context.
 415:../../os/common/ports/AVR/chcore.h ****  * @retval false        not running in ISR mode.
 416:../../os/common/ports/AVR/chcore.h ****  * @retval true         running in ISR mode.
 417:../../os/common/ports/AVR/chcore.h ****  */
 418:../../os/common/ports/AVR/chcore.h **** static inline bool port_is_isr_context(void) {
 419:../../os/common/ports/AVR/chcore.h **** 
 420:../../os/common/ports/AVR/chcore.h ****   return __avr_in_isr;
 421:../../os/common/ports/AVR/chcore.h **** }
 422:../../os/common/ports/AVR/chcore.h **** 
 423:../../os/common/ports/AVR/chcore.h **** /**
 424:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-lock action.
 425:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just disables interrupts but may perform more
 426:../../os/common/ports/AVR/chcore.h ****  *          actions.
 427:../../os/common/ports/AVR/chcore.h ****  */
 428:../../os/common/ports/AVR/chcore.h **** static inline void port_lock(void) {
 429:../../os/common/ports/AVR/chcore.h **** 
 430:../../os/common/ports/AVR/chcore.h ****   asm volatile ("cli" : : : "memory");
 354               		.loc 3 430 0
 355               	/* #APP */
 356               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 357 0018 F894      		cli
 358               	 ;  0 "" 2
 359               	.LVL27:
 360               	/* #NOAPP */
 361               	.LBE67:
 362               	.LBE66:
 363               	.LBE65:
 364               	.LBB68:
 365               	.LBB69:
 366               	.LBB70:
 367               	.LBB71:
 287:../../os/rt/include/chvt.h ****     chVTDoResetI(vtp);
 368               		.loc 2 287 0
 369 001a 8981      		ldd r24,Y+1
 370 001c 9A81      		ldd r25,Y+2
 371               	.LVL28:
 372 001e 892B      		or r24,r25
 373 0020 01F4      		brne .+2
 374 0022 00C0      		rjmp .L34
 288:../../os/rt/include/chvt.h ****   }
 375               		.loc 2 288 0
 376 0024 FE01      		movw r30,r28
 377 0026 3196      		adiw r30,1
 378 0028 7F01      		movw r14,r30
 379 002a CF01      		movw r24,r30
 380 002c 0E94 0000 		call chVTDoResetI
 381               	.LVL29:
 382               	.L24:
 383               	.LBE71:
 384               	.LBE70:
 385               		.loc 2 335 0
 386 0030 8701      		movw r16,r14
 387 0032 20E0      		ldi r18,lo8(gs(vt_cb))
 388 0034 30E0      		ldi r19,hi8(gs(vt_cb))
 389 0036 48E2      		ldi r20,lo8(40)
 390 0038 51E3      		ldi r21,lo8(49)
 391 003a 61E0      		ldi r22,lo8(1)
 392 003c 70E0      		ldi r23,0
 393 003e C701      		movw r24,r14
 394 0040 0E94 0000 		call chVTDoSetI
 395               	.LVL30:
 396               	.LBE69:
 397               	.LBE68:
 398               	.LBB72:
 399               	.LBB73:
 400               	.LBB74:
 401               	.LBB75:
 431:../../os/common/ports/AVR/chcore.h **** }
 432:../../os/common/ports/AVR/chcore.h **** 
 433:../../os/common/ports/AVR/chcore.h **** /**
 434:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-unlock action.
 435:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just enables interrupts but may perform more
 436:../../os/common/ports/AVR/chcore.h ****  *          actions.
 437:../../os/common/ports/AVR/chcore.h ****  */
 438:../../os/common/ports/AVR/chcore.h **** static inline void port_unlock(void) {
 439:../../os/common/ports/AVR/chcore.h **** 
 440:../../os/common/ports/AVR/chcore.h ****   asm volatile ("sei" : : : "memory");
 402               		.loc 3 440 0
 403               	/* #APP */
 404               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 405 0044 7894      		sei
 406               	 ;  0 "" 2
 407               	/* #NOAPP */
 408               	.LBE75:
 409               	.LBE74:
 410               	.LBE73:
 411               	.LBE72:
 412               	.LBE64:
  98:main.c        ****     }
 413               		.loc 1 98 0
 414 0046 EE24      		clr r14
 415 0048 E394      		inc r14
 416 004a F12C      		mov r15,__zero_reg__
 417 004c 00C0      		rjmp .L29
 418               	.LVL31:
 419               	.L25:
  93:main.c        ****       palToggleLine(SECUNDARIO_VERDE);
 420               		.loc 1 93 0
 421 004e 8430      		cpi r24,4
 422 0050 9105      		cpc r25,__zero_reg__
 423 0052 01F0      		breq .L35
  95:main.c        ****       palSetLine(SECUNDARIO_VERMELHO);
 424               		.loc 1 95 0
 425 0054 8130      		cpi r24,1
 426 0056 9105      		cpc r25,__zero_reg__
 427 0058 01F4      		brne .+2
 428 005a 00C0      		rjmp .L36
  97:main.c        ****       palSetLine(PEDESTRE_VERDE);
 429               		.loc 1 97 0
 430 005c 0297      		sbiw r24,2
 431 005e 01F4      		brne .+2
 432 0060 00C0      		rjmp .L37
 433               	.LVL32:
 434               	.L26:
 100:main.c        ****   }
 435               		.loc 1 100 0
 436 0062 6BE1      		ldi r22,lo8(27)
 437 0064 76E0      		ldi r23,lo8(6)
 438 0066 80E0      		ldi r24,0
 439 0068 90E0      		ldi r25,0
 440 006a 0E94 0000 		call chThdSleep
 441               	.LVL33:
 442               	.L29:
  90:main.c        ****     if (ev == AMB_PRIMARIO){
 443               		.loc 1 90 0
 444 006e 0E94 0000 		call dequeue
 445               	.LVL34:
 446 0072 8C01      		movw r16,r24
 447               	.LVL35:
  91:main.c        ****       palSetLine(PRIMARIO_VERDE);
 448               		.loc 1 91 0
 449 0074 8330      		cpi r24,3
 450 0076 9105      		cpc r25,__zero_reg__
 451 0078 01F4      		brne .L25
  92:main.c        ****     } else if (ev == AMB_SECUNDARIO){
 452               		.loc 1 92 0
 453 007a 67E0      		ldi r22,lo8(7)
 454 007c 89E2      		ldi r24,lo8(41)
 455 007e 90E0      		ldi r25,0
 456 0080 0E94 0000 		call _pal_lld_setlineid
 457               	.LVL36:
 458 0084 0E94 0000 		call _pal_lld_getpadfromline
 459               	.LVL37:
 460 0088 182F      		mov r17,r24
 461 008a 67E0      		ldi r22,lo8(7)
 462 008c 89E2      		ldi r24,lo8(41)
 463 008e 90E0      		ldi r25,0
 464               	.L33:
  98:main.c        ****     }
 465               		.loc 1 98 0
 466 0090 0E94 0000 		call _pal_lld_setlineid
 467               	.LVL38:
 468 0094 0E94 0000 		call _pal_lld_getportfromline
 469               	.LVL39:
 470 0098 FC01      		movw r30,r24
 471 009a 9281      		ldd r25,Z+2
 472 009c 9701      		movw r18,r14
 473 009e 00C0      		rjmp 2f
 474               		1:
 475 00a0 220F      		lsl r18
 476               		2:
 477 00a2 1A95      		dec r17
 478 00a4 02F4      		brpl 1b
 479 00a6 922B      		or r25,r18
 480 00a8 9283      		std Z+2,r25
 481 00aa 00C0      		rjmp .L26
 482               	.L35:
  94:main.c        ****     } else if (ev == SECUNDARIO){
 483               		.loc 1 94 0
 484 00ac 61E0      		ldi r22,lo8(1)
 485 00ae 83E2      		ldi r24,lo8(35)
 486 00b0 90E0      		ldi r25,0
 487 00b2 0E94 0000 		call _pal_lld_setlineid
 488               	.LVL40:
 489 00b6 0E94 0000 		call _pal_lld_getportfromline
 490               	.LVL41:
 491 00ba FC01      		movw r30,r24
 492 00bc 1281      		ldd r17,Z+2
 493 00be 61E0      		ldi r22,lo8(1)
 494 00c0 83E2      		ldi r24,lo8(35)
 495 00c2 90E0      		ldi r25,0
 496 00c4 0E94 0000 		call _pal_lld_setlineid
 497               	.LVL42:
 498 00c8 0E94 0000 		call _pal_lld_getpadfromline
 499               	.LVL43:
 500 00cc 082F      		mov r16,r24
 501               	.LVL44:
 502 00ce 61E0      		ldi r22,lo8(1)
 503 00d0 83E2      		ldi r24,lo8(35)
 504 00d2 90E0      		ldi r25,0
 505 00d4 0E94 0000 		call _pal_lld_setlineid
 506               	.LVL45:
 507 00d8 0E94 0000 		call _pal_lld_getportfromline
 508               	.LVL46:
 509 00dc 9701      		movw r18,r14
 510 00de 00C0      		rjmp 2f
 511               		1:
 512 00e0 220F      		lsl r18
 513               		2:
 514 00e2 0A95      		dec r16
 515 00e4 02F4      		brpl 1b
 516 00e6 1227      		eor r17,r18
 517 00e8 FC01      		movw r30,r24
 518 00ea 1283      		std Z+2,r17
 519 00ec 00C0      		rjmp .L26
 520               	.LVL47:
 521               	.L36:
  96:main.c        ****     } else if (ev == PEDESTRE){
 522               		.loc 1 96 0
 523 00ee 60E0      		ldi r22,0
 524 00f0 83E2      		ldi r24,lo8(35)
 525 00f2 90E0      		ldi r25,0
 526 00f4 0E94 0000 		call _pal_lld_setlineid
 527               	.LVL48:
 528 00f8 0E94 0000 		call _pal_lld_getpadfromline
 529               	.LVL49:
 530 00fc D82E      		mov r13,r24
 531 00fe 60E0      		ldi r22,0
 532 0100 83E2      		ldi r24,lo8(35)
 533 0102 90E0      		ldi r25,0
 534 0104 0E94 0000 		call _pal_lld_setlineid
 535               	.LVL50:
 536 0108 0E94 0000 		call _pal_lld_getportfromline
 537               	.LVL51:
 538 010c FC01      		movw r30,r24
 539 010e 9281      		ldd r25,Z+2
 540 0110 00C0      		rjmp 2f
 541               		1:
 542 0112 000F      		lsl r16
 543               		2:
 544 0114 DA94      		dec r13
 545 0116 02F4      		brpl 1b
 546               	.LVL52:
 547 0118 092B      		or r16,r25
 548 011a 0283      		std Z+2,r16
 549 011c 00C0      		rjmp .L26
 550               	.LVL53:
 551               	.L37:
  98:main.c        ****     }
 552               		.loc 1 98 0
 553 011e 63E0      		ldi r22,lo8(3)
 554 0120 83E2      		ldi r24,lo8(35)
 555 0122 90E0      		ldi r25,0
 556 0124 0E94 0000 		call _pal_lld_setlineid
 557               	.LVL54:
 558 0128 0E94 0000 		call _pal_lld_getpadfromline
 559               	.LVL55:
 560 012c 182F      		mov r17,r24
 561 012e 63E0      		ldi r22,lo8(3)
 562 0130 83E2      		ldi r24,lo8(35)
 563 0132 90E0      		ldi r25,0
 564 0134 00C0      		rjmp .L33
 565               	.LVL56:
 566               	.L34:
 567 0136 CE01      		movw r24,r28
 568 0138 0196      		adiw r24,1
 569 013a 7C01      		movw r14,r24
 570 013c 00C0      		rjmp .L24
 571               		.cfi_endproc
 572               	.LFE243:
 574               		.section	.text.button_check,"ax",@progbits
 575               	.global	button_check
 577               	button_check:
 578               	.LFB248:
 244:main.c        ****   static uint8_t x, w, old_x;
 579               		.loc 1 244 0
 580               		.cfi_startproc
 581               	.LVL57:
 582 0000 CF92      		push r12
 583               	.LCFI12:
 584               		.cfi_def_cfa_offset 3
 585               		.cfi_offset 12, -2
 586 0002 DF92      		push r13
 587               	.LCFI13:
 588               		.cfi_def_cfa_offset 4
 589               		.cfi_offset 13, -3
 590 0004 EF92      		push r14
 591               	.LCFI14:
 592               		.cfi_def_cfa_offset 5
 593               		.cfi_offset 14, -4
 594 0006 CF93      		push r28
 595               	.LCFI15:
 596               		.cfi_def_cfa_offset 6
 597               		.cfi_offset 28, -5
 598               	/* prologue: function */
 599               	/* frame size = 0 */
 600               	/* stack size = 4 */
 601               	.L__stack_usage = 4
 602 0008 6B01      		movw r12,r22
 603 000a E82E      		mov r14,r24
 246:main.c        ****   w = x^old_x;
 604               		.loc 1 246 0
 605 000c 0E94 0000 		call _pal_lld_getportfromline
 606               	.LVL58:
 607 0010 FC01      		movw r30,r24
 608 0012 C081      		ld r28,Z
 609 0014 8E2D      		mov r24,r14
 610 0016 B601      		movw r22,r12
 611 0018 0E94 0000 		call _pal_lld_getpadfromline
 612               	.LVL59:
 613 001c 2C2F      		mov r18,r28
 614 001e 30E0      		ldi r19,0
 615 0020 00C0      		rjmp 2f
 616               		1:
 617 0022 3595      		asr r19
 618 0024 2795      		ror r18
 619               		2:
 620 0026 8A95      		dec r24
 621 0028 02F4      		brpl 1b
 622 002a 922F      		mov r25,r18
 623 002c 9170      		andi r25,lo8(1)
 247:main.c        ****   old_x = x;
 624               		.loc 1 247 0
 625 002e 8091 0000 		lds r24,old_x.4096
 626 0032 8927      		eor r24,r25
 248:main.c        ****   return w &! x;
 627               		.loc 1 248 0
 628 0034 9093 0000 		sts old_x.4096,r25
 249:main.c        **** }
 629               		.loc 1 249 0
 630 0038 2095      		com r18
 631 003a 2170      		andi r18,lo8(1)
 250:main.c        **** 
 632               		.loc 1 250 0
 633 003c 8223      		and r24,r18
 634               	/* epilogue start */
 635 003e CF91      		pop r28
 636 0040 EF90      		pop r14
 637               	.LVL60:
 638 0042 DF90      		pop r13
 639 0044 CF90      		pop r12
 640 0046 0895      		ret
 641               		.cfi_endproc
 642               	.LFE248:
 644               		.section	.text.startup.main,"ax",@progbits
 645               	.global	main
 647               	main:
 648               	.LFB244:
 108:main.c        ****   queueInit();
 649               		.loc 1 108 0
 650               		.cfi_startproc
 651               	/* prologue: function */
 652               	/* frame size = 0 */
 653               	/* stack size = 0 */
 654               	.L__stack_usage = 0
 109:main.c        ****   /*
 655               		.loc 1 109 0
 656 0000 0E94 0000 		call queueInit
 657               	.LVL61:
 117:main.c        ****   chSysInit();
 658               		.loc 1 117 0
 659 0004 0E94 0000 		call halInit
 660               	.LVL62:
 118:main.c        **** 
 661               		.loc 1 118 0
 662 0008 0E94 0000 		call chSysInit
 663               	.LVL63:
 121:main.c        ****   palSetLineMode(SEC_FLAG, PAL_MODE_INPUT_PULLUP);
 664               		.loc 1 121 0
 665 000c 62E0      		ldi r22,lo8(2)
 666 000e 86E2      		ldi r24,lo8(38)
 667 0010 90E0      		ldi r25,0
 668 0012 0E94 0000 		call _pal_lld_setlineid
 669               	.LVL64:
 670 0016 0E94 0000 		call _pal_lld_getpadfromline
 671               	.LVL65:
 672 001a 182F      		mov r17,r24
 673 001c 62E0      		ldi r22,lo8(2)
 674 001e 86E2      		ldi r24,lo8(38)
 675 0020 90E0      		ldi r25,0
 676 0022 0E94 0000 		call _pal_lld_setlineid
 677               	.LVL66:
 678 0026 0E94 0000 		call _pal_lld_getportfromline
 679               	.LVL67:
 680 002a C1E0      		ldi r28,lo8(1)
 681 002c D0E0      		ldi r29,0
 682 002e BE01      		movw r22,r28
 683 0030 00C0      		rjmp 2f
 684               		1:
 685 0032 660F      		lsl r22
 686               		2:
 687 0034 1A95      		dec r17
 688 0036 02F4      		brpl 1b
 689 0038 43E0      		ldi r20,lo8(3)
 690 003a 0E94 0000 		call _pal_lld_setgroupmode
 691               	.LVL68:
 122:main.c        ****   palSetLineMode(AMB_PRIM, PAL_MODE_INPUT_PULLUP);
 692               		.loc 1 122 0
 693 003e 64E0      		ldi r22,lo8(4)
 694 0040 86E2      		ldi r24,lo8(38)
 695 0042 90E0      		ldi r25,0
 696 0044 0E94 0000 		call _pal_lld_setlineid
 697               	.LVL69:
 698 0048 0E94 0000 		call _pal_lld_getpadfromline
 699               	.LVL70:
 700 004c 182F      		mov r17,r24
 701 004e 64E0      		ldi r22,lo8(4)
 702 0050 86E2      		ldi r24,lo8(38)
 703 0052 90E0      		ldi r25,0
 704 0054 0E94 0000 		call _pal_lld_setlineid
 705               	.LVL71:
 706 0058 0E94 0000 		call _pal_lld_getportfromline
 707               	.LVL72:
 708 005c BE01      		movw r22,r28
 709 005e 00C0      		rjmp 2f
 710               		1:
 711 0060 660F      		lsl r22
 712               		2:
 713 0062 1A95      		dec r17
 714 0064 02F4      		brpl 1b
 715 0066 43E0      		ldi r20,lo8(3)
 716 0068 0E94 0000 		call _pal_lld_setgroupmode
 717               	.LVL73:
 123:main.c        ****   palSetLineMode(AMB_SEC, PAL_MODE_INPUT_PULLUP);
 718               		.loc 1 123 0
 719 006c 63E0      		ldi r22,lo8(3)
 720 006e 86E2      		ldi r24,lo8(38)
 721 0070 90E0      		ldi r25,0
 722 0072 0E94 0000 		call _pal_lld_setlineid
 723               	.LVL74:
 724 0076 0E94 0000 		call _pal_lld_getpadfromline
 725               	.LVL75:
 726 007a 182F      		mov r17,r24
 727 007c 63E0      		ldi r22,lo8(3)
 728 007e 86E2      		ldi r24,lo8(38)
 729 0080 90E0      		ldi r25,0
 730 0082 0E94 0000 		call _pal_lld_setlineid
 731               	.LVL76:
 732 0086 0E94 0000 		call _pal_lld_getportfromline
 733               	.LVL77:
 734 008a BE01      		movw r22,r28
 735 008c 00C0      		rjmp 2f
 736               		1:
 737 008e 660F      		lsl r22
 738               		2:
 739 0090 1A95      		dec r17
 740 0092 02F4      		brpl 1b
 741 0094 43E0      		ldi r20,lo8(3)
 742 0096 0E94 0000 		call _pal_lld_setgroupmode
 743               	.LVL78:
 124:main.c        **** 
 744               		.loc 1 124 0
 745 009a 65E0      		ldi r22,lo8(5)
 746 009c 86E2      		ldi r24,lo8(38)
 747 009e 90E0      		ldi r25,0
 748 00a0 0E94 0000 		call _pal_lld_setlineid
 749               	.LVL79:
 750 00a4 0E94 0000 		call _pal_lld_getpadfromline
 751               	.LVL80:
 752 00a8 182F      		mov r17,r24
 753 00aa 65E0      		ldi r22,lo8(5)
 754 00ac 86E2      		ldi r24,lo8(38)
 755 00ae 90E0      		ldi r25,0
 756 00b0 0E94 0000 		call _pal_lld_setlineid
 757               	.LVL81:
 758 00b4 0E94 0000 		call _pal_lld_getportfromline
 759               	.LVL82:
 760 00b8 BE01      		movw r22,r28
 761 00ba 00C0      		rjmp 2f
 762               		1:
 763 00bc 660F      		lsl r22
 764               		2:
 765 00be 1A95      		dec r17
 766 00c0 02F4      		brpl 1b
 767 00c2 43E0      		ldi r20,lo8(3)
 768 00c4 0E94 0000 		call _pal_lld_setgroupmode
 769               	.LVL83:
 127:main.c        ****   palClearLine(PEDESTRE_VERDE);
 770               		.loc 1 127 0
 771 00c8 63E0      		ldi r22,lo8(3)
 772 00ca 83E2      		ldi r24,lo8(35)
 773 00cc 90E0      		ldi r25,0
 774 00ce 0E94 0000 		call _pal_lld_setlineid
 775               	.LVL84:
 776 00d2 0E94 0000 		call _pal_lld_getpadfromline
 777               	.LVL85:
 778 00d6 182F      		mov r17,r24
 779 00d8 63E0      		ldi r22,lo8(3)
 780 00da 83E2      		ldi r24,lo8(35)
 781 00dc 90E0      		ldi r25,0
 782 00de 0E94 0000 		call _pal_lld_setlineid
 783               	.LVL86:
 784 00e2 0E94 0000 		call _pal_lld_getportfromline
 785               	.LVL87:
 786 00e6 BE01      		movw r22,r28
 787 00e8 00C0      		rjmp 2f
 788               		1:
 789 00ea 660F      		lsl r22
 790               		2:
 791 00ec 1A95      		dec r17
 792 00ee 02F4      		brpl 1b
 793 00f0 46E0      		ldi r20,lo8(6)
 794 00f2 0E94 0000 		call _pal_lld_setgroupmode
 795               	.LVL88:
 128:main.c        ****   palSetLineMode(PEDESTRE_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 796               		.loc 1 128 0
 797 00f6 63E0      		ldi r22,lo8(3)
 798 00f8 83E2      		ldi r24,lo8(35)
 799 00fa 90E0      		ldi r25,0
 800 00fc 0E94 0000 		call _pal_lld_setlineid
 801               	.LVL89:
 802 0100 0E94 0000 		call _pal_lld_getpadfromline
 803               	.LVL90:
 804 0104 182F      		mov r17,r24
 805 0106 63E0      		ldi r22,lo8(3)
 806 0108 83E2      		ldi r24,lo8(35)
 807 010a 90E0      		ldi r25,0
 808 010c 0E94 0000 		call _pal_lld_setlineid
 809               	.LVL91:
 810 0110 0E94 0000 		call _pal_lld_getportfromline
 811               	.LVL92:
 812 0114 FC01      		movw r30,r24
 813 0116 9281      		ldd r25,Z+2
 814 0118 9E01      		movw r18,r28
 815 011a 00C0      		rjmp 2f
 816               		1:
 817 011c 220F      		lsl r18
 818 011e 331F      		rol r19
 819               		2:
 820 0120 1A95      		dec r17
 821 0122 02F4      		brpl 1b
 822 0124 2095      		com r18
 823 0126 3095      		com r19
 824 0128 9223      		and r25,r18
 825 012a 9283      		std Z+2,r25
 129:main.c        ****   palClearLine(PEDESTRE_VERMELHO);
 826               		.loc 1 129 0
 827 012c 62E0      		ldi r22,lo8(2)
 828 012e 83E2      		ldi r24,lo8(35)
 829 0130 90E0      		ldi r25,0
 830 0132 0E94 0000 		call _pal_lld_setlineid
 831               	.LVL93:
 832 0136 0E94 0000 		call _pal_lld_getpadfromline
 833               	.LVL94:
 834 013a 182F      		mov r17,r24
 835 013c 62E0      		ldi r22,lo8(2)
 836 013e 83E2      		ldi r24,lo8(35)
 837 0140 90E0      		ldi r25,0
 838 0142 0E94 0000 		call _pal_lld_setlineid
 839               	.LVL95:
 840 0146 0E94 0000 		call _pal_lld_getportfromline
 841               	.LVL96:
 842 014a BE01      		movw r22,r28
 843 014c 00C0      		rjmp 2f
 844               		1:
 845 014e 660F      		lsl r22
 846               		2:
 847 0150 1A95      		dec r17
 848 0152 02F4      		brpl 1b
 849 0154 46E0      		ldi r20,lo8(6)
 850 0156 0E94 0000 		call _pal_lld_setgroupmode
 851               	.LVL97:
 130:main.c        **** 
 852               		.loc 1 130 0
 853 015a 62E0      		ldi r22,lo8(2)
 854 015c 83E2      		ldi r24,lo8(35)
 855 015e 90E0      		ldi r25,0
 856 0160 0E94 0000 		call _pal_lld_setlineid
 857               	.LVL98:
 858 0164 0E94 0000 		call _pal_lld_getpadfromline
 859               	.LVL99:
 860 0168 182F      		mov r17,r24
 861 016a 62E0      		ldi r22,lo8(2)
 862 016c 83E2      		ldi r24,lo8(35)
 863 016e 90E0      		ldi r25,0
 864 0170 0E94 0000 		call _pal_lld_setlineid
 865               	.LVL100:
 866 0174 0E94 0000 		call _pal_lld_getportfromline
 867               	.LVL101:
 868 0178 FC01      		movw r30,r24
 869 017a 9281      		ldd r25,Z+2
 870 017c 9E01      		movw r18,r28
 871 017e 00C0      		rjmp 2f
 872               		1:
 873 0180 220F      		lsl r18
 874 0182 331F      		rol r19
 875               		2:
 876 0184 1A95      		dec r17
 877 0186 02F4      		brpl 1b
 878 0188 2095      		com r18
 879 018a 3095      		com r19
 880 018c 9223      		and r25,r18
 881 018e 9283      		std Z+2,r25
 133:main.c        ****   palClearLine(PRIMARIO_VERDE);
 882               		.loc 1 133 0
 883 0190 67E0      		ldi r22,lo8(7)
 884 0192 89E2      		ldi r24,lo8(41)
 885 0194 90E0      		ldi r25,0
 886 0196 0E94 0000 		call _pal_lld_setlineid
 887               	.LVL102:
 888 019a 0E94 0000 		call _pal_lld_getpadfromline
 889               	.LVL103:
 890 019e 182F      		mov r17,r24
 891 01a0 67E0      		ldi r22,lo8(7)
 892 01a2 89E2      		ldi r24,lo8(41)
 893 01a4 90E0      		ldi r25,0
 894 01a6 0E94 0000 		call _pal_lld_setlineid
 895               	.LVL104:
 896 01aa 0E94 0000 		call _pal_lld_getportfromline
 897               	.LVL105:
 898 01ae BE01      		movw r22,r28
 899 01b0 00C0      		rjmp 2f
 900               		1:
 901 01b2 660F      		lsl r22
 902               		2:
 903 01b4 1A95      		dec r17
 904 01b6 02F4      		brpl 1b
 905 01b8 46E0      		ldi r20,lo8(6)
 906 01ba 0E94 0000 		call _pal_lld_setgroupmode
 907               	.LVL106:
 134:main.c        ****   palSetLineMode(PRIMARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
 908               		.loc 1 134 0
 909 01be 67E0      		ldi r22,lo8(7)
 910 01c0 89E2      		ldi r24,lo8(41)
 911 01c2 90E0      		ldi r25,0
 912 01c4 0E94 0000 		call _pal_lld_setlineid
 913               	.LVL107:
 914 01c8 0E94 0000 		call _pal_lld_getpadfromline
 915               	.LVL108:
 916 01cc 182F      		mov r17,r24
 917 01ce 67E0      		ldi r22,lo8(7)
 918 01d0 89E2      		ldi r24,lo8(41)
 919 01d2 90E0      		ldi r25,0
 920 01d4 0E94 0000 		call _pal_lld_setlineid
 921               	.LVL109:
 922 01d8 0E94 0000 		call _pal_lld_getportfromline
 923               	.LVL110:
 924 01dc FC01      		movw r30,r24
 925 01de 9281      		ldd r25,Z+2
 926 01e0 9E01      		movw r18,r28
 927 01e2 00C0      		rjmp 2f
 928               		1:
 929 01e4 220F      		lsl r18
 930 01e6 331F      		rol r19
 931               		2:
 932 01e8 1A95      		dec r17
 933 01ea 02F4      		brpl 1b
 934 01ec 2095      		com r18
 935 01ee 3095      		com r19
 936 01f0 9223      		and r25,r18
 937 01f2 9283      		std Z+2,r25
 135:main.c        ****   palClearLine(PRIMARIO_AMARELO);
 938               		.loc 1 135 0
 939 01f4 64E0      		ldi r22,lo8(4)
 940 01f6 89E2      		ldi r24,lo8(41)
 941 01f8 90E0      		ldi r25,0
 942 01fa 0E94 0000 		call _pal_lld_setlineid
 943               	.LVL111:
 944 01fe 0E94 0000 		call _pal_lld_getpadfromline
 945               	.LVL112:
 946 0202 182F      		mov r17,r24
 947 0204 64E0      		ldi r22,lo8(4)
 948 0206 89E2      		ldi r24,lo8(41)
 949 0208 90E0      		ldi r25,0
 950 020a 0E94 0000 		call _pal_lld_setlineid
 951               	.LVL113:
 952 020e 0E94 0000 		call _pal_lld_getportfromline
 953               	.LVL114:
 954 0212 BE01      		movw r22,r28
 955 0214 00C0      		rjmp 2f
 956               		1:
 957 0216 660F      		lsl r22
 958               		2:
 959 0218 1A95      		dec r17
 960 021a 02F4      		brpl 1b
 961 021c 46E0      		ldi r20,lo8(6)
 962 021e 0E94 0000 		call _pal_lld_setgroupmode
 963               	.LVL115:
 136:main.c        ****   palSetLineMode(PRIMARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 964               		.loc 1 136 0
 965 0222 64E0      		ldi r22,lo8(4)
 966 0224 89E2      		ldi r24,lo8(41)
 967 0226 90E0      		ldi r25,0
 968 0228 0E94 0000 		call _pal_lld_setlineid
 969               	.LVL116:
 970 022c 0E94 0000 		call _pal_lld_getpadfromline
 971               	.LVL117:
 972 0230 182F      		mov r17,r24
 973 0232 64E0      		ldi r22,lo8(4)
 974 0234 89E2      		ldi r24,lo8(41)
 975 0236 90E0      		ldi r25,0
 976 0238 0E94 0000 		call _pal_lld_setlineid
 977               	.LVL118:
 978 023c 0E94 0000 		call _pal_lld_getportfromline
 979               	.LVL119:
 980 0240 FC01      		movw r30,r24
 981 0242 9281      		ldd r25,Z+2
 982 0244 9E01      		movw r18,r28
 983 0246 00C0      		rjmp 2f
 984               		1:
 985 0248 220F      		lsl r18
 986 024a 331F      		rol r19
 987               		2:
 988 024c 1A95      		dec r17
 989 024e 02F4      		brpl 1b
 990 0250 2095      		com r18
 991 0252 3095      		com r19
 992 0254 9223      		and r25,r18
 993 0256 9283      		std Z+2,r25
 137:main.c        ****   palClearLine(PRIMARIO_VERMELHO);
 994               		.loc 1 137 0
 995 0258 66E0      		ldi r22,lo8(6)
 996 025a 89E2      		ldi r24,lo8(41)
 997 025c 90E0      		ldi r25,0
 998 025e 0E94 0000 		call _pal_lld_setlineid
 999               	.LVL120:
 1000 0262 0E94 0000 		call _pal_lld_getpadfromline
 1001               	.LVL121:
 1002 0266 182F      		mov r17,r24
 1003 0268 66E0      		ldi r22,lo8(6)
 1004 026a 89E2      		ldi r24,lo8(41)
 1005 026c 90E0      		ldi r25,0
 1006 026e 0E94 0000 		call _pal_lld_setlineid
 1007               	.LVL122:
 1008 0272 0E94 0000 		call _pal_lld_getportfromline
 1009               	.LVL123:
 1010 0276 BE01      		movw r22,r28
 1011 0278 00C0      		rjmp 2f
 1012               		1:
 1013 027a 660F      		lsl r22
 1014               		2:
 1015 027c 1A95      		dec r17
 1016 027e 02F4      		brpl 1b
 1017 0280 46E0      		ldi r20,lo8(6)
 1018 0282 0E94 0000 		call _pal_lld_setgroupmode
 1019               	.LVL124:
 138:main.c        **** 
 1020               		.loc 1 138 0
 1021 0286 66E0      		ldi r22,lo8(6)
 1022 0288 89E2      		ldi r24,lo8(41)
 1023 028a 90E0      		ldi r25,0
 1024 028c 0E94 0000 		call _pal_lld_setlineid
 1025               	.LVL125:
 1026 0290 0E94 0000 		call _pal_lld_getpadfromline
 1027               	.LVL126:
 1028 0294 182F      		mov r17,r24
 1029 0296 66E0      		ldi r22,lo8(6)
 1030 0298 89E2      		ldi r24,lo8(41)
 1031 029a 90E0      		ldi r25,0
 1032 029c 0E94 0000 		call _pal_lld_setlineid
 1033               	.LVL127:
 1034 02a0 0E94 0000 		call _pal_lld_getportfromline
 1035               	.LVL128:
 1036 02a4 FC01      		movw r30,r24
 1037 02a6 9281      		ldd r25,Z+2
 1038 02a8 9E01      		movw r18,r28
 1039 02aa 00C0      		rjmp 2f
 1040               		1:
 1041 02ac 220F      		lsl r18
 1042 02ae 331F      		rol r19
 1043               		2:
 1044 02b0 1A95      		dec r17
 1045 02b2 02F4      		brpl 1b
 1046 02b4 2095      		com r18
 1047 02b6 3095      		com r19
 1048 02b8 9223      		and r25,r18
 1049 02ba 9283      		std Z+2,r25
 141:main.c        ****   palClearLine(SECUNDARIO_VERDE);
 1050               		.loc 1 141 0
 1051 02bc 61E0      		ldi r22,lo8(1)
 1052 02be 83E2      		ldi r24,lo8(35)
 1053 02c0 90E0      		ldi r25,0
 1054 02c2 0E94 0000 		call _pal_lld_setlineid
 1055               	.LVL129:
 1056 02c6 0E94 0000 		call _pal_lld_getpadfromline
 1057               	.LVL130:
 1058 02ca 182F      		mov r17,r24
 1059 02cc 61E0      		ldi r22,lo8(1)
 1060 02ce 83E2      		ldi r24,lo8(35)
 1061 02d0 90E0      		ldi r25,0
 1062 02d2 0E94 0000 		call _pal_lld_setlineid
 1063               	.LVL131:
 1064 02d6 0E94 0000 		call _pal_lld_getportfromline
 1065               	.LVL132:
 1066 02da BE01      		movw r22,r28
 1067 02dc 00C0      		rjmp 2f
 1068               		1:
 1069 02de 660F      		lsl r22
 1070               		2:
 1071 02e0 1A95      		dec r17
 1072 02e2 02F4      		brpl 1b
 1073 02e4 46E0      		ldi r20,lo8(6)
 1074 02e6 0E94 0000 		call _pal_lld_setgroupmode
 1075               	.LVL133:
 142:main.c        ****   palSetLineMode(SECUNDARIO_AMARELO, PAL_MODE_OUTPUT_PUSHPULL);
 1076               		.loc 1 142 0
 1077 02ea 61E0      		ldi r22,lo8(1)
 1078 02ec 83E2      		ldi r24,lo8(35)
 1079 02ee 90E0      		ldi r25,0
 1080 02f0 0E94 0000 		call _pal_lld_setlineid
 1081               	.LVL134:
 1082 02f4 0E94 0000 		call _pal_lld_getpadfromline
 1083               	.LVL135:
 1084 02f8 182F      		mov r17,r24
 1085 02fa 61E0      		ldi r22,lo8(1)
 1086 02fc 83E2      		ldi r24,lo8(35)
 1087 02fe 90E0      		ldi r25,0
 1088 0300 0E94 0000 		call _pal_lld_setlineid
 1089               	.LVL136:
 1090 0304 0E94 0000 		call _pal_lld_getportfromline
 1091               	.LVL137:
 1092 0308 FC01      		movw r30,r24
 1093 030a 9281      		ldd r25,Z+2
 1094 030c 9E01      		movw r18,r28
 1095 030e 00C0      		rjmp 2f
 1096               		1:
 1097 0310 220F      		lsl r18
 1098 0312 331F      		rol r19
 1099               		2:
 1100 0314 1A95      		dec r17
 1101 0316 02F4      		brpl 1b
 1102 0318 2095      		com r18
 1103 031a 3095      		com r19
 1104 031c 9223      		and r25,r18
 1105 031e 9283      		std Z+2,r25
 143:main.c        ****   palClearLine(SECUNDARIO_AMARELO);
 1106               		.loc 1 143 0
 1107 0320 65E0      		ldi r22,lo8(5)
 1108 0322 89E2      		ldi r24,lo8(41)
 1109 0324 90E0      		ldi r25,0
 1110 0326 0E94 0000 		call _pal_lld_setlineid
 1111               	.LVL138:
 1112 032a 0E94 0000 		call _pal_lld_getpadfromline
 1113               	.LVL139:
 1114 032e 182F      		mov r17,r24
 1115 0330 65E0      		ldi r22,lo8(5)
 1116 0332 89E2      		ldi r24,lo8(41)
 1117 0334 90E0      		ldi r25,0
 1118 0336 0E94 0000 		call _pal_lld_setlineid
 1119               	.LVL140:
 1120 033a 0E94 0000 		call _pal_lld_getportfromline
 1121               	.LVL141:
 1122 033e BE01      		movw r22,r28
 1123 0340 00C0      		rjmp 2f
 1124               		1:
 1125 0342 660F      		lsl r22
 1126               		2:
 1127 0344 1A95      		dec r17
 1128 0346 02F4      		brpl 1b
 1129 0348 46E0      		ldi r20,lo8(6)
 1130 034a 0E94 0000 		call _pal_lld_setgroupmode
 1131               	.LVL142:
 144:main.c        ****   palSetLineMode(SECUNDARIO_VERMELHO, PAL_MODE_OUTPUT_PUSHPULL);
 1132               		.loc 1 144 0
 1133 034e 65E0      		ldi r22,lo8(5)
 1134 0350 89E2      		ldi r24,lo8(41)
 1135 0352 90E0      		ldi r25,0
 1136 0354 0E94 0000 		call _pal_lld_setlineid
 1137               	.LVL143:
 1138 0358 0E94 0000 		call _pal_lld_getpadfromline
 1139               	.LVL144:
 1140 035c 182F      		mov r17,r24
 1141 035e 65E0      		ldi r22,lo8(5)
 1142 0360 89E2      		ldi r24,lo8(41)
 1143 0362 90E0      		ldi r25,0
 1144 0364 0E94 0000 		call _pal_lld_setlineid
 1145               	.LVL145:
 1146 0368 0E94 0000 		call _pal_lld_getportfromline
 1147               	.LVL146:
 1148 036c FC01      		movw r30,r24
 1149 036e 9281      		ldd r25,Z+2
 1150 0370 9E01      		movw r18,r28
 1151 0372 00C0      		rjmp 2f
 1152               		1:
 1153 0374 220F      		lsl r18
 1154 0376 331F      		rol r19
 1155               		2:
 1156 0378 1A95      		dec r17
 1157 037a 02F4      		brpl 1b
 1158 037c 2095      		com r18
 1159 037e 3095      		com r19
 1160 0380 9223      		and r25,r18
 1161 0382 9283      		std Z+2,r25
 145:main.c        ****   palClearLine(SECUNDARIO_VERMELHO);
 1162               		.loc 1 145 0
 1163 0384 60E0      		ldi r22,0
 1164 0386 83E2      		ldi r24,lo8(35)
 1165 0388 90E0      		ldi r25,0
 1166 038a 0E94 0000 		call _pal_lld_setlineid
 1167               	.LVL147:
 1168 038e 0E94 0000 		call _pal_lld_getpadfromline
 1169               	.LVL148:
 1170 0392 182F      		mov r17,r24
 1171 0394 60E0      		ldi r22,0
 1172 0396 83E2      		ldi r24,lo8(35)
 1173 0398 90E0      		ldi r25,0
 1174 039a 0E94 0000 		call _pal_lld_setlineid
 1175               	.LVL149:
 1176 039e 0E94 0000 		call _pal_lld_getportfromline
 1177               	.LVL150:
 1178 03a2 BE01      		movw r22,r28
 1179 03a4 00C0      		rjmp 2f
 1180               		1:
 1181 03a6 660F      		lsl r22
 1182               		2:
 1183 03a8 1A95      		dec r17
 1184 03aa 02F4      		brpl 1b
 1185 03ac 46E0      		ldi r20,lo8(6)
 1186 03ae 0E94 0000 		call _pal_lld_setgroupmode
 1187               	.LVL151:
 146:main.c        **** 
 1188               		.loc 1 146 0
 1189 03b2 60E0      		ldi r22,0
 1190 03b4 83E2      		ldi r24,lo8(35)
 1191 03b6 90E0      		ldi r25,0
 1192 03b8 0E94 0000 		call _pal_lld_setlineid
 1193               	.LVL152:
 1194 03bc 0E94 0000 		call _pal_lld_getpadfromline
 1195               	.LVL153:
 1196 03c0 182F      		mov r17,r24
 1197 03c2 60E0      		ldi r22,0
 1198 03c4 83E2      		ldi r24,lo8(35)
 1199 03c6 90E0      		ldi r25,0
 1200 03c8 0E94 0000 		call _pal_lld_setlineid
 1201               	.LVL154:
 1202 03cc 0E94 0000 		call _pal_lld_getportfromline
 1203               	.LVL155:
 1204 03d0 FC01      		movw r30,r24
 1205 03d2 9281      		ldd r25,Z+2
 1206 03d4 9E01      		movw r18,r28
 1207 03d6 00C0      		rjmp 2f
 1208               		1:
 1209 03d8 220F      		lsl r18
 1210 03da 331F      		rol r19
 1211               		2:
 1212 03dc 1A95      		dec r17
 1213 03de 02F4      		brpl 1b
 1214 03e0 2095      		com r18
 1215 03e2 3095      		com r19
 1216 03e4 2923      		and r18,r25
 1217 03e6 2283      		std Z+2,r18
 151:main.c        **** 
 1218               		.loc 1 151 0
 1219 03e8 10E0      		ldi r17,0
 1220 03ea 00E0      		ldi r16,0
 1221 03ec 20E0      		ldi r18,lo8(gs(Thread1))
 1222 03ee 30E0      		ldi r19,hi8(gs(Thread1))
 1223 03f0 40E8      		ldi r20,lo8(-128)
 1224 03f2 63E8      		ldi r22,lo8(-125)
 1225 03f4 70E0      		ldi r23,0
 1226 03f6 80E0      		ldi r24,lo8(waThread1)
 1227 03f8 90E0      		ldi r25,hi8(waThread1)
 1228 03fa 0E94 0000 		call chThdCreateStatic
 1229               	.LVL156:
 1230 03fe 00C0      		rjmp .L44
 1231               	.L45:
 157:main.c        ****     }
 1232               		.loc 1 157 0
 1233 0400 84E0      		ldi r24,lo8(4)
 1234 0402 90E0      		ldi r25,0
 1235 0404 0E94 0000 		call enqueue
 1236               	.LVL157:
 1237               	.L41:
 172:main.c        ****   }
 1238               		.loc 1 172 0
 1239 0408 6EE0      		ldi r22,lo8(14)
 1240 040a 73E0      		ldi r23,lo8(3)
 1241 040c 80E0      		ldi r24,0
 1242 040e 90E0      		ldi r25,0
 1243 0410 0E94 0000 		call chThdSleep
 1244               	.LVL158:
 1245               	.L44:
 155:main.c        ****     {
 1246               		.loc 1 155 0
 1247 0414 65E0      		ldi r22,lo8(5)
 1248 0416 86E2      		ldi r24,lo8(38)
 1249 0418 90E0      		ldi r25,0
 1250 041a 0E94 0000 		call _pal_lld_setlineid
 1251               	.LVL159:
 1252 041e 0E94 0000 		call button_check
 1253               	.LVL160:
 1254 0422 8111      		cpse r24,__zero_reg__
 1255 0424 00C0      		rjmp .L45
 159:main.c        ****     {
 1256               		.loc 1 159 0
 1257 0426 63E0      		ldi r22,lo8(3)
 1258 0428 86E2      		ldi r24,lo8(38)
 1259 042a 90E0      		ldi r25,0
 1260 042c 0E94 0000 		call _pal_lld_setlineid
 1261               	.LVL161:
 1262 0430 0E94 0000 		call _pal_lld_getportfromline
 1263               	.LVL162:
 1264 0434 FC01      		movw r30,r24
 1265 0436 C081      		ld r28,Z
 1266 0438 63E0      		ldi r22,lo8(3)
 1267 043a 86E2      		ldi r24,lo8(38)
 1268 043c 90E0      		ldi r25,0
 1269 043e 0E94 0000 		call _pal_lld_setlineid
 1270               	.LVL163:
 1271 0442 0E94 0000 		call _pal_lld_getpadfromline
 1272               	.LVL164:
 1273 0446 2C2F      		mov r18,r28
 1274 0448 30E0      		ldi r19,0
 1275 044a 00C0      		rjmp 2f
 1276               		1:
 1277 044c 3595      		asr r19
 1278 044e 2795      		ror r18
 1279               		2:
 1280 0450 8A95      		dec r24
 1281 0452 02F4      		brpl 1b
 1282 0454 20FD      		sbrc r18,0
 1283 0456 00C0      		rjmp .L42
 161:main.c        ****     }
 1284               		.loc 1 161 0
 1285 0458 83E0      		ldi r24,lo8(3)
 1286 045a 90E0      		ldi r25,0
 1287 045c 0E94 0000 		call enqueue
 1288               	.LVL165:
 1289 0460 00C0      		rjmp .L41
 1290               	.L42:
 163:main.c        ****     {
 1291               		.loc 1 163 0
 1292 0462 64E0      		ldi r22,lo8(4)
 1293 0464 86E2      		ldi r24,lo8(38)
 1294 0466 90E0      		ldi r25,0
 1295 0468 0E94 0000 		call _pal_lld_setlineid
 1296               	.LVL166:
 1297 046c 0E94 0000 		call _pal_lld_getportfromline
 1298               	.LVL167:
 1299 0470 FC01      		movw r30,r24
 1300 0472 C081      		ld r28,Z
 1301 0474 64E0      		ldi r22,lo8(4)
 1302 0476 86E2      		ldi r24,lo8(38)
 1303 0478 90E0      		ldi r25,0
 1304 047a 0E94 0000 		call _pal_lld_setlineid
 1305               	.LVL168:
 1306 047e 0E94 0000 		call _pal_lld_getpadfromline
 1307               	.LVL169:
 1308 0482 2C2F      		mov r18,r28
 1309 0484 30E0      		ldi r19,0
 1310 0486 00C0      		rjmp 2f
 1311               		1:
 1312 0488 3595      		asr r19
 1313 048a 2795      		ror r18
 1314               		2:
 1315 048c 8A95      		dec r24
 1316 048e 02F4      		brpl 1b
 1317 0490 20FD      		sbrc r18,0
 1318 0492 00C0      		rjmp .L43
 165:main.c        ****     }
 1319               		.loc 1 165 0
 1320 0494 81E0      		ldi r24,lo8(1)
 1321 0496 90E0      		ldi r25,0
 1322 0498 0E94 0000 		call enqueue
 1323               	.LVL170:
 1324 049c 00C0      		rjmp .L41
 1325               	.L43:
 167:main.c        ****     {
 1326               		.loc 1 167 0
 1327 049e 62E0      		ldi r22,lo8(2)
 1328 04a0 86E2      		ldi r24,lo8(38)
 1329 04a2 90E0      		ldi r25,0
 1330 04a4 0E94 0000 		call _pal_lld_setlineid
 1331               	.LVL171:
 1332 04a8 0E94 0000 		call _pal_lld_getportfromline
 1333               	.LVL172:
 1334 04ac FC01      		movw r30,r24
 1335 04ae C081      		ld r28,Z
 1336 04b0 62E0      		ldi r22,lo8(2)
 1337 04b2 86E2      		ldi r24,lo8(38)
 1338 04b4 90E0      		ldi r25,0
 1339 04b6 0E94 0000 		call _pal_lld_setlineid
 1340               	.LVL173:
 1341 04ba 0E94 0000 		call _pal_lld_getpadfromline
 1342               	.LVL174:
 1343 04be 2C2F      		mov r18,r28
 1344 04c0 30E0      		ldi r19,0
 1345 04c2 00C0      		rjmp 2f
 1346               		1:
 1347 04c4 3595      		asr r19
 1348 04c6 2795      		ror r18
 1349               		2:
 1350 04c8 8A95      		dec r24
 1351 04ca 02F4      		brpl 1b
 1352 04cc 20FD      		sbrc r18,0
 1353 04ce 00C0      		rjmp .L41
 169:main.c        ****     }
 1354               		.loc 1 169 0
 1355 04d0 82E0      		ldi r24,lo8(2)
 1356 04d2 90E0      		ldi r25,0
 1357 04d4 0E94 0000 		call enqueue
 1358               	.LVL175:
 1359 04d8 00C0      		rjmp .L41
 1360               		.cfi_endproc
 1361               	.LFE244:
 1363               		.section	.bss.old_x.4096,"aw",@nobits
 1366               	old_x.4096:
 1367 0000 00        		.zero	1
 1368               		.section	.bss.waThread1,"aw",@nobits
 1371               	waThread1:
 1372 0000 0000 0000 		.zero	131
 1372      0000 0000 
 1372      0000 0000 
 1372      0000 0000 
 1372      0000 0000 
 1373               		.comm	ev_buffer,11,1
 1374               		.section	.bss.qfull,"aw",@nobits
 1377               	qfull:
 1378 0000 0000 0000 		.zero	4
 1379               		.section	.bss.qempty,"aw",@nobits
 1382               	qempty:
 1383 0000 0000 0000 		.zero	4
 1384               		.section	.bss.qmtx,"aw",@nobits
 1387               	qmtx:
 1388 0000 0000 0000 		.zero	8
 1388      0000 0000 
 1389               		.section	.bss.qsize,"aw",@nobits
 1392               	qsize:
 1393 0000 0000      		.zero	2
 1394               		.section	.bss.wrp,"aw",@nobits
 1397               	wrp:
 1398 0000 0000      		.zero	2
 1399               		.section	.bss.rdp,"aw",@nobits
 1402               	rdp:
 1403 0000 0000      		.zero	2
 1404               		.section	.bss.queue,"aw",@nobits
 1407               	queue:
 1408 0000 0000 0000 		.zero	256
 1408      0000 0000 
 1408      0000 0000 
 1408      0000 0000 
 1408      0000 0000 
 1409               		.text
 1410               	.Letext0:
 1411               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 1412               		.file 5 "/usr/lib/avr/include/stdint.h"
 1413               		.file 6 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 1414               		.file 7 "../../os/rt/include/chearly.h"
 1415               		.file 8 "../../os/rt/include/chobjects.h"
 1416               		.file 9 "../../os/rt/include/chrfcu.h"
 1417               		.file 10 "../../os/rt/include/chdebug.h"
 1418               		.file 11 "../../os/rt/include/chtime.h"
 1419               		.file 12 "../../os/rt/include/chlists.h"
 1420               		.file 13 "../../os/rt/include/chsem.h"
 1421               		.file 14 "../../os/rt/include/chmtx.h"
 1422               		.file 15 "../../os/rt/include/chsys.h"
 1423               		.file 16 "../../os/rt/include/chregistry.h"
 1424               		.file 17 "../../os/rt/include/chcond.h"
 1425               		.file 18 "../../os/rt/include/chevents.h"
 1426               		.file 19 "../../os/oslib/include/chmemcore.h"
 1427               		.file 20 "../../os/hal/include/hal_queues.h"
 1428               		.file 21 "../../os/hal/include/hal_pal.h"
 1429               		.file 22 "../../os/hal/ports/AVR/MEGA/LLD/GPIOv1/hal_pal_lld.h"
 1430               		.file 23 "../../os/hal/include/hal_serial.h"
 1431               		.file 24 "../../os/hal/ports/AVR/MEGA/LLD/USARTv1/hal_serial_lld.h"
 1432               		.file 25 "../../os/hal/include/hal.h"
 1433               		.file 26 "../../os/rt/include/chthreads.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccM7mVCt.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccM7mVCt.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccM7mVCt.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccM7mVCt.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccM7mVCt.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccM7mVCt.s:13     .text.vt_cb:0000000000000000 vt_cb
     /tmp/ccM7mVCt.s:92     .text.queueInit:0000000000000000 queueInit
     /tmp/ccM7mVCt.s:1387   .bss.qmtx:0000000000000000 qmtx
     /tmp/ccM7mVCt.s:1382   .bss.qempty:0000000000000000 qempty
     /tmp/ccM7mVCt.s:1377   .bss.qfull:0000000000000000 qfull
     /tmp/ccM7mVCt.s:1407   .bss.queue:0000000000000000 queue
     /tmp/ccM7mVCt.s:1397   .bss.wrp:0000000000000000 wrp
     /tmp/ccM7mVCt.s:1402   .bss.rdp:0000000000000000 rdp
     /tmp/ccM7mVCt.s:1392   .bss.qsize:0000000000000000 qsize
     /tmp/ccM7mVCt.s:134    .text.enqueue:0000000000000000 enqueue
     /tmp/ccM7mVCt.s:224    .text.dequeue:0000000000000000 dequeue
     /tmp/ccM7mVCt.s:311    .text.Thread1:0000000000000000 Thread1
     /tmp/ccM7mVCt.s:577    .text.button_check:0000000000000000 button_check
     /tmp/ccM7mVCt.s:1366   .bss.old_x.4096:0000000000000000 old_x.4096
     /tmp/ccM7mVCt.s:647    .text.startup.main:0000000000000000 main
     /tmp/ccM7mVCt.s:1371   .bss.waThread1:0000000000000000 waThread1
                            *COM*:000000000000000b ev_buffer

UNDEFINED SYMBOLS
chVTDoResetI
chVTDoSetI
chMtxObjectInit
chCondObjectInit
chMtxLock
chCondWait
chCondSignal
chMtxUnlock
chThdSleep
_pal_lld_setlineid
_pal_lld_getpadfromline
_pal_lld_getportfromline
halInit
chSysInit
_pal_lld_setgroupmode
chThdCreateStatic
__do_clear_bss
